/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CUDA_VERSION: u32 = 7050;
pub const CU_CTX_SCHED_BLOCKING_SYNC: u32 = 4;
pub const CU_EGL_FRAME_MAX_PLANES: u32 = 3;
pub const CU_STREAM_DEFAULT: u32 = 0;
pub const CU_STREAM_NON_BLOCKING: u32 = 1;
pub const CU_EVENT_DEFAULT: u32 = 0;
pub const CU_EVENT_BLOCKING_SYNC: u32 = 1;
pub const CU_EVENT_DISABLE_TIMING: u32 = 2;
pub const CU_EVENT_WAIT_DEFAULT: u32 = 0;
pub const CU_EVENT_WAIT_EXTERNAL: u32 = 1;
pub const CU_TRSF_READ_AS_INTEGER: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const NVENCAPI_MAJOR_VERSION: u32 = 13;
pub const NVENCAPI_MINOR_VERSION: u32 = 0;
pub const NVENCAPI_VERSION: u32 = 13;
pub const NVENC_INFINITE_GOPLENGTH: u32 = 4294967295;
pub const NV_MAX_SEQ_HDR_LEN: u32 = 512;
pub const MAX_NUM_VIEWS_MINUS_1: u32 = 7;
pub const MAX_NUM_CLOCK_TS: u32 = 3;
pub const MULTIVIEW_MAX_NUM_REF_DISPLAY: u32 = 32;
pub const NV_MAX_TILE_COLS_AV1: u32 = 64;
pub const NV_MAX_TILE_ROWS_AV1: u32 = 64;
pub const NVDECAPI_MAJOR_VERSION: u32 = 13;
pub const NVDECAPI_MINOR_VERSION: u32 = 0;
pub const NVDECAPI_VERSION: u32 = 13;
pub const I_VOP: u32 = 0;
pub const P_VOP: u32 = 1;
pub const B_VOP: u32 = 2;
pub const S_VOP: u32 = 3;
pub const MAX_CLOCK_TS: u32 = 3;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type CUdevice = ::std::os::raw::c_int;
pub type CUdeviceptr = ::std::os::raw::c_ulonglong;
pub type CUtexObject = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarray_st {
    _unused: [u8; 0],
}
pub type CUarray = *mut CUarray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type CUfunction = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmod_st {
    _unused: [u8; 0],
}
pub type CUmodule = *mut CUmod_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmipmappedArray_st {
    _unused: [u8; 0],
}
pub type CUmipmappedArray = *mut CUmipmappedArray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphicsResource_st {
    _unused: [u8; 0],
}
pub type CUgraphicsResource = *mut CUgraphicsResource_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextMemory_st {
    _unused: [u8; 0],
}
pub type CUexternalMemory = *mut CUextMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextSemaphore_st {
    _unused: [u8; 0],
}
pub type CUexternalSemaphore = *mut CUextSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUeglStreamConnection_st {
    _unused: [u8; 0],
}
pub type CUeglStreamConnection = *mut CUeglStreamConnection_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlinkState_st {
    _unused: [u8; 0],
}
pub type CUlinkState = *mut CUlinkState_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaError_enum {
    CUDA_SUCCESS = 0,
    CUDA_ERROR_NOT_READY = 600,
    CUDA_ERROR_LAUNCH_TIMEOUT = 702,
    CUDA_ERROR_UNKNOWN = 999,
}
pub use self::cudaError_enum as CUresult;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUdevice_attribute_enum {
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,
    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,
}
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUarray_format_enum {
    CU_AD_FORMAT_UNSIGNED_INT8 = 1,
    CU_AD_FORMAT_UNSIGNED_INT16 = 2,
    CU_AD_FORMAT_UNSIGNED_INT32 = 3,
    CU_AD_FORMAT_SIGNED_INT8 = 8,
    CU_AD_FORMAT_SIGNED_INT16 = 9,
    CU_AD_FORMAT_SIGNED_INT32 = 10,
    CU_AD_FORMAT_HALF = 16,
    CU_AD_FORMAT_FLOAT = 32,
}
pub use self::CUarray_format_enum as CUarray_format;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemorytype_enum {
    CU_MEMORYTYPE_HOST = 1,
    CU_MEMORYTYPE_DEVICE = 2,
    CU_MEMORYTYPE_ARRAY = 3,
}
pub use self::CUmemorytype_enum as CUmemorytype;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUlimit_enum {
    CU_LIMIT_STACK_SIZE = 0,
    CU_LIMIT_PRINTF_FIFO_SIZE = 1,
    CU_LIMIT_MALLOC_HEAP_SIZE = 2,
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = 3,
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 4,
}
pub use self::CUlimit_enum as CUlimit;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUresourcetype_enum {
    CU_RESOURCE_TYPE_ARRAY = 0,
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 1,
    CU_RESOURCE_TYPE_LINEAR = 2,
    CU_RESOURCE_TYPE_PITCH2D = 3,
}
pub use self::CUresourcetype_enum as CUresourcetype;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUaddress_mode_enum {
    CU_TR_ADDRESS_MODE_WRAP = 0,
    CU_TR_ADDRESS_MODE_CLAMP = 1,
    CU_TR_ADDRESS_MODE_MIRROR = 2,
    CU_TR_ADDRESS_MODE_BORDER = 3,
}
pub use self::CUaddress_mode_enum as CUaddress_mode;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUfilter_mode_enum {
    CU_TR_FILTER_MODE_POINT = 0,
    CU_TR_FILTER_MODE_LINEAR = 1,
}
pub use self::CUfilter_mode_enum as CUfilter_mode;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphicsRegisterFlags_enum {
    CU_GRAPHICS_REGISTER_FLAGS_NONE = 0,
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = 1,
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = 2,
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4,
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8,
}
pub use self::CUgraphicsRegisterFlags_enum as CUgraphicsRegisterFlags;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUexternalMemoryHandleType_enum {
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = 1,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = 4,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = 5,
}
pub use self::CUexternalMemoryHandleType_enum as CUexternalMemoryHandleType;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUexternalSemaphoreHandleType_enum {
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = 1,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = 4,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = 9,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10,
}
pub use self::CUexternalSemaphoreHandleType_enum as CUexternalSemaphoreHandleType;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUjit_option_enum {
    CU_JIT_MAX_REGISTERS = 0,
    CU_JIT_THREADS_PER_BLOCK = 1,
    CU_JIT_WALL_TIME = 2,
    CU_JIT_INFO_LOG_BUFFER = 3,
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES = 4,
    CU_JIT_ERROR_LOG_BUFFER = 5,
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = 6,
    CU_JIT_OPTIMIZATION_LEVEL = 7,
    CU_JIT_TARGET_FROM_CUCONTEXT = 8,
    CU_JIT_TARGET = 9,
    CU_JIT_FALLBACK_STRATEGY = 10,
    CU_JIT_GENERATE_DEBUG_INFO = 11,
    CU_JIT_LOG_VERBOSE = 12,
    CU_JIT_GENERATE_LINE_INFO = 13,
    CU_JIT_CACHE_MODE = 14,
    CU_JIT_NEW_SM3X_OPT = 15,
    CU_JIT_FAST_COMPILE = 16,
    CU_JIT_GLOBAL_SYMBOL_NAMES = 17,
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES = 18,
    CU_JIT_GLOBAL_SYMBOL_COUNT = 19,
    CU_JIT_NUM_OPTIONS = 20,
}
pub use self::CUjit_option_enum as CUjit_option;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUjitInputType_enum {
    CU_JIT_INPUT_CUBIN = 0,
    CU_JIT_INPUT_PTX = 1,
    CU_JIT_INPUT_FATBINARY = 2,
    CU_JIT_INPUT_OBJECT = 3,
    CU_JIT_INPUT_LIBRARY = 4,
    CU_JIT_NUM_INPUT_TYPES = 5,
}
pub use self::CUjitInputType_enum as CUjitInputType;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUeglFrameType {
    CU_EGL_FRAME_TYPE_ARRAY = 0,
    CU_EGL_FRAME_TYPE_PITCH = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUeglColorFormat {
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR = 0,
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR = 1,
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR = 21,
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR = 23,
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR = 25,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUd3d11DeviceList_enum {
    CU_D3D11_DEVICE_LIST_ALL = 1,
    CU_D3D11_DEVICE_LIST_CURRENT_FRAME = 2,
    CU_D3D11_DEVICE_LIST_NEXT_FRAME = 3,
}
pub use self::CUd3d11DeviceList_enum as CUd3d11DeviceList;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
pub type CUuuid = CUuuid_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_MEMCPY2D_st {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub srcPitch: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub dstPitch: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
}
impl Default for CUDA_MEMCPY2D_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_MEMCPY2D = CUDA_MEMCPY2D_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st {
    pub resType: CUresourcetype,
    pub res: CUDA_RESOURCE_DESC_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub hArray: CUarray,
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    pub hMipmappedArray: CUmipmappedArray,
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: CUdeviceptr,
    pub format: CUarray_format,
    pub numChannels: ::std::os::raw::c_uint,
    pub sizeInBytes: usize,
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: CUdeviceptr,
    pub format: CUarray_format,
    pub numChannels: ::std::os::raw::c_uint,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUDA_RESOURCE_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_RESOURCE_DESC = CUDA_RESOURCE_DESC_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct CUDA_TEXTURE_DESC_st {
    pub addressMode: [CUaddress_mode; 3usize],
    pub filterMode: CUfilter_mode,
    pub flags: ::std::os::raw::c_uint,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: CUfilter_mode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
impl Default for CUDA_TEXTURE_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_TEXTURE_DESC = CUDA_TEXTURE_DESC_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_VIEW_DESC_st {
    _unused: [u8; 0],
}
pub type CUDA_RESOURCE_VIEW_DESC = CUDA_RESOURCE_VIEW_DESC_st;
pub type GLenum = ::std::os::raw::c_uint;
pub type GLuint = ::std::os::raw::c_uint;
pub type ffnv_EGLint = i32;
pub type ffnv_EGLStreamKHR = *mut ::std::os::raw::c_void;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUGLDeviceList_enum {
    CU_GL_DEVICE_LIST_ALL = 1,
    CU_GL_DEVICE_LIST_CURRENT_FRAME = 2,
    CU_GL_DEVICE_LIST_NEXT_FRAME = 3,
}
pub use self::CUGLDeviceList_enum as CUGLDeviceList;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    pub type_: CUexternalMemoryHandleType,
    pub handle: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    pub type_: CUexternalSemaphoreHandleType,
    pub handle: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st;
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_ARRAY_DESCRIPTOR_st {
    pub Width: usize,
    pub Height: usize,
    pub Format: CUarray_format,
    pub NumChannels: ::std::os::raw::c_uint,
}
impl Default for CUDA_ARRAY_DESCRIPTOR_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_ARRAY_DESCRIPTOR = CUDA_ARRAY_DESCRIPTOR_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_ARRAY3D_DESCRIPTOR_st {
    pub Width: usize,
    pub Height: usize,
    pub Depth: usize,
    pub Format: CUarray_format,
    pub NumChannels: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_uint,
}
impl Default for CUDA_ARRAY3D_DESCRIPTOR_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_ARRAY3D_DESCRIPTOR = CUDA_ARRAY3D_DESCRIPTOR_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub arrayDesc: CUDA_ARRAY3D_DESCRIPTOR,
    pub numLevels: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
impl Default for CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC = CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUeglFrame_st {
    pub frame: CUeglFrame_st__bindgen_ty_1,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
    pub pitch: ::std::os::raw::c_uint,
    pub planeCount: ::std::os::raw::c_uint,
    pub numChannels: ::std::os::raw::c_uint,
    pub frameType: CUeglFrameType,
    pub eglColorFormat: CUeglColorFormat,
    pub cuFormat: CUarray_format,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUeglFrame_st__bindgen_ty_1 {
    pub pArray: [CUarray; 3usize],
    pub pPitch: [*mut ::std::os::raw::c_void; 3usize],
}
impl Default for CUeglFrame_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUeglFrame_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUeglFrame = CUeglFrame_st;
pub type CUstreamCallback = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        status: CUresult,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type tcuInit =
    ::std::option::Option<unsafe extern "C" fn(Flags: ::std::os::raw::c_uint) -> CUresult>;
pub type tcuDriverGetVersion = ::std::option::Option<
    unsafe extern "C" fn(driverVersion: *mut ::std::os::raw::c_int) -> CUresult,
>;
pub type tcuDeviceGetCount =
    ::std::option::Option<unsafe extern "C" fn(count: *mut ::std::os::raw::c_int) -> CUresult>;
pub type tcuDeviceGet = ::std::option::Option<
    unsafe extern "C" fn(device: *mut CUdevice, ordinal: ::std::os::raw::c_int) -> CUresult,
>;
pub type tcuDeviceGetAttribute = ::std::option::Option<
    unsafe extern "C" fn(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUdevice_attribute,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuDeviceGetName = ::std::option::Option<
    unsafe extern "C" fn(
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuDeviceGetUuid =
    ::std::option::Option<unsafe extern "C" fn(uuid: *mut CUuuid, dev: CUdevice) -> CUresult>;
pub type tcuDeviceGetUuid_v2 =
    ::std::option::Option<unsafe extern "C" fn(uuid: *mut CUuuid, dev: CUdevice) -> CUresult>;
pub type tcuDeviceGetLuid = ::std::option::Option<
    unsafe extern "C" fn(
        luid: *mut ::std::os::raw::c_char,
        deviceNodeMask: *mut ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuDeviceGetByPCIBusId = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut CUdevice, pciBusId: *const ::std::os::raw::c_char) -> CUresult,
>;
pub type tcuDeviceGetPCIBusId = ::std::option::Option<
    unsafe extern "C" fn(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuDeviceComputeCapability = ::std::option::Option<
    unsafe extern "C" fn(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuCtxCreate_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        pctx: *mut CUcontext,
        flags: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuCtxGetCurrent =
    ::std::option::Option<unsafe extern "C" fn(pctx: *mut CUcontext) -> CUresult>;
pub type tcuCtxSetLimit =
    ::std::option::Option<unsafe extern "C" fn(limit: CUlimit, value: usize) -> CUresult>;
pub type tcuCtxPushCurrent_v2 =
    ::std::option::Option<unsafe extern "C" fn(pctx: CUcontext) -> CUresult>;
pub type tcuCtxPopCurrent_v2 =
    ::std::option::Option<unsafe extern "C" fn(pctx: *mut CUcontext) -> CUresult>;
pub type tcuCtxDestroy_v2 = ::std::option::Option<unsafe extern "C" fn(ctx: CUcontext) -> CUresult>;
pub type tcuMemAlloc_v2 = ::std::option::Option<
    unsafe extern "C" fn(dptr: *mut CUdeviceptr, bytesize: usize) -> CUresult,
>;
pub type tcuMemAllocPitch_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dptr: *mut CUdeviceptr,
        pPitch: *mut usize,
        WidthInBytes: usize,
        Height: usize,
        ElementSizeBytes: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuMemAllocManaged = ::std::option::Option<
    unsafe extern "C" fn(
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuMemsetD8Async = ::std::option::Option<
    unsafe extern "C" fn(
        dstDevice: CUdeviceptr,
        uc: ::std::os::raw::c_uchar,
        N: usize,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuMemFree_v2 = ::std::option::Option<unsafe extern "C" fn(dptr: CUdeviceptr) -> CUresult>;
pub type tcuMemcpy = ::std::option::Option<
    unsafe extern "C" fn(dst: CUdeviceptr, src: CUdeviceptr, bytesize: usize) -> CUresult,
>;
pub type tcuMemcpyAsync = ::std::option::Option<
    unsafe extern "C" fn(
        dst: CUdeviceptr,
        src: CUdeviceptr,
        bytesize: usize,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuMemcpy2D_v2 =
    ::std::option::Option<unsafe extern "C" fn(pcopy: *const CUDA_MEMCPY2D) -> CUresult>;
pub type tcuMemcpy2DAsync_v2 = ::std::option::Option<
    unsafe extern "C" fn(pcopy: *const CUDA_MEMCPY2D, hStream: CUstream) -> CUresult,
>;
pub type tcuMemcpyHtoD_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
    ) -> CUresult,
>;
pub type tcuMemcpyHtoDAsync_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuMemcpyDtoH_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult,
>;
pub type tcuMemcpyDtoHAsync_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuMemcpyDtoD_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult,
>;
pub type tcuMemcpyDtoDAsync_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuGetErrorName = ::std::option::Option<
    unsafe extern "C" fn(error: CUresult, pstr: *mut *const ::std::os::raw::c_char) -> CUresult,
>;
pub type tcuGetErrorString = ::std::option::Option<
    unsafe extern "C" fn(error: CUresult, pstr: *mut *const ::std::os::raw::c_char) -> CUresult,
>;
pub type tcuCtxGetDevice =
    ::std::option::Option<unsafe extern "C" fn(device: *mut CUdevice) -> CUresult>;
pub type tcuDevicePrimaryCtxRetain =
    ::std::option::Option<unsafe extern "C" fn(pctx: *mut CUcontext, dev: CUdevice) -> CUresult>;
pub type tcuDevicePrimaryCtxRelease =
    ::std::option::Option<unsafe extern "C" fn(dev: CUdevice) -> CUresult>;
pub type tcuDevicePrimaryCtxSetFlags = ::std::option::Option<
    unsafe extern "C" fn(dev: CUdevice, flags: ::std::os::raw::c_uint) -> CUresult,
>;
pub type tcuDevicePrimaryCtxGetState = ::std::option::Option<
    unsafe extern "C" fn(
        dev: CUdevice,
        flags: *mut ::std::os::raw::c_uint,
        active: *mut ::std::os::raw::c_int,
    ) -> CUresult,
>;
pub type tcuDevicePrimaryCtxReset =
    ::std::option::Option<unsafe extern "C" fn(dev: CUdevice) -> CUresult>;
pub type tcuStreamCreate = ::std::option::Option<
    unsafe extern "C" fn(phStream: *mut CUstream, flags: ::std::os::raw::c_uint) -> CUresult,
>;
pub type tcuStreamQuery =
    ::std::option::Option<unsafe extern "C" fn(hStream: CUstream) -> CUresult>;
pub type tcuStreamSynchronize =
    ::std::option::Option<unsafe extern "C" fn(hStream: CUstream) -> CUresult>;
pub type tcuStreamDestroy_v2 =
    ::std::option::Option<unsafe extern "C" fn(hStream: CUstream) -> CUresult>;
pub type tcuStreamAddCallback = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        callback: CUstreamCallback,
        userdata: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuStreamWaitEvent = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        hEvent: CUevent,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuEventCreate = ::std::option::Option<
    unsafe extern "C" fn(phEvent: *mut CUevent, flags: ::std::os::raw::c_uint) -> CUresult,
>;
pub type tcuEventDestroy_v2 =
    ::std::option::Option<unsafe extern "C" fn(hEvent: CUevent) -> CUresult>;
pub type tcuEventSynchronize =
    ::std::option::Option<unsafe extern "C" fn(hEvent: CUevent) -> CUresult>;
pub type tcuEventQuery = ::std::option::Option<unsafe extern "C" fn(hEvent: CUevent) -> CUresult>;
pub type tcuEventRecord =
    ::std::option::Option<unsafe extern "C" fn(hEvent: CUevent, hStream: CUstream) -> CUresult>;
pub type tcuLaunchKernel = ::std::option::Option<
    unsafe extern "C" fn(
        f: CUfunction,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult,
>;
pub type tcuLinkCreate = ::std::option::Option<
    unsafe extern "C" fn(
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
        stateOut: *mut CUlinkState,
    ) -> CUresult,
>;
pub type tcuLinkAddData = ::std::option::Option<
    unsafe extern "C" fn(
        state: CUlinkState,
        type_: CUjitInputType,
        data: *mut ::std::os::raw::c_void,
        size: usize,
        name: *const ::std::os::raw::c_char,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult,
>;
pub type tcuLinkComplete = ::std::option::Option<
    unsafe extern "C" fn(
        state: CUlinkState,
        cubinOut: *mut *mut ::std::os::raw::c_void,
        sizeOut: *mut usize,
    ) -> CUresult,
>;
pub type tcuLinkDestroy =
    ::std::option::Option<unsafe extern "C" fn(state: CUlinkState) -> CUresult>;
pub type tcuModuleLoadData = ::std::option::Option<
    unsafe extern "C" fn(module: *mut CUmodule, image: *const ::std::os::raw::c_void) -> CUresult,
>;
pub type tcuModuleUnload = ::std::option::Option<unsafe extern "C" fn(hmod: CUmodule) -> CUresult>;
pub type tcuModuleGetFunction = ::std::option::Option<
    unsafe extern "C" fn(
        hfunc: *mut CUfunction,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult,
>;
pub type tcuModuleGetGlobal = ::std::option::Option<
    unsafe extern "C" fn(
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult,
>;
pub type tcuTexObjectCreate = ::std::option::Option<
    unsafe extern "C" fn(
        pTexObject: *mut CUtexObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
        pTexDesc: *const CUDA_TEXTURE_DESC,
        pResViewDesc: *const CUDA_RESOURCE_VIEW_DESC,
    ) -> CUresult,
>;
pub type tcuTexObjectDestroy =
    ::std::option::Option<unsafe extern "C" fn(texObject: CUtexObject) -> CUresult>;
pub type tcuGLGetDevices_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        pCudaDeviceCount: *mut ::std::os::raw::c_uint,
        pCudaDevices: *mut CUdevice,
        cudaDeviceCount: ::std::os::raw::c_uint,
        deviceList: CUGLDeviceList,
    ) -> CUresult,
>;
pub type tcuGraphicsGLRegisterImage = ::std::option::Option<
    unsafe extern "C" fn(
        pCudaResource: *mut CUgraphicsResource,
        image: GLuint,
        target: GLenum,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuGraphicsUnregisterResource =
    ::std::option::Option<unsafe extern "C" fn(resource: CUgraphicsResource) -> CUresult>;
pub type tcuGraphicsMapResources = ::std::option::Option<
    unsafe extern "C" fn(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuGraphicsUnmapResources = ::std::option::Option<
    unsafe extern "C" fn(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuGraphicsSubResourceGetMappedArray = ::std::option::Option<
    unsafe extern "C" fn(
        pArray: *mut CUarray,
        resource: CUgraphicsResource,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuGraphicsResourceGetMappedPointer = ::std::option::Option<
    unsafe extern "C" fn(
        devPtrOut: *mut CUdeviceptr,
        sizeOut: *mut usize,
        resource: CUgraphicsResource,
    ) -> CUresult,
>;
pub type tcuImportExternalMemory = ::std::option::Option<
    unsafe extern "C" fn(
        extMem_out: *mut CUexternalMemory,
        memHandleDesc: *const CUDA_EXTERNAL_MEMORY_HANDLE_DESC,
    ) -> CUresult,
>;
pub type tcuDestroyExternalMemory =
    ::std::option::Option<unsafe extern "C" fn(extMem: CUexternalMemory) -> CUresult>;
pub type tcuExternalMemoryGetMappedBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        devPtr: *mut CUdeviceptr,
        extMem: CUexternalMemory,
        bufferDesc: *const CUDA_EXTERNAL_MEMORY_BUFFER_DESC,
    ) -> CUresult,
>;
pub type tcuExternalMemoryGetMappedMipmappedArray = ::std::option::Option<
    unsafe extern "C" fn(
        mipmap: *mut CUmipmappedArray,
        extMem: CUexternalMemory,
        mipmapDesc: *const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC,
    ) -> CUresult,
>;
pub type tcuMipmappedArrayGetLevel = ::std::option::Option<
    unsafe extern "C" fn(
        pLevelArray: *mut CUarray,
        hMipmappedArray: CUmipmappedArray,
        level: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuMipmappedArrayDestroy =
    ::std::option::Option<unsafe extern "C" fn(hMipmappedArray: CUmipmappedArray) -> CUresult>;
pub type tcuImportExternalSemaphore = ::std::option::Option<
    unsafe extern "C" fn(
        extSem_out: *mut CUexternalSemaphore,
        semHandleDesc: *const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC,
    ) -> CUresult,
>;
pub type tcuDestroyExternalSemaphore =
    ::std::option::Option<unsafe extern "C" fn(extSem: CUexternalSemaphore) -> CUresult>;
pub type tcuSignalExternalSemaphoresAsync = ::std::option::Option<
    unsafe extern "C" fn(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult,
>;
pub type tcuWaitExternalSemaphoresAsync = ::std::option::Option<
    unsafe extern "C" fn(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult,
>;
pub type tcuArrayCreate = ::std::option::Option<
    unsafe extern "C" fn(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY_DESCRIPTOR,
    ) -> CUresult,
>;
pub type tcuArray3DCreate = ::std::option::Option<
    unsafe extern "C" fn(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY3D_DESCRIPTOR,
    ) -> CUresult,
>;
pub type tcuArrayDestroy = ::std::option::Option<unsafe extern "C" fn(hArray: CUarray) -> CUresult>;
pub type tcuEGLStreamProducerConnect = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut CUeglStreamConnection,
        stream: ffnv_EGLStreamKHR,
        width: ffnv_EGLint,
        height: ffnv_EGLint,
    ) -> CUresult,
>;
pub type tcuEGLStreamProducerDisconnect =
    ::std::option::Option<unsafe extern "C" fn(conn: *mut CUeglStreamConnection) -> CUresult>;
pub type tcuEGLStreamConsumerDisconnect =
    ::std::option::Option<unsafe extern "C" fn(conn: *mut CUeglStreamConnection) -> CUresult>;
pub type tcuEGLStreamProducerPresentFrame = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut CUeglStreamConnection,
        eglframe: CUeglFrame,
        pStream: *mut CUstream,
    ) -> CUresult,
>;
pub type tcuEGLStreamProducerReturnFrame = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut CUeglStreamConnection,
        eglframe: *mut CUeglFrame,
        pStream: *mut CUstream,
    ) -> CUresult,
>;
pub type tcuD3D11GetDevice = ::std::option::Option<
    unsafe extern "C" fn(
        device: *mut CUdevice,
        dxgiAdapter: *mut ::std::os::raw::c_void,
    ) -> CUresult,
>;
pub type tcuD3D11GetDevices = ::std::option::Option<
    unsafe extern "C" fn(
        deviceCountOut: *mut ::std::os::raw::c_uint,
        devices: *mut CUdevice,
        deviceCount: ::std::os::raw::c_uint,
        d3d11device: *mut ::std::os::raw::c_void,
        listType: CUd3d11DeviceList,
    ) -> CUresult,
>;
pub type tcuGraphicsD3D11RegisterResource = ::std::option::Option<
    unsafe extern "C" fn(
        cudaResourceOut: *mut CUgraphicsResource,
        d3d11Resource: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GUID {
    pub Data1: u32,
    pub Data2: u16,
    pub Data3: u16,
    pub Data4: [u8; 8usize],
}
pub type GUID = _GUID;
pub type LPGUID = *mut _GUID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVENC_RECT {
    pub left: u32,
    pub top: u32,
    pub right: u32,
    pub bottom: u32,
}
pub type NVENC_RECT = _NVENC_RECT;
pub type NV_ENC_INPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_OUTPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_REGISTERED_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_CUSTREAM_PTR = *mut ::std::os::raw::c_void;
unsafe extern "C" {
    pub static NV_ENC_CODEC_H264_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_CODEC_HEVC_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_CODEC_AV1_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_BASELINE_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_MAIN_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_HIGH_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_HIGH_10_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_HIGH_422_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_HIGH_444_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_STEREO_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_HEVC_PROFILE_MAIN_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_HEVC_PROFILE_MAIN10_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_HEVC_PROFILE_FREXT_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_AV1_PROFILE_MAIN_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_P1_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_P2_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_P3_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_P4_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_P5_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_P6_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_P7_GUID: GUID;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_PARAMS_FRAME_FIELD_MODE {
    NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME = 1,
    NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD = 2,
    NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF = 3,
}
pub use self::_NV_ENC_PARAMS_FRAME_FIELD_MODE as NV_ENC_PARAMS_FRAME_FIELD_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_PARAMS_RC_MODE {
    NV_ENC_PARAMS_RC_CONSTQP = 0,
    NV_ENC_PARAMS_RC_VBR = 1,
    NV_ENC_PARAMS_RC_CBR = 2,
}
pub use self::_NV_ENC_PARAMS_RC_MODE as NV_ENC_PARAMS_RC_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_MULTI_PASS {
    NV_ENC_MULTI_PASS_DISABLED = 0,
    NV_ENC_TWO_PASS_QUARTER_RESOLUTION = 1,
    NV_ENC_TWO_PASS_FULL_RESOLUTION = 2,
}
pub use self::_NV_ENC_MULTI_PASS as NV_ENC_MULTI_PASS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_STATE_RESTORE_TYPE {
    NV_ENC_STATE_RESTORE_FULL = 1,
    NV_ENC_STATE_RESTORE_RATE_CONTROL = 2,
    NV_ENC_STATE_RESTORE_ENCODE = 3,
}
pub use self::_NV_ENC_STATE_RESTORE_TYPE as NV_ENC_STATE_RESTORE_TYPE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_OUTPUT_STATS_LEVEL {
    NV_ENC_OUTPUT_STATS_NONE = 0,
    NV_ENC_OUTPUT_STATS_BLOCK_LEVEL = 1,
    NV_ENC_OUTPUT_STATS_ROW_LEVEL = 2,
}
pub use self::_NV_ENC_OUTPUT_STATS_LEVEL as NV_ENC_OUTPUT_STATS_LEVEL;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_EMPHASIS_MAP_LEVEL {
    NV_ENC_EMPHASIS_MAP_LEVEL_0 = 0,
    NV_ENC_EMPHASIS_MAP_LEVEL_1 = 1,
    NV_ENC_EMPHASIS_MAP_LEVEL_2 = 2,
    NV_ENC_EMPHASIS_MAP_LEVEL_3 = 3,
    NV_ENC_EMPHASIS_MAP_LEVEL_4 = 4,
    NV_ENC_EMPHASIS_MAP_LEVEL_5 = 5,
}
pub use self::_NV_ENC_EMPHASIS_MAP_LEVEL as NV_ENC_EMPHASIS_MAP_LEVEL;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_QP_MAP_MODE {
    NV_ENC_QP_MAP_DISABLED = 0,
    NV_ENC_QP_MAP_EMPHASIS = 1,
    NV_ENC_QP_MAP_DELTA = 2,
    NV_ENC_QP_MAP = 3,
}
pub use self::_NV_ENC_QP_MAP_MODE as NV_ENC_QP_MAP_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_PIC_STRUCT {
    NV_ENC_PIC_STRUCT_FRAME = 1,
    NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM = 2,
    NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP = 3,
}
pub use self::_NV_ENC_PIC_STRUCT as NV_ENC_PIC_STRUCT;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_DISPLAY_PIC_STRUCT {
    NV_ENC_PIC_STRUCT_DISPLAY_FRAME = 0,
    NV_ENC_PIC_STRUCT_DISPLAY_FIELD_TOP_BOTTOM = 1,
    NV_ENC_PIC_STRUCT_DISPLAY_FIELD_BOTTOM_TOP = 2,
    NV_ENC_PIC_STRUCT_DISPLAY_FRAME_DOUBLING = 3,
    NV_ENC_PIC_STRUCT_DISPLAY_FRAME_TRIPLING = 4,
}
pub use self::_NV_ENC_DISPLAY_PIC_STRUCT as NV_ENC_DISPLAY_PIC_STRUCT;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_PIC_TYPE {
    NV_ENC_PIC_TYPE_P = 0,
    NV_ENC_PIC_TYPE_B = 1,
    NV_ENC_PIC_TYPE_I = 2,
    NV_ENC_PIC_TYPE_IDR = 3,
    NV_ENC_PIC_TYPE_BI = 4,
    NV_ENC_PIC_TYPE_SKIPPED = 5,
    NV_ENC_PIC_TYPE_INTRA_REFRESH = 6,
    NV_ENC_PIC_TYPE_NONREF_P = 7,
    NV_ENC_PIC_TYPE_SWITCH = 8,
    NV_ENC_PIC_TYPE_UNKNOWN = 255,
}
pub use self::_NV_ENC_PIC_TYPE as NV_ENC_PIC_TYPE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_MV_PRECISION {
    NV_ENC_MV_PRECISION_DEFAULT = 0,
    NV_ENC_MV_PRECISION_FULL_PEL = 1,
    NV_ENC_MV_PRECISION_HALF_PEL = 2,
    NV_ENC_MV_PRECISION_QUARTER_PEL = 3,
}
pub use self::_NV_ENC_MV_PRECISION as NV_ENC_MV_PRECISION;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_BUFFER_FORMAT {
    NV_ENC_BUFFER_FORMAT_UNDEFINED = 0,
    NV_ENC_BUFFER_FORMAT_NV12 = 1,
    NV_ENC_BUFFER_FORMAT_YV12 = 16,
    NV_ENC_BUFFER_FORMAT_IYUV = 256,
    NV_ENC_BUFFER_FORMAT_YUV444 = 4096,
    NV_ENC_BUFFER_FORMAT_YUV420_10BIT = 65536,
    NV_ENC_BUFFER_FORMAT_YUV444_10BIT = 1048576,
    NV_ENC_BUFFER_FORMAT_ARGB = 16777216,
    NV_ENC_BUFFER_FORMAT_ARGB10 = 33554432,
    NV_ENC_BUFFER_FORMAT_AYUV = 67108864,
    NV_ENC_BUFFER_FORMAT_ABGR = 268435456,
    NV_ENC_BUFFER_FORMAT_ABGR10 = 536870912,
    NV_ENC_BUFFER_FORMAT_U8 = 1073741824,
    NV_ENC_BUFFER_FORMAT_NV16 = 1073741825,
    NV_ENC_BUFFER_FORMAT_P210 = 1073741826,
}
pub use self::_NV_ENC_BUFFER_FORMAT as NV_ENC_BUFFER_FORMAT;
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_HEVC_1: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_3;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_HEVC_2: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_60;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_HEVC_MAIN: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_2: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_21: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_TIER_HEVC_HIGH;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_41: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1b;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_42: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_43: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_11;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_5: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_12;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_51: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_13;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_7: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_2;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_71: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_21;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_72: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_22;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_AV1_0: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_AV1_1: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_TIER_HEVC_HIGH;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_LEVEL {
    NV_ENC_LEVEL_AUTOSELECT = 0,
    NV_ENC_LEVEL_H264_1 = 10,
    NV_ENC_LEVEL_H264_1b = 9,
    NV_ENC_LEVEL_H264_11 = 11,
    NV_ENC_LEVEL_H264_12 = 12,
    NV_ENC_LEVEL_H264_13 = 13,
    NV_ENC_LEVEL_H264_2 = 20,
    NV_ENC_LEVEL_H264_21 = 21,
    NV_ENC_LEVEL_H264_22 = 22,
    NV_ENC_LEVEL_H264_3 = 30,
    NV_ENC_LEVEL_H264_31 = 31,
    NV_ENC_LEVEL_H264_32 = 32,
    NV_ENC_LEVEL_H264_4 = 40,
    NV_ENC_LEVEL_H264_41 = 41,
    NV_ENC_LEVEL_H264_42 = 42,
    NV_ENC_LEVEL_H264_5 = 50,
    NV_ENC_LEVEL_H264_51 = 51,
    NV_ENC_LEVEL_H264_52 = 52,
    NV_ENC_LEVEL_H264_60 = 60,
    NV_ENC_LEVEL_H264_61 = 61,
    NV_ENC_LEVEL_H264_62 = 62,
    NV_ENC_LEVEL_HEVC_21 = 63,
    NV_ENC_LEVEL_HEVC_3 = 90,
    NV_ENC_LEVEL_HEVC_31 = 93,
    NV_ENC_LEVEL_HEVC_4 = 120,
    NV_ENC_LEVEL_HEVC_41 = 123,
    NV_ENC_LEVEL_HEVC_5 = 150,
    NV_ENC_LEVEL_HEVC_51 = 153,
    NV_ENC_LEVEL_HEVC_52 = 156,
    NV_ENC_LEVEL_HEVC_6 = 180,
    NV_ENC_LEVEL_HEVC_61 = 183,
    NV_ENC_LEVEL_HEVC_62 = 186,
    NV_ENC_TIER_HEVC_HIGH = 1,
    NV_ENC_LEVEL_AV1_22 = 2,
    NV_ENC_LEVEL_AV1_23 = 3,
    NV_ENC_LEVEL_AV1_3 = 4,
    NV_ENC_LEVEL_AV1_31 = 5,
    NV_ENC_LEVEL_AV1_32 = 6,
    NV_ENC_LEVEL_AV1_33 = 7,
    NV_ENC_LEVEL_AV1_4 = 8,
    NV_ENC_LEVEL_AV1_52 = 14,
    NV_ENC_LEVEL_AV1_53 = 15,
    NV_ENC_LEVEL_AV1_6 = 16,
    NV_ENC_LEVEL_AV1_61 = 17,
    NV_ENC_LEVEL_AV1_62 = 18,
    NV_ENC_LEVEL_AV1_63 = 19,
    NV_ENC_LEVEL_AV1_73 = 23,
    NV_ENC_LEVEL_AV1_AUTOSELECT = 24,
}
pub use self::_NV_ENC_LEVEL as NV_ENC_LEVEL;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NVENCSTATUS {
    NV_ENC_SUCCESS = 0,
    NV_ENC_ERR_NO_ENCODE_DEVICE = 1,
    NV_ENC_ERR_UNSUPPORTED_DEVICE = 2,
    NV_ENC_ERR_INVALID_ENCODERDEVICE = 3,
    NV_ENC_ERR_INVALID_DEVICE = 4,
    NV_ENC_ERR_DEVICE_NOT_EXIST = 5,
    NV_ENC_ERR_INVALID_PTR = 6,
    NV_ENC_ERR_INVALID_EVENT = 7,
    NV_ENC_ERR_INVALID_PARAM = 8,
    NV_ENC_ERR_INVALID_CALL = 9,
    NV_ENC_ERR_OUT_OF_MEMORY = 10,
    NV_ENC_ERR_ENCODER_NOT_INITIALIZED = 11,
    NV_ENC_ERR_UNSUPPORTED_PARAM = 12,
    NV_ENC_ERR_LOCK_BUSY = 13,
    NV_ENC_ERR_NOT_ENOUGH_BUFFER = 14,
    NV_ENC_ERR_INVALID_VERSION = 15,
    NV_ENC_ERR_MAP_FAILED = 16,
    NV_ENC_ERR_NEED_MORE_INPUT = 17,
    NV_ENC_ERR_ENCODER_BUSY = 18,
    NV_ENC_ERR_EVENT_NOT_REGISTERD = 19,
    NV_ENC_ERR_GENERIC = 20,
    NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY = 21,
    NV_ENC_ERR_UNIMPLEMENTED = 22,
    NV_ENC_ERR_RESOURCE_REGISTER_FAILED = 23,
    NV_ENC_ERR_RESOURCE_NOT_REGISTERED = 24,
    NV_ENC_ERR_RESOURCE_NOT_MAPPED = 25,
    NV_ENC_ERR_NEED_MORE_OUTPUT = 26,
}
pub use self::_NVENCSTATUS as NVENCSTATUS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_PIC_FLAGS {
    NV_ENC_PIC_FLAG_FORCEINTRA = 1,
    NV_ENC_PIC_FLAG_FORCEIDR = 2,
    NV_ENC_PIC_FLAG_OUTPUT_SPSPPS = 4,
    NV_ENC_PIC_FLAG_EOS = 8,
    NV_ENC_PIC_FLAG_DISABLE_ENC_STATE_ADVANCE = 16,
    NV_ENC_PIC_FLAG_OUTPUT_RECON_FRAME = 32,
}
pub use self::_NV_ENC_PIC_FLAGS as NV_ENC_PIC_FLAGS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_MEMORY_HEAP {
    NV_ENC_MEMORY_HEAP_AUTOSELECT = 0,
    NV_ENC_MEMORY_HEAP_VID = 1,
    NV_ENC_MEMORY_HEAP_SYSMEM_CACHED = 2,
    NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED = 3,
}
pub use self::_NV_ENC_MEMORY_HEAP as NV_ENC_MEMORY_HEAP;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_BFRAME_REF_MODE {
    NV_ENC_BFRAME_REF_MODE_DISABLED = 0,
    NV_ENC_BFRAME_REF_MODE_EACH = 1,
    NV_ENC_BFRAME_REF_MODE_MIDDLE = 2,
}
pub use self::_NV_ENC_BFRAME_REF_MODE as NV_ENC_BFRAME_REF_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_H264_ENTROPY_CODING_MODE {
    NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT = 0,
    NV_ENC_H264_ENTROPY_CODING_MODE_CABAC = 1,
    NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC = 2,
}
pub use self::_NV_ENC_H264_ENTROPY_CODING_MODE as NV_ENC_H264_ENTROPY_CODING_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_H264_BDIRECT_MODE {
    NV_ENC_H264_BDIRECT_MODE_AUTOSELECT = 0,
    NV_ENC_H264_BDIRECT_MODE_DISABLE = 1,
    NV_ENC_H264_BDIRECT_MODE_TEMPORAL = 2,
    NV_ENC_H264_BDIRECT_MODE_SPATIAL = 3,
}
pub use self::_NV_ENC_H264_BDIRECT_MODE as NV_ENC_H264_BDIRECT_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_H264_FMO_MODE {
    NV_ENC_H264_FMO_AUTOSELECT = 0,
    NV_ENC_H264_FMO_ENABLE = 1,
    NV_ENC_H264_FMO_DISABLE = 2,
}
pub use self::_NV_ENC_H264_FMO_MODE as NV_ENC_H264_FMO_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE {
    NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT = 0,
    NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE = 1,
    NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE = 2,
}
pub use self::_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE as NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_STEREO_PACKING_MODE {
    NV_ENC_STEREO_PACKING_MODE_NONE = 0,
    NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD = 1,
    NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE = 2,
    NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE = 3,
    NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE = 4,
    NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM = 5,
    NV_ENC_STEREO_PACKING_MODE_FRAMESEQ = 6,
}
pub use self::_NV_ENC_STEREO_PACKING_MODE as NV_ENC_STEREO_PACKING_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_INPUT_RESOURCE_TYPE {
    NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX = 0,
    NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR = 1,
    NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY = 2,
    NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX = 3,
}
pub use self::_NV_ENC_INPUT_RESOURCE_TYPE as NV_ENC_INPUT_RESOURCE_TYPE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_BUFFER_USAGE {
    NV_ENC_INPUT_IMAGE = 0,
    NV_ENC_OUTPUT_MOTION_VECTOR = 1,
    NV_ENC_OUTPUT_BITSTREAM = 2,
    NV_ENC_OUTPUT_RECON = 4,
}
pub use self::_NV_ENC_BUFFER_USAGE as NV_ENC_BUFFER_USAGE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_DEVICE_TYPE {
    NV_ENC_DEVICE_TYPE_DIRECTX = 0,
    NV_ENC_DEVICE_TYPE_CUDA = 1,
    NV_ENC_DEVICE_TYPE_OPENGL = 2,
}
pub use self::_NV_ENC_DEVICE_TYPE as NV_ENC_DEVICE_TYPE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_NUM_REF_FRAMES {
    NV_ENC_NUM_REF_FRAMES_AUTOSELECT = 0,
    NV_ENC_NUM_REF_FRAMES_1 = 1,
    NV_ENC_NUM_REF_FRAMES_2 = 2,
    NV_ENC_NUM_REF_FRAMES_3 = 3,
    NV_ENC_NUM_REF_FRAMES_4 = 4,
    NV_ENC_NUM_REF_FRAMES_5 = 5,
    NV_ENC_NUM_REF_FRAMES_6 = 6,
    NV_ENC_NUM_REF_FRAMES_7 = 7,
}
pub use self::_NV_ENC_NUM_REF_FRAMES as NV_ENC_NUM_REF_FRAMES;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_TEMPORAL_FILTER_LEVEL {
    NV_ENC_TEMPORAL_FILTER_LEVEL_0 = 0,
    NV_ENC_TEMPORAL_FILTER_LEVEL_4 = 4,
}
pub use self::_NV_ENC_TEMPORAL_FILTER_LEVEL as NV_ENC_TEMPORAL_FILTER_LEVEL;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_CAPS {
    NV_ENC_CAPS_NUM_MAX_BFRAMES = 0,
    NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES = 1,
    NV_ENC_CAPS_SUPPORT_FIELD_ENCODING = 2,
    NV_ENC_CAPS_SUPPORT_MONOCHROME = 3,
    NV_ENC_CAPS_SUPPORT_FMO = 4,
    NV_ENC_CAPS_SUPPORT_QPELMV = 5,
    NV_ENC_CAPS_SUPPORT_BDIRECT_MODE = 6,
    NV_ENC_CAPS_SUPPORT_CABAC = 7,
    NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM = 8,
    NV_ENC_CAPS_SUPPORT_STEREO_MVC = 9,
    NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS = 10,
    NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES = 11,
    NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES = 12,
    NV_ENC_CAPS_LEVEL_MAX = 13,
    NV_ENC_CAPS_LEVEL_MIN = 14,
    NV_ENC_CAPS_SEPARATE_COLOUR_PLANE = 15,
    NV_ENC_CAPS_WIDTH_MAX = 16,
    NV_ENC_CAPS_HEIGHT_MAX = 17,
    NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC = 18,
    NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE = 19,
    NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE = 20,
    NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP = 21,
    NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE = 22,
    NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK = 23,
    NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING = 24,
    NV_ENC_CAPS_SUPPORT_INTRA_REFRESH = 25,
    NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE = 26,
    NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE = 27,
    NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION = 28,
    NV_ENC_CAPS_PREPROC_SUPPORT = 29,
    NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT = 30,
    NV_ENC_CAPS_MB_NUM_MAX = 31,
    NV_ENC_CAPS_MB_PER_SEC_MAX = 32,
    NV_ENC_CAPS_SUPPORT_YUV444_ENCODE = 33,
    NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE = 34,
    NV_ENC_CAPS_SUPPORT_SAO = 35,
    NV_ENC_CAPS_SUPPORT_MEONLY_MODE = 36,
    NV_ENC_CAPS_SUPPORT_LOOKAHEAD = 37,
    NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ = 38,
    NV_ENC_CAPS_SUPPORT_10BIT_ENCODE = 39,
    NV_ENC_CAPS_NUM_MAX_LTR_FRAMES = 40,
    NV_ENC_CAPS_SUPPORT_WEIGHTED_PREDICTION = 41,
    NV_ENC_CAPS_DYNAMIC_QUERY_ENCODER_CAPACITY = 42,
    NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE = 43,
    NV_ENC_CAPS_SUPPORT_EMPHASIS_LEVEL_MAP = 44,
    NV_ENC_CAPS_WIDTH_MIN = 45,
    NV_ENC_CAPS_HEIGHT_MIN = 46,
    NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES = 47,
    NV_ENC_CAPS_SUPPORT_ALPHA_LAYER_ENCODING = 48,
    NV_ENC_CAPS_NUM_ENCODER_ENGINES = 49,
    NV_ENC_CAPS_SINGLE_SLICE_INTRA_REFRESH = 50,
    NV_ENC_CAPS_DISABLE_ENC_STATE_ADVANCE = 51,
    NV_ENC_CAPS_OUTPUT_RECON_SURFACE = 52,
    NV_ENC_CAPS_OUTPUT_BLOCK_STATS = 53,
    NV_ENC_CAPS_OUTPUT_ROW_STATS = 54,
    NV_ENC_CAPS_SUPPORT_TEMPORAL_FILTER = 55,
    NV_ENC_CAPS_SUPPORT_LOOKAHEAD_LEVEL = 56,
    NV_ENC_CAPS_SUPPORT_UNIDIRECTIONAL_B = 57,
    NV_ENC_CAPS_SUPPORT_MVHEVC_ENCODE = 58,
    NV_ENC_CAPS_SUPPORT_YUV422_ENCODE = 59,
    NV_ENC_CAPS_EXPOSED_COUNT = 60,
}
pub use self::_NV_ENC_CAPS as NV_ENC_CAPS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_HEVC_CUSIZE {
    NV_ENC_HEVC_CUSIZE_AUTOSELECT = 0,
    NV_ENC_HEVC_CUSIZE_8x8 = 1,
    NV_ENC_HEVC_CUSIZE_16x16 = 2,
    NV_ENC_HEVC_CUSIZE_32x32 = 3,
    NV_ENC_HEVC_CUSIZE_64x64 = 4,
}
pub use self::_NV_ENC_HEVC_CUSIZE as NV_ENC_HEVC_CUSIZE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_AV1_PART_SIZE {
    NV_ENC_AV1_PART_SIZE_AUTOSELECT = 0,
    NV_ENC_AV1_PART_SIZE_4x4 = 1,
    NV_ENC_AV1_PART_SIZE_8x8 = 2,
    NV_ENC_AV1_PART_SIZE_16x16 = 3,
    NV_ENC_AV1_PART_SIZE_32x32 = 4,
    NV_ENC_AV1_PART_SIZE_64x64 = 5,
}
pub use self::_NV_ENC_AV1_PART_SIZE as NV_ENC_AV1_PART_SIZE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_VUI_VIDEO_FORMAT {
    NV_ENC_VUI_VIDEO_FORMAT_COMPONENT = 0,
    NV_ENC_VUI_VIDEO_FORMAT_PAL = 1,
    NV_ENC_VUI_VIDEO_FORMAT_NTSC = 2,
    NV_ENC_VUI_VIDEO_FORMAT_SECAM = 3,
    NV_ENC_VUI_VIDEO_FORMAT_MAC = 4,
    NV_ENC_VUI_VIDEO_FORMAT_UNSPECIFIED = 5,
}
pub use self::_NV_ENC_VUI_VIDEO_FORMAT as NV_ENC_VUI_VIDEO_FORMAT;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_VUI_COLOR_PRIMARIES {
    NV_ENC_VUI_COLOR_PRIMARIES_UNDEFINED = 0,
    NV_ENC_VUI_COLOR_PRIMARIES_BT709 = 1,
    NV_ENC_VUI_COLOR_PRIMARIES_UNSPECIFIED = 2,
    NV_ENC_VUI_COLOR_PRIMARIES_RESERVED = 3,
    NV_ENC_VUI_COLOR_PRIMARIES_BT470M = 4,
    NV_ENC_VUI_COLOR_PRIMARIES_BT470BG = 5,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE170M = 6,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE240M = 7,
    NV_ENC_VUI_COLOR_PRIMARIES_FILM = 8,
    NV_ENC_VUI_COLOR_PRIMARIES_BT2020 = 9,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE428 = 10,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE431 = 11,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE432 = 12,
    NV_ENC_VUI_COLOR_PRIMARIES_JEDEC_P22 = 22,
}
pub use self::_NV_ENC_VUI_COLOR_PRIMARIES as NV_ENC_VUI_COLOR_PRIMARIES;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_VUI_TRANSFER_CHARACTERISTIC {
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_UNDEFINED = 0,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT709 = 1,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_UNSPECIFIED = 2,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_RESERVED = 3,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT470M = 4,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT470BG = 5,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE170M = 6,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE240M = 7,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LINEAR = 8,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LOG = 9,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LOG_SQRT = 10,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_IEC61966_2_4 = 11,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT1361_ECG = 12,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SRGB = 13,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT2020_10 = 14,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT2020_12 = 15,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE2084 = 16,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE428 = 17,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_ARIB_STD_B67 = 18,
}
pub use self::_NV_ENC_VUI_TRANSFER_CHARACTERISTIC as NV_ENC_VUI_TRANSFER_CHARACTERISTIC;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_VUI_MATRIX_COEFFS {
    NV_ENC_VUI_MATRIX_COEFFS_RGB = 0,
    NV_ENC_VUI_MATRIX_COEFFS_BT709 = 1,
    NV_ENC_VUI_MATRIX_COEFFS_UNSPECIFIED = 2,
    NV_ENC_VUI_MATRIX_COEFFS_RESERVED = 3,
    NV_ENC_VUI_MATRIX_COEFFS_FCC = 4,
    NV_ENC_VUI_MATRIX_COEFFS_BT470BG = 5,
    NV_ENC_VUI_MATRIX_COEFFS_SMPTE170M = 6,
    NV_ENC_VUI_MATRIX_COEFFS_SMPTE240M = 7,
    NV_ENC_VUI_MATRIX_COEFFS_YCGCO = 8,
    NV_ENC_VUI_MATRIX_COEFFS_BT2020_NCL = 9,
    NV_ENC_VUI_MATRIX_COEFFS_BT2020_CL = 10,
    NV_ENC_VUI_MATRIX_COEFFS_SMPTE2085 = 11,
}
pub use self::_NV_ENC_VUI_MATRIX_COEFFS as NV_ENC_VUI_MATRIX_COEFFS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_LOOKAHEAD_LEVEL {
    NV_ENC_LOOKAHEAD_LEVEL_0 = 0,
    NV_ENC_LOOKAHEAD_LEVEL_1 = 1,
    NV_ENC_LOOKAHEAD_LEVEL_2 = 2,
    NV_ENC_LOOKAHEAD_LEVEL_3 = 3,
    NV_ENC_LOOKAHEAD_LEVEL_AUTOSELECT = 15,
}
pub use self::_NV_ENC_LOOKAHEAD_LEVEL as NV_ENC_LOOKAHEAD_LEVEL;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_BIT_DEPTH {
    NV_ENC_BIT_DEPTH_INVALID = 0,
    NV_ENC_BIT_DEPTH_8 = 8,
    NV_ENC_BIT_DEPTH_10 = 10,
}
pub use self::_NV_ENC_BIT_DEPTH as NV_ENC_BIT_DEPTH;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CAPS_PARAM {
    pub version: u32,
    pub capsToQuery: NV_ENC_CAPS,
    pub reserved: [u32; 62usize],
}
impl Default for _NV_ENC_CAPS_PARAM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CAPS_PARAM = _NV_ENC_CAPS_PARAM;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_RESTORE_ENCODER_STATE_PARAMS {
    pub version: u32,
    pub bufferIdx: u32,
    pub state: NV_ENC_STATE_RESTORE_TYPE,
    pub reserved: u32,
    pub outputBitstream: NV_ENC_OUTPUT_PTR,
    pub completionEvent: *mut ::std::os::raw::c_void,
    pub reserved1: [u32; 64usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_RESTORE_ENCODER_STATE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_RESTORE_ENCODER_STATE_PARAMS = _NV_ENC_RESTORE_ENCODER_STATE_PARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_OUTPUT_STATS_BLOCK {
    pub version: u32,
    pub QP: u8,
    pub reserved: [u8; 3usize],
    pub bitcount: u32,
    pub satdCost: u32,
    pub reserved1: [u32; 12usize],
}
pub type NV_ENC_OUTPUT_STATS_BLOCK = _NV_ENC_OUTPUT_STATS_BLOCK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_OUTPUT_STATS_ROW {
    pub version: u32,
    pub QP: u8,
    pub reserved: [u8; 3usize],
    pub bitcount: u32,
    pub satdCost: u32,
    pub reserved1: [u32; 12usize],
}
pub type NV_ENC_OUTPUT_STATS_ROW = _NV_ENC_OUTPUT_STATS_ROW;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_ENCODE_OUT_PARAMS {
    pub version: u32,
    pub bitstreamSizeInBytes: u32,
    pub reserved: [u32; 62usize],
}
impl Default for _NV_ENC_ENCODE_OUT_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_ENCODE_OUT_PARAMS = _NV_ENC_ENCODE_OUT_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_LOOKAHEAD_PIC_PARAMS {
    pub version: u32,
    pub reserved: u32,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub pictureType: NV_ENC_PIC_TYPE,
    pub reserved1: [u32; 63usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_LOOKAHEAD_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_LOOKAHEAD_PIC_PARAMS = _NV_ENC_LOOKAHEAD_PIC_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_INPUT_BUFFER {
    pub version: u32,
    pub width: u32,
    pub height: u32,
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub reserved: u32,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub pSysMemBuffer: *mut ::std::os::raw::c_void,
    pub reserved1: [u32; 58usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
impl Default for _NV_ENC_CREATE_INPUT_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CREATE_INPUT_BUFFER = _NV_ENC_CREATE_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_BITSTREAM_BUFFER {
    pub version: u32,
    pub size: u32,
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    pub reserved: u32,
    pub bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    pub reserved1: [u32; 58usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CREATE_BITSTREAM_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CREATE_BITSTREAM_BUFFER = _NV_ENC_CREATE_BITSTREAM_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_MVECTOR {
    pub mvx: i16,
    pub mvy: i16,
}
pub type NV_ENC_MVECTOR = _NV_ENC_MVECTOR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_H264_MV_DATA {
    pub mv: [NV_ENC_MVECTOR; 4usize],
    pub mbType: u8,
    pub partitionType: u8,
    pub reserved: u16,
    pub mbCost: u32,
}
pub type NV_ENC_H264_MV_DATA = _NV_ENC_H264_MV_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_HEVC_MV_DATA {
    pub mv: [NV_ENC_MVECTOR; 4usize],
    pub cuType: u8,
    pub cuSize: u8,
    pub partitionMode: u8,
    pub lastCUInCTB: u8,
}
pub type NV_ENC_HEVC_MV_DATA = _NV_ENC_HEVC_MV_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_MV_BUFFER {
    pub version: u32,
    pub reserved: u32,
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    pub reserved1: [u32; 254usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
impl Default for _NV_ENC_CREATE_MV_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CREATE_MV_BUFFER = _NV_ENC_CREATE_MV_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_QP {
    pub qpInterP: u32,
    pub qpInterB: u32,
    pub qpIntra: u32,
}
pub type NV_ENC_QP = _NV_ENC_QP;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_RC_PARAMS {
    pub version: u32,
    pub rateControlMode: NV_ENC_PARAMS_RC_MODE,
    pub constQP: NV_ENC_QP,
    pub averageBitRate: u32,
    pub maxBitRate: u32,
    pub vbvBufferSize: u32,
    pub vbvInitialDelay: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub minQP: NV_ENC_QP,
    pub maxQP: NV_ENC_QP,
    pub initialRCQP: NV_ENC_QP,
    pub temporallayerIdxMask: u32,
    pub temporalLayerQP: [u8; 8usize],
    pub targetQuality: u8,
    pub targetQualityLSB: u8,
    pub lookaheadDepth: u16,
    pub lowDelayKeyFrameScale: u8,
    pub yDcQPIndexOffset: i8,
    pub uDcQPIndexOffset: i8,
    pub vDcQPIndexOffset: i8,
    pub qpMapMode: NV_ENC_QP_MAP_MODE,
    pub multiPass: NV_ENC_MULTI_PASS,
    pub alphaLayerBitrateRatio: u32,
    pub cbQPIndexOffset: i8,
    pub crQPIndexOffset: i8,
    pub reserved2: u16,
    pub lookaheadLevel: NV_ENC_LOOKAHEAD_LEVEL,
    pub viewBitrateRatios: [u8; 7usize],
    pub reserved3: u8,
    pub reserved1: u32,
}
impl Default for _NV_ENC_RC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_RC_PARAMS {
    #[inline]
    pub fn enableMinQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMinQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMinQP_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMinQP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableMaxQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMaxQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMaxQP_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMaxQP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableInitialRCQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableInitialRCQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableInitialRCQP_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableInitialRCQP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableAQ_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableAQ_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitField1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitField1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitField1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLookahead(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLookahead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLookahead_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLookahead_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableIadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableIadapt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableIadapt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableBadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableBadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableBadapt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableBadapt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTemporalAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTemporalAQ_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTemporalAQ_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn zeroReorderDelay(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zeroReorderDelay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn zeroReorderDelay_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_zeroReorderDelay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableNonRefP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableNonRefP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableNonRefP_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableNonRefP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn strictGOPTarget(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strictGOPTarget(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strictGOPTarget_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_strictGOPTarget_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn aqStrength(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_aqStrength(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn aqStrength_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_aqStrength_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableExtLookahead(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableExtLookahead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableExtLookahead_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableExtLookahead_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                15u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableMinQP: u32,
        enableMaxQP: u32,
        enableInitialRCQP: u32,
        enableAQ: u32,
        reservedBitField1: u32,
        enableLookahead: u32,
        disableIadapt: u32,
        disableBadapt: u32,
        enableTemporalAQ: u32,
        zeroReorderDelay: u32,
        enableNonRefP: u32,
        strictGOPTarget: u32,
        aqStrength: u32,
        enableExtLookahead: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableMinQP: u32 = unsafe { ::std::mem::transmute(enableMinQP) };
            enableMinQP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableMaxQP: u32 = unsafe { ::std::mem::transmute(enableMaxQP) };
            enableMaxQP as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableInitialRCQP: u32 = unsafe { ::std::mem::transmute(enableInitialRCQP) };
            enableInitialRCQP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableAQ: u32 = unsafe { ::std::mem::transmute(enableAQ) };
            enableAQ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reservedBitField1: u32 = unsafe { ::std::mem::transmute(reservedBitField1) };
            reservedBitField1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLookahead: u32 = unsafe { ::std::mem::transmute(enableLookahead) };
            enableLookahead as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableIadapt: u32 = unsafe { ::std::mem::transmute(disableIadapt) };
            disableIadapt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableBadapt: u32 = unsafe { ::std::mem::transmute(disableBadapt) };
            disableBadapt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableTemporalAQ: u32 = unsafe { ::std::mem::transmute(enableTemporalAQ) };
            enableTemporalAQ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let zeroReorderDelay: u32 = unsafe { ::std::mem::transmute(zeroReorderDelay) };
            zeroReorderDelay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableNonRefP: u32 = unsafe { ::std::mem::transmute(enableNonRefP) };
            enableNonRefP as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let strictGOPTarget: u32 = unsafe { ::std::mem::transmute(strictGOPTarget) };
            strictGOPTarget as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let aqStrength: u32 = unsafe { ::std::mem::transmute(aqStrength) };
            aqStrength as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enableExtLookahead: u32 = unsafe { ::std::mem::transmute(enableExtLookahead) };
            enableExtLookahead as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_RC_PARAMS = _NV_ENC_RC_PARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CLOCK_TIMESTAMP_SET {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub timeOffset: u32,
}
impl _NV_ENC_CLOCK_TIMESTAMP_SET {
    #[inline]
    pub fn countingType(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_countingType(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn countingType_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_countingType_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn discontinuityFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_discontinuityFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn discontinuityFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_discontinuityFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cntDroppedFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cntDroppedFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cntDroppedFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_cntDroppedFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_nFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn secondsValue(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_secondsValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn secondsValue_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_secondsValue_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn minutesValue(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_minutesValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn minutesValue_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_minutesValue_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hoursValue(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_hoursValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hoursValue_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hoursValue_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved2_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        countingType: u32,
        discontinuityFlag: u32,
        cntDroppedFrames: u32,
        nFrames: u32,
        secondsValue: u32,
        minutesValue: u32,
        hoursValue: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let countingType: u32 = unsafe { ::std::mem::transmute(countingType) };
            countingType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let discontinuityFlag: u32 = unsafe { ::std::mem::transmute(discontinuityFlag) };
            discontinuityFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cntDroppedFrames: u32 = unsafe { ::std::mem::transmute(cntDroppedFrames) };
            cntDroppedFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let nFrames: u32 = unsafe { ::std::mem::transmute(nFrames) };
            nFrames as u64
        });
        __bindgen_bitfield_unit.set(11usize, 6u8, {
            let secondsValue: u32 = unsafe { ::std::mem::transmute(secondsValue) };
            secondsValue as u64
        });
        __bindgen_bitfield_unit.set(17usize, 6u8, {
            let minutesValue: u32 = unsafe { ::std::mem::transmute(minutesValue) };
            minutesValue as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let hoursValue: u32 = unsafe { ::std::mem::transmute(hoursValue) };
            hoursValue as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_CLOCK_TIMESTAMP_SET = _NV_ENC_CLOCK_TIMESTAMP_SET;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_TIME_CODE {
    pub displayPicStruct: NV_ENC_DISPLAY_PIC_STRUCT,
    pub clockTimestamp: [NV_ENC_CLOCK_TIMESTAMP_SET; 3usize],
    pub skipClockTimestampInsertion: u32,
}
impl Default for _NV_ENC_TIME_CODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_TIME_CODE = _NV_ENC_TIME_CODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _HEVC_3D_REFERENCE_DISPLAY_INFO {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub precRefDisplayWidth: i32,
    pub precRefViewingDist: i32,
    pub numRefDisplaysMinus1: i32,
    pub leftViewId: [i32; 32usize],
    pub rightViewId: [i32; 32usize],
    pub exponentRefDisplayWidth: [i32; 32usize],
    pub mantissaRefDisplayWidth: [i32; 32usize],
    pub exponentRefViewingDistance: [i32; 32usize],
    pub mantissaRefViewingDistance: [i32; 32usize],
    pub numSampleShiftPlus512: [i32; 32usize],
    pub additionalShiftPresentFlag: [u8; 32usize],
    pub reserved2: [u32; 4usize],
}
impl _HEVC_3D_REFERENCE_DISPLAY_INFO {
    #[inline]
    pub fn refViewingDistanceFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refViewingDistanceFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn refViewingDistanceFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_refViewingDistanceFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn threeDimensionalReferenceDisplaysExtensionFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_threeDimensionalReferenceDisplaysExtensionFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn threeDimensionalReferenceDisplaysExtensionFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_threeDimensionalReferenceDisplaysExtensionFlag_raw(
        this: *mut Self,
        val: u32,
    ) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        refViewingDistanceFlag: u32,
        threeDimensionalReferenceDisplaysExtensionFlag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let refViewingDistanceFlag: u32 =
                unsafe { ::std::mem::transmute(refViewingDistanceFlag) };
            refViewingDistanceFlag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let threeDimensionalReferenceDisplaysExtensionFlag: u32 =
                unsafe { ::std::mem::transmute(threeDimensionalReferenceDisplaysExtensionFlag) };
            threeDimensionalReferenceDisplaysExtensionFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type HEVC_3D_REFERENCE_DISPLAY_INFO = _HEVC_3D_REFERENCE_DISPLAY_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CHROMA_POINTS {
    pub x: u16,
    pub y: u16,
}
pub type CHROMA_POINTS = _CHROMA_POINTS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _MASTERING_DISPLAY_INFO {
    pub g: CHROMA_POINTS,
    pub b: CHROMA_POINTS,
    pub r: CHROMA_POINTS,
    pub whitePoint: CHROMA_POINTS,
    pub maxLuma: u32,
    pub minLuma: u32,
}
pub type MASTERING_DISPLAY_INFO = _MASTERING_DISPLAY_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CONTENT_LIGHT_LEVEL {
    pub maxContentLightLevel: u16,
    pub maxPicAverageLightLevel: u16,
}
pub type CONTENT_LIGHT_LEVEL = _CONTENT_LIGHT_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    pub overscanInfoPresentFlag: u32,
    pub overscanInfo: u32,
    pub videoSignalTypePresentFlag: u32,
    pub videoFormat: NV_ENC_VUI_VIDEO_FORMAT,
    pub videoFullRangeFlag: u32,
    pub colourDescriptionPresentFlag: u32,
    pub colourPrimaries: NV_ENC_VUI_COLOR_PRIMARIES,
    pub transferCharacteristics: NV_ENC_VUI_TRANSFER_CHARACTERISTIC,
    pub colourMatrix: NV_ENC_VUI_MATRIX_COEFFS,
    pub chromaSampleLocationFlag: u32,
    pub chromaSampleLocationTop: u32,
    pub chromaSampleLocationBot: u32,
    pub bitstreamRestrictionFlag: u32,
    pub timingInfoPresentFlag: u32,
    pub numUnitInTicks: u32,
    pub timeScale: u32,
    pub reserved: [u32; 12usize],
}
impl Default for _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CONFIG_H264_VUI_PARAMETERS = _NV_ENC_CONFIG_H264_VUI_PARAMETERS;
pub type NV_ENC_CONFIG_HEVC_VUI_PARAMETERS = NV_ENC_CONFIG_H264_VUI_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 3usize],
}
impl _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    #[inline]
    pub fn numCandsPerBlk16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk16x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk16x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerBlk16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk16x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk16x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk8x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk8x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk8x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk8x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerSb(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerSb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerSb_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerSb_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        numCandsPerBlk16x16: u32,
        numCandsPerBlk16x8: u32,
        numCandsPerBlk8x16: u32,
        numCandsPerBlk8x8: u32,
        numCandsPerSb: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let numCandsPerBlk16x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x16) };
            numCandsPerBlk16x16 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let numCandsPerBlk16x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x8) };
            numCandsPerBlk16x8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numCandsPerBlk8x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x16) };
            numCandsPerBlk8x16 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCandsPerBlk8x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x8) };
            numCandsPerBlk8x8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let numCandsPerSb: u32 = unsafe { ::std::mem::transmute(numCandsPerSb) };
            numCandsPerSb as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE = _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NVENC_EXTERNAL_ME_HINT {
    #[inline]
    pub fn mvx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mvx_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mvx_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mvy(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mvy_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mvy_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn refidx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn refidx_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_refidx_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dir(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dir_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dir_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn partType(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_partType(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn partType_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_partType_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lastofPart(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastofPart(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lastofPart_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lastofPart_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lastOfMB(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastOfMB(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lastOfMB_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lastOfMB_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mvx: i32,
        mvy: i32,
        refidx: i32,
        dir: i32,
        partType: i32,
        lastofPart: i32,
        lastOfMB: i32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let mvx: u32 = unsafe { ::std::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(12usize, 10u8, {
            let mvy: u32 = unsafe { ::std::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let refidx: u32 = unsafe { ::std::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let dir: u32 = unsafe { ::std::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let partType: u32 = unsafe { ::std::mem::transmute(partType) };
            partType as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lastofPart: u32 = unsafe { ::std::mem::transmute(lastofPart) };
            lastofPart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lastOfMB: u32 = unsafe { ::std::mem::transmute(lastOfMB) };
            lastOfMB as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVENC_EXTERNAL_ME_HINT = _NVENC_EXTERNAL_ME_HINT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_SB_HINT {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
}
impl _NVENC_EXTERNAL_ME_SB_HINT {
    #[inline]
    pub fn refidx(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn refidx_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_refidx_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn direction(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_direction(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn direction_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_direction_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bi(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_bi(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bi_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_bi_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn partition_type(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_partition_type(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn partition_type_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_partition_type_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn x8(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_x8(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn x8_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_x8_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn last_of_cu(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_last_of_cu(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_of_cu_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_last_of_cu_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn last_of_sb(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_last_of_sb(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn last_of_sb_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_last_of_sb_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved0(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved0_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reserved0_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mvx(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mvx_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                14u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_mvx_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cu_size(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cu_size(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cu_size_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_cu_size_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mvy(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mvy_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                12u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_mvy_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn y8(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_y8(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn y8_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_y8_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> i16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                47usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        refidx: i16,
        direction: i16,
        bi: i16,
        partition_type: i16,
        x8: i16,
        last_of_cu: i16,
        last_of_sb: i16,
        reserved0: i16,
        mvx: i16,
        cu_size: i16,
        mvy: i16,
        y8: i16,
        reserved1: i16,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let refidx: u16 = unsafe { ::std::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let direction: u16 = unsafe { ::std::mem::transmute(direction) };
            direction as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bi: u16 = unsafe { ::std::mem::transmute(bi) };
            bi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let partition_type: u16 = unsafe { ::std::mem::transmute(partition_type) };
            partition_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let x8: u16 = unsafe { ::std::mem::transmute(x8) };
            x8 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let last_of_cu: u16 = unsafe { ::std::mem::transmute(last_of_cu) };
            last_of_cu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let last_of_sb: u16 = unsafe { ::std::mem::transmute(last_of_sb) };
            last_of_sb as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved0: u16 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 14u8, {
            let mvx: u16 = unsafe { ::std::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let cu_size: u16 = unsafe { ::std::mem::transmute(cu_size) };
            cu_size as u64
        });
        __bindgen_bitfield_unit.set(32usize, 12u8, {
            let mvy: u16 = unsafe { ::std::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(44usize, 3u8, {
            let y8: u16 = unsafe { ::std::mem::transmute(y8) };
            y8 as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let reserved1: u16 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVENC_EXTERNAL_ME_SB_HINT = _NVENC_EXTERNAL_ME_SB_HINT;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub level: u32,
    pub idrPeriod: u32,
    pub separateColourPlaneFlag: u32,
    pub disableDeblockingFilterIDC: u32,
    pub numTemporalLayers: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub adaptiveTransformMode: NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE,
    pub fmoMode: NV_ENC_H264_FMO_MODE,
    pub bdirectMode: NV_ENC_H264_BDIRECT_MODE,
    pub entropyCodingMode: NV_ENC_H264_ENTROPY_CODING_MODE,
    pub stereoMode: NV_ENC_STEREO_PACKING_MODE,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFrames: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub h264VUIParameters: NV_ENC_CONFIG_H264_VUI_PARAMETERS,
    pub ltrNumFrames: u32,
    pub ltrTrustMode: u32,
    pub chromaFormatIDC: u32,
    pub maxTemporalLayers: u32,
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    pub outputBitDepth: NV_ENC_BIT_DEPTH,
    pub inputBitDepth: NV_ENC_BIT_DEPTH,
    pub tfLevel: NV_ENC_TEMPORAL_FILTER_LEVEL,
    pub reserved1: [u32; 264usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CONFIG_H264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_H264 {
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTemporalSVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTemporalSVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableStereoMVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableStereoMVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableStereoMVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableStereoMVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hierarchicalPFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalPFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hierarchicalPFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hierarchicalPFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hierarchicalBFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalBFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hierarchicalBFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hierarchicalBFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputBufferingPeriodSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputBufferingPeriodSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputPictureTimingSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputPictureTimingSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputAUD_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputAUD_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputFramePackingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputFramePackingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputFramePackingSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputFramePackingSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputRecoveryPointSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputRecoveryPointSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableConstrainedEncoding_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableConstrainedEncoding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repeatSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repeatSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableVFR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableVFR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableVFR_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableVFR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLTR_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLTR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qpPrimeYZeroTransformBypassFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_qpPrimeYZeroTransformBypassFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qpPrimeYZeroTransformBypassFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_qpPrimeYZeroTransformBypassFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn useConstrainedIntraPred_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_useConstrainedIntraPred_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableFillerDataInsertion_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableFillerDataInsertion_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableSVCPrefixNalu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSVCPrefixNalu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableSVCPrefixNalu_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableSVCPrefixNalu_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableScalabilityInfoSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableScalabilityInfoSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableScalabilityInfoSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableScalabilityInfoSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn singleSliceIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_singleSliceIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn singleSliceIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_singleSliceIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTimeCode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTimeCode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTimeCode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTimeCode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableTemporalSVC: u32,
        enableStereoMVC: u32,
        hierarchicalPFrames: u32,
        hierarchicalBFrames: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        disableSPSPPS: u32,
        outputFramePackingSEI: u32,
        outputRecoveryPointSEI: u32,
        enableIntraRefresh: u32,
        enableConstrainedEncoding: u32,
        repeatSPSPPS: u32,
        enableVFR: u32,
        enableLTR: u32,
        qpPrimeYZeroTransformBypassFlag: u32,
        useConstrainedIntraPred: u32,
        enableFillerDataInsertion: u32,
        disableSVCPrefixNalu: u32,
        enableScalabilityInfoSEI: u32,
        singleSliceIntraRefresh: u32,
        enableTimeCode: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::std::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableStereoMVC: u32 = unsafe { ::std::mem::transmute(enableStereoMVC) };
            enableStereoMVC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hierarchicalPFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalPFrames) };
            hierarchicalPFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hierarchicalBFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalBFrames) };
            hierarchicalBFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let outputFramePackingSEI: u32 =
                unsafe { ::std::mem::transmute(outputFramePackingSEI) };
            outputFramePackingSEI as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::std::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::std::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enableVFR: u32 = unsafe { ::std::mem::transmute(enableVFR) };
            enableVFR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let qpPrimeYZeroTransformBypassFlag: u32 =
                unsafe { ::std::mem::transmute(qpPrimeYZeroTransformBypassFlag) };
            qpPrimeYZeroTransformBypassFlag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::std::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let disableSVCPrefixNalu: u32 = unsafe { ::std::mem::transmute(disableSVCPrefixNalu) };
            disableSVCPrefixNalu as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let enableScalabilityInfoSEI: u32 =
                unsafe { ::std::mem::transmute(enableScalabilityInfoSEI) };
            enableScalabilityInfoSEI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let singleSliceIntraRefresh: u32 =
                unsafe { ::std::mem::transmute(singleSliceIntraRefresh) };
            singleSliceIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let enableTimeCode: u32 = unsafe { ::std::mem::transmute(enableTimeCode) };
            enableTimeCode as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_CONFIG_H264 = _NV_ENC_CONFIG_H264;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_HEVC {
    pub level: u32,
    pub tier: u32,
    pub minCUSize: NV_ENC_HEVC_CUSIZE,
    pub maxCUSize: NV_ENC_HEVC_CUSIZE,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub idrPeriod: u32,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFramesInDPB: u32,
    pub ltrNumFrames: u32,
    pub vpsId: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub maxTemporalLayersMinus1: u32,
    pub hevcVUIParameters: NV_ENC_CONFIG_HEVC_VUI_PARAMETERS,
    pub ltrTrustMode: u32,
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    pub tfLevel: NV_ENC_TEMPORAL_FILTER_LEVEL,
    pub disableDeblockingFilterIDC: u32,
    pub outputBitDepth: NV_ENC_BIT_DEPTH,
    pub inputBitDepth: NV_ENC_BIT_DEPTH,
    pub numTemporalLayers: u32,
    pub numViews: u32,
    pub reserved1: [u32; 208usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CONFIG_HEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_HEVC {
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn useConstrainedIntraPred_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_useConstrainedIntraPred_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableDeblockAcrossSliceBoundary(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableDeblockAcrossSliceBoundary(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableDeblockAcrossSliceBoundary_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableDeblockAcrossSliceBoundary_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputBufferingPeriodSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputBufferingPeriodSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputPictureTimingSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputPictureTimingSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputAUD_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputAUD_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLTR_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLTR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repeatSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repeatSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn chromaFormatIDC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_chromaFormatIDC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved3_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved3_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableFillerDataInsertion_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableFillerDataInsertion_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableConstrainedEncoding_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableConstrainedEncoding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableAlphaLayerEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAlphaLayerEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableAlphaLayerEncoding_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableAlphaLayerEncoding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn singleSliceIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_singleSliceIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn singleSliceIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_singleSliceIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputRecoveryPointSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputRecoveryPointSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputTimeCodeSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputTimeCodeSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputTimeCodeSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputTimeCodeSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTemporalSVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTemporalSVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableMVHEVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMVHEVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMVHEVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMVHEVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputHevc3DReferenceDisplayInfo(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputHevc3DReferenceDisplayInfo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputHevc3DReferenceDisplayInfo_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputHevc3DReferenceDisplayInfo_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputMaxCll(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputMaxCll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputMaxCll_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputMaxCll_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputMasteringDisplay(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputMasteringDisplay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputMasteringDisplay_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputMasteringDisplay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        useConstrainedIntraPred: u32,
        disableDeblockAcrossSliceBoundary: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        enableLTR: u32,
        disableSPSPPS: u32,
        repeatSPSPPS: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        reserved3: u32,
        enableFillerDataInsertion: u32,
        enableConstrainedEncoding: u32,
        enableAlphaLayerEncoding: u32,
        singleSliceIntraRefresh: u32,
        outputRecoveryPointSEI: u32,
        outputTimeCodeSEI: u32,
        enableTemporalSVC: u32,
        enableMVHEVC: u32,
        outputHevc3DReferenceDisplayInfo: u32,
        outputMaxCll: u32,
        outputMasteringDisplay: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disableDeblockAcrossSliceBoundary: u32 =
                unsafe { ::std::mem::transmute(disableDeblockAcrossSliceBoundary) };
            disableDeblockAcrossSliceBoundary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::std::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::std::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::std::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enableAlphaLayerEncoding: u32 =
                unsafe { ::std::mem::transmute(enableAlphaLayerEncoding) };
            enableAlphaLayerEncoding as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let singleSliceIntraRefresh: u32 =
                unsafe { ::std::mem::transmute(singleSliceIntraRefresh) };
            singleSliceIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::std::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let outputTimeCodeSEI: u32 = unsafe { ::std::mem::transmute(outputTimeCodeSEI) };
            outputTimeCodeSEI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::std::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let enableMVHEVC: u32 = unsafe { ::std::mem::transmute(enableMVHEVC) };
            enableMVHEVC as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let outputHevc3DReferenceDisplayInfo: u32 =
                unsafe { ::std::mem::transmute(outputHevc3DReferenceDisplayInfo) };
            outputHevc3DReferenceDisplayInfo as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let outputMaxCll: u32 = unsafe { ::std::mem::transmute(outputMaxCll) };
            outputMaxCll as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let outputMasteringDisplay: u32 =
                unsafe { ::std::mem::transmute(outputMasteringDisplay) };
            outputMasteringDisplay as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_CONFIG_HEVC = _NV_ENC_CONFIG_HEVC;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_FILM_GRAIN_PARAMS_AV1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub pointYValue: [u8; 14usize],
    pub pointYScaling: [u8; 14usize],
    pub pointCbValue: [u8; 10usize],
    pub pointCbScaling: [u8; 10usize],
    pub pointCrValue: [u8; 10usize],
    pub pointCrScaling: [u8; 10usize],
    pub arCoeffsYPlus128: [u8; 24usize],
    pub arCoeffsCbPlus128: [u8; 25usize],
    pub arCoeffsCrPlus128: [u8; 25usize],
    pub reserved2: [u8; 2usize],
    pub cbMult: u8,
    pub cbLumaMult: u8,
    pub cbOffset: u16,
    pub crMult: u8,
    pub crLumaMult: u8,
    pub crOffset: u16,
}
impl _NV_ENC_FILM_GRAIN_PARAMS_AV1 {
    #[inline]
    pub fn applyGrain(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_applyGrain(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn applyGrain_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_applyGrain_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn chromaScalingFromLuma(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chromaScalingFromLuma(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn chromaScalingFromLuma_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_chromaScalingFromLuma_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn overlapFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlapFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn overlapFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_overlapFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn clipToRestrictedRange(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clipToRestrictedRange(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn clipToRestrictedRange_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_clipToRestrictedRange_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grainScalingMinus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_grainScalingMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grainScalingMinus8_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_grainScalingMinus8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arCoeffLag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arCoeffLag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arCoeffLag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arCoeffLag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numYPoints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numYPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numYPoints_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numYPoints_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCbPoints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCbPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCbPoints_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCbPoints_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCrPoints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCrPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCrPoints_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCrPoints_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arCoeffShiftMinus6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arCoeffShiftMinus6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arCoeffShiftMinus6_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arCoeffShiftMinus6_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grainScaleShift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_grainScaleShift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grainScaleShift_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_grainScaleShift_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        applyGrain: u32,
        chromaScalingFromLuma: u32,
        overlapFlag: u32,
        clipToRestrictedRange: u32,
        grainScalingMinus8: u32,
        arCoeffLag: u32,
        numYPoints: u32,
        numCbPoints: u32,
        numCrPoints: u32,
        arCoeffShiftMinus6: u32,
        grainScaleShift: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let applyGrain: u32 = unsafe { ::std::mem::transmute(applyGrain) };
            applyGrain as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let chromaScalingFromLuma: u32 =
                unsafe { ::std::mem::transmute(chromaScalingFromLuma) };
            chromaScalingFromLuma as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let overlapFlag: u32 = unsafe { ::std::mem::transmute(overlapFlag) };
            overlapFlag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clipToRestrictedRange: u32 =
                unsafe { ::std::mem::transmute(clipToRestrictedRange) };
            clipToRestrictedRange as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let grainScalingMinus8: u32 = unsafe { ::std::mem::transmute(grainScalingMinus8) };
            grainScalingMinus8 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let arCoeffLag: u32 = unsafe { ::std::mem::transmute(arCoeffLag) };
            arCoeffLag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numYPoints: u32 = unsafe { ::std::mem::transmute(numYPoints) };
            numYPoints as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCbPoints: u32 = unsafe { ::std::mem::transmute(numCbPoints) };
            numCbPoints as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let numCrPoints: u32 = unsafe { ::std::mem::transmute(numCrPoints) };
            numCrPoints as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let arCoeffShiftMinus6: u32 = unsafe { ::std::mem::transmute(arCoeffShiftMinus6) };
            arCoeffShiftMinus6 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let grainScaleShift: u32 = unsafe { ::std::mem::transmute(grainScaleShift) };
            grainScaleShift as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_FILM_GRAIN_PARAMS_AV1 = _NV_ENC_FILM_GRAIN_PARAMS_AV1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_AV1 {
    pub level: u32,
    pub tier: u32,
    pub minPartSize: NV_ENC_AV1_PART_SIZE,
    pub maxPartSize: NV_ENC_AV1_PART_SIZE,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub idrPeriod: u32,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFramesInDPB: u32,
    pub numTileColumns: u32,
    pub numTileRows: u32,
    pub reserved2: u32,
    pub tileWidths: *mut u32,
    pub tileHeights: *mut u32,
    pub maxTemporalLayersMinus1: u32,
    pub colorPrimaries: NV_ENC_VUI_COLOR_PRIMARIES,
    pub transferCharacteristics: NV_ENC_VUI_TRANSFER_CHARACTERISTIC,
    pub matrixCoefficients: NV_ENC_VUI_MATRIX_COEFFS,
    pub colorRange: u32,
    pub chromaSamplePosition: u32,
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    pub filmGrainParams: *mut NV_ENC_FILM_GRAIN_PARAMS_AV1,
    pub numFwdRefs: NV_ENC_NUM_REF_FRAMES,
    pub numBwdRefs: NV_ENC_NUM_REF_FRAMES,
    pub outputBitDepth: NV_ENC_BIT_DEPTH,
    pub inputBitDepth: NV_ENC_BIT_DEPTH,
    pub ltrNumFrames: u32,
    pub numTemporalLayers: u32,
    pub tfLevel: NV_ENC_TEMPORAL_FILTER_LEVEL,
    pub reserved1: [u32; 230usize],
    pub reserved3: [*mut ::std::os::raw::c_void; 62usize],
}
impl Default for _NV_ENC_CONFIG_AV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_AV1 {
    #[inline]
    pub fn outputAnnexBFormat(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAnnexBFormat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputAnnexBFormat_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputAnnexBFormat_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTimingInfo(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTimingInfo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTimingInfo_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTimingInfo_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableDecoderModelInfo(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableDecoderModelInfo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableDecoderModelInfo_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableDecoderModelInfo_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableFrameIdNumbers(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFrameIdNumbers(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableFrameIdNumbers_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableFrameIdNumbers_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableSeqHdr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSeqHdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableSeqHdr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableSeqHdr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repeatSeqHdr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSeqHdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repeatSeqHdr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repeatSeqHdr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn chromaFormatIDC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_chromaFormatIDC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableBitstreamPadding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableBitstreamPadding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableBitstreamPadding_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableBitstreamPadding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableCustomTileConfig(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableCustomTileConfig(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableCustomTileConfig_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableCustomTileConfig_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableFilmGrainParams(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFilmGrainParams(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableFilmGrainParams_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableFilmGrainParams_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLTR_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLTR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTemporalSVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTemporalSVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputMaxCll(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputMaxCll(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputMaxCll_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputMaxCll_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputMasteringDisplay(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputMasteringDisplay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputMasteringDisplay_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputMasteringDisplay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved4_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved4_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                14u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        outputAnnexBFormat: u32,
        enableTimingInfo: u32,
        enableDecoderModelInfo: u32,
        enableFrameIdNumbers: u32,
        disableSeqHdr: u32,
        repeatSeqHdr: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        enableBitstreamPadding: u32,
        enableCustomTileConfig: u32,
        enableFilmGrainParams: u32,
        enableLTR: u32,
        enableTemporalSVC: u32,
        outputMaxCll: u32,
        outputMasteringDisplay: u32,
        reserved4: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let outputAnnexBFormat: u32 = unsafe { ::std::mem::transmute(outputAnnexBFormat) };
            outputAnnexBFormat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableTimingInfo: u32 = unsafe { ::std::mem::transmute(enableTimingInfo) };
            enableTimingInfo as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableDecoderModelInfo: u32 =
                unsafe { ::std::mem::transmute(enableDecoderModelInfo) };
            enableDecoderModelInfo as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableFrameIdNumbers: u32 = unsafe { ::std::mem::transmute(enableFrameIdNumbers) };
            enableFrameIdNumbers as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableSeqHdr: u32 = unsafe { ::std::mem::transmute(disableSeqHdr) };
            disableSeqHdr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let repeatSeqHdr: u32 = unsafe { ::std::mem::transmute(repeatSeqHdr) };
            repeatSeqHdr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::std::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enableBitstreamPadding: u32 =
                unsafe { ::std::mem::transmute(enableBitstreamPadding) };
            enableBitstreamPadding as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableCustomTileConfig: u32 =
                unsafe { ::std::mem::transmute(enableCustomTileConfig) };
            enableCustomTileConfig as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableFilmGrainParams: u32 =
                unsafe { ::std::mem::transmute(enableFilmGrainParams) };
            enableFilmGrainParams as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::std::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let outputMaxCll: u32 = unsafe { ::std::mem::transmute(outputMaxCll) };
            outputMaxCll as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let outputMasteringDisplay: u32 =
                unsafe { ::std::mem::transmute(outputMasteringDisplay) };
            outputMasteringDisplay as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let reserved4: u32 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_CONFIG_AV1 = _NV_ENC_CONFIG_AV1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_MEONLY {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 255usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CONFIG_H264_MEONLY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_H264_MEONLY {
    #[inline]
    pub fn disablePartition16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition16x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition16x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disablePartition8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition8x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition8x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disablePartition16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition16x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition16x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disablePartition8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition8x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition8x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableIntraSearch(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIntraSearch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableIntraSearch_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableIntraSearch_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bStereoEnable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bStereoEnable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bStereoEnable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bStereoEnable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                26u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                26u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disablePartition16x16: u32,
        disablePartition8x16: u32,
        disablePartition16x8: u32,
        disablePartition8x8: u32,
        disableIntraSearch: u32,
        bStereoEnable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disablePartition16x16: u32 =
                unsafe { ::std::mem::transmute(disablePartition16x16) };
            disablePartition16x16 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disablePartition8x16: u32 = unsafe { ::std::mem::transmute(disablePartition8x16) };
            disablePartition8x16 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disablePartition16x8: u32 = unsafe { ::std::mem::transmute(disablePartition16x8) };
            disablePartition16x8 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disablePartition8x8: u32 = unsafe { ::std::mem::transmute(disablePartition8x8) };
            disablePartition8x8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableIntraSearch: u32 = unsafe { ::std::mem::transmute(disableIntraSearch) };
            disableIntraSearch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bStereoEnable: u32 = unsafe { ::std::mem::transmute(bStereoEnable) };
            bStereoEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_CONFIG_H264_MEONLY = _NV_ENC_CONFIG_H264_MEONLY;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_HEVC_MEONLY {
    pub reserved: [u32; 256usize],
    pub reserved1: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CONFIG_HEVC_MEONLY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CONFIG_HEVC_MEONLY = _NV_ENC_CONFIG_HEVC_MEONLY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_CONFIG {
    pub h264Config: NV_ENC_CONFIG_H264,
    pub hevcConfig: NV_ENC_CONFIG_HEVC,
    pub av1Config: NV_ENC_CONFIG_AV1,
    pub h264MeOnlyConfig: NV_ENC_CONFIG_H264_MEONLY,
    pub hevcMeOnlyConfig: NV_ENC_CONFIG_HEVC_MEONLY,
    pub reserved: [u32; 320usize],
}
impl Default for _NV_ENC_CODEC_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CODEC_CONFIG = _NV_ENC_CODEC_CONFIG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG {
    pub version: u32,
    pub profileGUID: GUID,
    pub gopLength: u32,
    pub frameIntervalP: i32,
    pub monoChromeEncoding: u32,
    pub frameFieldMode: NV_ENC_PARAMS_FRAME_FIELD_MODE,
    pub mvPrecision: NV_ENC_MV_PRECISION,
    pub rcParams: NV_ENC_RC_PARAMS,
    pub encodeCodecConfig: NV_ENC_CODEC_CONFIG,
    pub reserved: [u32; 278usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CONFIG = _NV_ENC_CONFIG;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NV_ENC_TUNING_INFO {
    NV_ENC_TUNING_INFO_UNDEFINED = 0,
    NV_ENC_TUNING_INFO_HIGH_QUALITY = 1,
    NV_ENC_TUNING_INFO_LOW_LATENCY = 2,
    NV_ENC_TUNING_INFO_ULTRA_LOW_LATENCY = 3,
    NV_ENC_TUNING_INFO_LOSSLESS = 4,
    NV_ENC_TUNING_INFO_ULTRA_HIGH_QUALITY = 5,
    NV_ENC_TUNING_INFO_COUNT = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_SPLIT_ENCODE_MODE {
    NV_ENC_SPLIT_AUTO_MODE = 0,
    NV_ENC_SPLIT_AUTO_FORCED_MODE = 1,
    NV_ENC_SPLIT_TWO_FORCED_MODE = 2,
    NV_ENC_SPLIT_THREE_FORCED_MODE = 3,
    NV_ENC_SPLIT_FOUR_FORCED_MODE = 4,
    NV_ENC_SPLIT_DISABLE_MODE = 15,
}
pub use self::_NV_ENC_SPLIT_ENCODE_MODE as NV_ENC_SPLIT_ENCODE_MODE;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_INITIALIZE_PARAMS {
    pub version: u32,
    pub encodeGUID: GUID,
    pub presetGUID: GUID,
    pub encodeWidth: u32,
    pub encodeHeight: u32,
    pub darWidth: u32,
    pub darHeight: u32,
    pub frameRateNum: u32,
    pub frameRateDen: u32,
    pub enableEncodeAsync: u32,
    pub enablePTD: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub privDataSize: u32,
    pub reserved: u32,
    pub privData: *mut ::std::os::raw::c_void,
    pub encodeConfig: *mut NV_ENC_CONFIG,
    pub maxEncodeWidth: u32,
    pub maxEncodeHeight: u32,
    pub maxMEHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub tuningInfo: NV_ENC_TUNING_INFO,
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    pub numStateBuffers: u32,
    pub outputStatsLevel: NV_ENC_OUTPUT_STATS_LEVEL,
    pub reserved1: [u32; 284usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_INITIALIZE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_INITIALIZE_PARAMS {
    #[inline]
    pub fn reportSliceOffsets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reportSliceOffsets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reportSliceOffsets_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reportSliceOffsets_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableSubFrameWrite(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableSubFrameWrite(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableSubFrameWrite_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableSubFrameWrite_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableExternalMEHints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableExternalMEHints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableExternalMEHints_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableExternalMEHints_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableMEOnlyMode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMEOnlyMode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMEOnlyMode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMEOnlyMode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableWeightedPrediction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableWeightedPrediction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableWeightedPrediction_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableWeightedPrediction_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn splitEncodeMode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_splitEncodeMode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn splitEncodeMode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_splitEncodeMode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableOutputInVidmem(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableOutputInVidmem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableOutputInVidmem_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableOutputInVidmem_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableReconFrameOutput(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableReconFrameOutput(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableReconFrameOutput_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableReconFrameOutput_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableOutputStats(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableOutputStats(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableOutputStats_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableOutputStats_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableUniDirectionalB(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableUniDirectionalB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableUniDirectionalB_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableUniDirectionalB_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                19u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                19u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reportSliceOffsets: u32,
        enableSubFrameWrite: u32,
        enableExternalMEHints: u32,
        enableMEOnlyMode: u32,
        enableWeightedPrediction: u32,
        splitEncodeMode: u32,
        enableOutputInVidmem: u32,
        enableReconFrameOutput: u32,
        enableOutputStats: u32,
        enableUniDirectionalB: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reportSliceOffsets: u32 = unsafe { ::std::mem::transmute(reportSliceOffsets) };
            reportSliceOffsets as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableSubFrameWrite: u32 = unsafe { ::std::mem::transmute(enableSubFrameWrite) };
            enableSubFrameWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableExternalMEHints: u32 =
                unsafe { ::std::mem::transmute(enableExternalMEHints) };
            enableExternalMEHints as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableMEOnlyMode: u32 = unsafe { ::std::mem::transmute(enableMEOnlyMode) };
            enableMEOnlyMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enableWeightedPrediction: u32 =
                unsafe { ::std::mem::transmute(enableWeightedPrediction) };
            enableWeightedPrediction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let splitEncodeMode: u32 = unsafe { ::std::mem::transmute(splitEncodeMode) };
            splitEncodeMode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enableOutputInVidmem: u32 = unsafe { ::std::mem::transmute(enableOutputInVidmem) };
            enableOutputInVidmem as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableReconFrameOutput: u32 =
                unsafe { ::std::mem::transmute(enableReconFrameOutput) };
            enableReconFrameOutput as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableOutputStats: u32 = unsafe { ::std::mem::transmute(enableOutputStats) };
            enableOutputStats as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enableUniDirectionalB: u32 =
                unsafe { ::std::mem::transmute(enableUniDirectionalB) };
            enableUniDirectionalB as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_INITIALIZE_PARAMS = _NV_ENC_INITIALIZE_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_RECONFIGURE_PARAMS {
    pub version: u32,
    pub reserved: u32,
    pub reInitEncodeParams: NV_ENC_INITIALIZE_PARAMS,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved2: u32,
}
impl Default for _NV_ENC_RECONFIGURE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_RECONFIGURE_PARAMS {
    #[inline]
    pub fn resetEncoder(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resetEncoder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resetEncoder_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_resetEncoder_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn forceIDR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceIDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn forceIDR_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_forceIDR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        resetEncoder: u32,
        forceIDR: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resetEncoder: u32 = unsafe { ::std::mem::transmute(resetEncoder) };
            resetEncoder as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let forceIDR: u32 = unsafe { ::std::mem::transmute(forceIDR) };
            forceIDR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_RECONFIGURE_PARAMS = _NV_ENC_RECONFIGURE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PRESET_CONFIG {
    pub version: u32,
    pub reserved: u32,
    pub presetCfg: NV_ENC_CONFIG,
    pub reserved1: [u32; 256usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_PRESET_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_PRESET_CONFIG = _NV_ENC_PRESET_CONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_MVC {
    pub version: u32,
    pub viewID: u32,
    pub temporalID: u32,
    pub priorityID: u32,
    pub reserved1: [u32; 12usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 8usize],
}
impl Default for _NV_ENC_PIC_PARAMS_MVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_PIC_PARAMS_MVC = _NV_ENC_PIC_PARAMS_MVC;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_PIC_PARAMS_H264_EXT {
    pub mvcPicParams: NV_ENC_PIC_PARAMS_MVC,
    pub reserved1: [u32; 32usize],
}
impl Default for _NV_ENC_PIC_PARAMS_H264_EXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_PIC_PARAMS_H264_EXT = _NV_ENC_PIC_PARAMS_H264_EXT;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_SEI_PAYLOAD {
    pub payloadSize: u32,
    pub payloadType: u32,
    pub payload: *mut u8,
}
impl Default for _NV_ENC_SEI_PAYLOAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_SEI_PAYLOAD = _NV_ENC_SEI_PAYLOAD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_H264 {
    pub displayPOCSyntax: u32,
    pub reserved3: u32,
    pub refPicFlag: u32,
    pub colourPlaneId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sliceTypeData: *mut u8,
    pub sliceTypeArrayCnt: u32,
    pub seiPayloadArrayCnt: u32,
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub ltrMarkFrameIdx: u32,
    pub ltrUseFrameBitmap: u32,
    pub ltrUsageMode: u32,
    pub forceIntraSliceCount: u32,
    pub forceIntraSliceIdx: *mut u32,
    pub h264ExtPicParams: NV_ENC_PIC_PARAMS_H264_EXT,
    pub timeCode: NV_ENC_TIME_CODE,
    pub reserved: [u32; 202usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 61usize],
}
impl Default for _NV_ENC_PIC_PARAMS_H264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_H264 {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn constrainedFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_constrainedFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sliceModeDataUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sliceModeDataUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrMarkFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrMarkFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrUseFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrUseFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_PIC_PARAMS_H264 = _NV_ENC_PIC_PARAMS_H264;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_HEVC {
    pub displayPOCSyntax: u32,
    pub refPicFlag: u32,
    pub temporalId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: u32,
    pub sliceTypeData: *mut u8,
    pub sliceTypeArrayCnt: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub ltrMarkFrameIdx: u32,
    pub ltrUseFrameBitmap: u32,
    pub ltrUsageMode: u32,
    pub seiPayloadArrayCnt: u32,
    pub reserved: u32,
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub timeCode: NV_ENC_TIME_CODE,
    pub numTemporalLayers: u32,
    pub viewId: u32,
    pub p3DReferenceDisplayInfo: *mut HEVC_3D_REFERENCE_DISPLAY_INFO,
    pub pMaxCll: *mut CONTENT_LIGHT_LEVEL,
    pub pMasteringDisplay: *mut MASTERING_DISPLAY_INFO,
    pub reserved2: [u32; 234usize],
    pub reserved3: [*mut ::std::os::raw::c_void; 58usize],
}
impl Default for _NV_ENC_PIC_PARAMS_HEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_HEVC {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn constrainedFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_constrainedFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sliceModeDataUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sliceModeDataUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrMarkFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrMarkFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrUseFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrUseFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn temporalConfigUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporalConfigUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn temporalConfigUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_temporalConfigUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        temporalConfigUpdate: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let temporalConfigUpdate: u32 = unsafe { ::std::mem::transmute(temporalConfigUpdate) };
            temporalConfigUpdate as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_PIC_PARAMS_HEVC = _NV_ENC_PIC_PARAMS_HEVC;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_AV1 {
    pub displayPOCSyntax: u32,
    pub refPicFlag: u32,
    pub temporalId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub numTileColumns: u32,
    pub numTileRows: u32,
    pub reserved: u32,
    pub tileWidths: *mut u32,
    pub tileHeights: *mut u32,
    pub obuPayloadArrayCnt: u32,
    pub reserved1: u32,
    pub obuPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub filmGrainParams: *mut NV_ENC_FILM_GRAIN_PARAMS_AV1,
    pub ltrMarkFrameIdx: u32,
    pub ltrUseFrameBitmap: u32,
    pub numTemporalLayers: u32,
    pub reserved4: u32,
    pub pMaxCll: *mut CONTENT_LIGHT_LEVEL,
    pub pMasteringDisplay: *mut MASTERING_DISPLAY_INFO,
    pub reserved2: [u32; 242usize],
    pub reserved3: [*mut ::std::os::raw::c_void; 59usize],
}
impl Default for _NV_ENC_PIC_PARAMS_AV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_AV1 {
    #[inline]
    pub fn goldenFrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_goldenFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn goldenFrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_goldenFrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arfFrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arfFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arfFrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arfFrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn arf2FrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arf2FrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn arf2FrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_arf2FrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bwdFrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bwdFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bwdFrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bwdFrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn overlayFrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlayFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn overlayFrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_overlayFrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn showExistingFrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_showExistingFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn showExistingFrameFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_showExistingFrameFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn errorResilientModeFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_errorResilientModeFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn errorResilientModeFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_errorResilientModeFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tileConfigUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tileConfigUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tileConfigUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tileConfigUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableCustomTileConfig(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableCustomTileConfig(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableCustomTileConfig_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableCustomTileConfig_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn filmGrainParamsUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filmGrainParamsUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn filmGrainParamsUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_filmGrainParamsUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrMarkFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrMarkFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrUseFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrUseFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn temporalConfigUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporalConfigUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn temporalConfigUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_temporalConfigUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                19u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                19u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        goldenFrameFlag: u32,
        arfFrameFlag: u32,
        arf2FrameFlag: u32,
        bwdFrameFlag: u32,
        overlayFrameFlag: u32,
        showExistingFrameFlag: u32,
        errorResilientModeFlag: u32,
        tileConfigUpdate: u32,
        enableCustomTileConfig: u32,
        filmGrainParamsUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        temporalConfigUpdate: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let goldenFrameFlag: u32 = unsafe { ::std::mem::transmute(goldenFrameFlag) };
            goldenFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let arfFrameFlag: u32 = unsafe { ::std::mem::transmute(arfFrameFlag) };
            arfFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let arf2FrameFlag: u32 = unsafe { ::std::mem::transmute(arf2FrameFlag) };
            arf2FrameFlag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bwdFrameFlag: u32 = unsafe { ::std::mem::transmute(bwdFrameFlag) };
            bwdFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let overlayFrameFlag: u32 = unsafe { ::std::mem::transmute(overlayFrameFlag) };
            overlayFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let showExistingFrameFlag: u32 =
                unsafe { ::std::mem::transmute(showExistingFrameFlag) };
            showExistingFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let errorResilientModeFlag: u32 =
                unsafe { ::std::mem::transmute(errorResilientModeFlag) };
            errorResilientModeFlag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tileConfigUpdate: u32 = unsafe { ::std::mem::transmute(tileConfigUpdate) };
            tileConfigUpdate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableCustomTileConfig: u32 =
                unsafe { ::std::mem::transmute(enableCustomTileConfig) };
            enableCustomTileConfig as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let filmGrainParamsUpdate: u32 =
                unsafe { ::std::mem::transmute(filmGrainParamsUpdate) };
            filmGrainParamsUpdate as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let temporalConfigUpdate: u32 = unsafe { ::std::mem::transmute(temporalConfigUpdate) };
            temporalConfigUpdate as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_PIC_PARAMS_AV1 = _NV_ENC_PIC_PARAMS_AV1;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_PIC_PARAMS {
    pub h264PicParams: NV_ENC_PIC_PARAMS_H264,
    pub hevcPicParams: NV_ENC_PIC_PARAMS_HEVC,
    pub av1PicParams: NV_ENC_PIC_PARAMS_AV1,
    pub reserved: [u32; 256usize],
}
impl Default for _NV_ENC_CODEC_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CODEC_PIC_PARAMS = _NV_ENC_CODEC_PIC_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS {
    pub version: u32,
    pub inputWidth: u32,
    pub inputHeight: u32,
    pub inputPitch: u32,
    pub encodePicFlags: u32,
    pub frameIdx: u32,
    pub inputTimeStamp: u64,
    pub inputDuration: u64,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub outputBitstream: NV_ENC_OUTPUT_PTR,
    pub completionEvent: *mut ::std::os::raw::c_void,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    pub pictureType: NV_ENC_PIC_TYPE,
    pub codecPicParams: NV_ENC_CODEC_PIC_PARAMS,
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    pub reserved2: [u32; 7usize],
    pub reserved5: [*mut ::std::os::raw::c_void; 2usize],
    pub qpDeltaMap: *mut i8,
    pub qpDeltaMapSize: u32,
    pub reservedBitFields: u32,
    pub meHintRefPicDist: [u16; 2usize],
    pub reserved4: u32,
    pub alphaBuffer: NV_ENC_INPUT_PTR,
    pub meExternalSbHints: *mut NVENC_EXTERNAL_ME_SB_HINT,
    pub meSbHintsCount: u32,
    pub stateBufferIdx: u32,
    pub outputReconBuffer: NV_ENC_OUTPUT_PTR,
    pub reserved3: [u32; 284usize],
    pub reserved6: [*mut ::std::os::raw::c_void; 57usize],
}
impl Default for _NV_ENC_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_PIC_PARAMS = _NV_ENC_PIC_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_MEONLY_PARAMS {
    pub version: u32,
    pub inputWidth: u32,
    pub inputHeight: u32,
    pub reserved: u32,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub referenceFrame: NV_ENC_INPUT_PTR,
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    pub reserved2: u32,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub completionEvent: *mut ::std::os::raw::c_void,
    pub viewID: u32,
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    pub reserved1: [u32; 241usize],
    pub reserved3: [*mut ::std::os::raw::c_void; 59usize],
}
impl Default for _NV_ENC_MEONLY_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_MEONLY_PARAMS = _NV_ENC_MEONLY_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_LOCK_BITSTREAM {
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub outputBitstream: *mut ::std::os::raw::c_void,
    pub sliceOffsets: *mut u32,
    pub frameIdx: u32,
    pub hwEncodeStatus: u32,
    pub numSlices: u32,
    pub bitstreamSizeInBytes: u32,
    pub outputTimeStamp: u64,
    pub outputDuration: u64,
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    pub pictureType: NV_ENC_PIC_TYPE,
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    pub frameAvgQP: u32,
    pub frameSatd: u32,
    pub ltrFrameIdx: u32,
    pub ltrFrameBitmap: u32,
    pub temporalId: u32,
    pub intraMBCount: u32,
    pub interMBCount: u32,
    pub averageMVX: i32,
    pub averageMVY: i32,
    pub alphaLayerSizeInBytes: u32,
    pub outputStatsPtrSize: u32,
    pub reserved: u32,
    pub outputStatsPtr: *mut ::std::os::raw::c_void,
    pub frameIdxDisplay: u32,
    pub reserved1: [u32; 219usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
    pub reservedInternal: [u32; 8usize],
}
impl Default for _NV_ENC_LOCK_BITSTREAM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_LOCK_BITSTREAM {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn doNotWait_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_doNotWait_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn getRCStats(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_getRCStats(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn getRCStats_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_getRCStats_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        ltrFrame: u32,
        getRCStats: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::std::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let getRCStats: u32 = unsafe { ::std::mem::transmute(getRCStats) };
            getRCStats as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_LOCK_BITSTREAM = _NV_ENC_LOCK_BITSTREAM;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_LOCK_INPUT_BUFFER {
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub bufferDataPtr: *mut ::std::os::raw::c_void,
    pub pitch: u32,
    pub reserved1: [u32; 251usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_LOCK_INPUT_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_LOCK_INPUT_BUFFER {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn doNotWait_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_doNotWait_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_LOCK_INPUT_BUFFER = _NV_ENC_LOCK_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_MAP_INPUT_RESOURCE {
    pub version: u32,
    pub subResourceIndex: u32,
    pub inputResource: *mut ::std::os::raw::c_void,
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    pub mappedResource: NV_ENC_INPUT_PTR,
    pub mappedBufferFmt: NV_ENC_BUFFER_FORMAT,
    pub reserved1: [u32; 251usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
impl Default for _NV_ENC_MAP_INPUT_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_MAP_INPUT_RESOURCE = _NV_ENC_MAP_INPUT_RESOURCE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX {
    pub texture: u32,
    pub target: u32,
}
pub type NV_ENC_INPUT_RESOURCE_OPENGL_TEX = _NV_ENC_INPUT_RESOURCE_OPENGL_TEX;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_FENCE_POINT_D3D12 {
    pub version: u32,
    pub reserved: u32,
    pub pFence: *mut ::std::os::raw::c_void,
    pub waitValue: u64,
    pub signalValue: u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 7usize],
}
impl Default for _NV_ENC_FENCE_POINT_D3D12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_FENCE_POINT_D3D12 {
    #[inline]
    pub fn bWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bWait_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bWait_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bSignal(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSignal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bSignal_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bSignal_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitField(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitField_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitField_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bWait: u32,
        bSignal: u32,
        reservedBitField: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bWait: u32 = unsafe { ::std::mem::transmute(bWait) };
            bWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSignal: u32 = unsafe { ::std::mem::transmute(bSignal) };
            bSignal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reservedBitField: u32 = unsafe { ::std::mem::transmute(reservedBitField) };
            reservedBitField as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_FENCE_POINT_D3D12 = _NV_ENC_FENCE_POINT_D3D12;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_INPUT_RESOURCE_D3D12 {
    pub version: u32,
    pub reserved: u32,
    pub pInputBuffer: NV_ENC_INPUT_PTR,
    pub inputFencePoint: NV_ENC_FENCE_POINT_D3D12,
    pub reserved1: [u32; 16usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 16usize],
}
impl Default for _NV_ENC_INPUT_RESOURCE_D3D12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_INPUT_RESOURCE_D3D12 = _NV_ENC_INPUT_RESOURCE_D3D12;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_OUTPUT_RESOURCE_D3D12 {
    pub version: u32,
    pub reserved: u32,
    pub pOutputBuffer: NV_ENC_INPUT_PTR,
    pub outputFencePoint: NV_ENC_FENCE_POINT_D3D12,
    pub reserved1: [u32; 16usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 16usize],
}
impl Default for _NV_ENC_OUTPUT_RESOURCE_D3D12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_OUTPUT_RESOURCE_D3D12 = _NV_ENC_OUTPUT_RESOURCE_D3D12;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_REGISTER_RESOURCE {
    pub version: u32,
    pub resourceType: NV_ENC_INPUT_RESOURCE_TYPE,
    pub width: u32,
    pub height: u32,
    pub pitch: u32,
    pub subResourceIndex: u32,
    pub resourceToRegister: *mut ::std::os::raw::c_void,
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    pub bufferUsage: NV_ENC_BUFFER_USAGE,
    pub pInputFencePoint: *mut NV_ENC_FENCE_POINT_D3D12,
    pub chromaOffset: [u32; 2usize],
    pub chromaOffsetIn: [u32; 2usize],
    pub reserved1: [u32; 244usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 61usize],
}
impl Default for _NV_ENC_REGISTER_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_REGISTER_RESOURCE = _NV_ENC_REGISTER_RESOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_STAT {
    pub version: u32,
    pub reserved: u32,
    pub outputBitStream: NV_ENC_OUTPUT_PTR,
    pub bitStreamSize: u32,
    pub picType: u32,
    pub lastValidByteOffset: u32,
    pub sliceOffsets: [u32; 16usize],
    pub picIdx: u32,
    pub frameAvgQP: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub ltrFrameIdx: u32,
    pub intraMBCount: u32,
    pub interMBCount: u32,
    pub averageMVX: i32,
    pub averageMVY: i32,
    pub reserved1: [u32; 227usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_STAT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_STAT {
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ltrFrame: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::std::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_STAT = _NV_ENC_STAT;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    pub version: u32,
    pub inBufferSize: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub spsppsBuffer: *mut ::std::os::raw::c_void,
    pub outSPSPPSPayloadSize: *mut u32,
    pub reserved: [u32; 250usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_SEQUENCE_PARAM_PAYLOAD = _NV_ENC_SEQUENCE_PARAM_PAYLOAD;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_EVENT_PARAMS {
    pub version: u32,
    pub reserved: u32,
    pub completionEvent: *mut ::std::os::raw::c_void,
    pub reserved1: [u32; 254usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_EVENT_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_EVENT_PARAMS = _NV_ENC_EVENT_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    pub version: u32,
    pub deviceType: NV_ENC_DEVICE_TYPE,
    pub device: *mut ::std::os::raw::c_void,
    pub reserved: *mut ::std::os::raw::c_void,
    pub apiVersion: u32,
    pub reserved1: [u32; 253usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS = _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS;
unsafe extern "C" {
    pub fn NvEncOpenEncodeSession(
        device: *mut ::std::os::raw::c_void,
        deviceType: u32,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeGUIDCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeProfileGUIDCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeProfileGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetInputFormatCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetInputFormats(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeCaps(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::std::os::raw::c_int,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodePresetCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodePresetGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodePresetConfig(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodePresetConfigEx(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncInitializeEncoder(
        encoder: *mut ::std::os::raw::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncCreateInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncDestroyInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncSetIOCudaStreams(
        encoder: *mut ::std::os::raw::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncCreateBitstreamBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncDestroyBitstreamBuffer(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncEncodePicture(
        encoder: *mut ::std::os::raw::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncLockBitstream(
        encoder: *mut ::std::os::raw::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncUnlockBitstream(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncRestoreEncoderState(
        encoder: *mut ::std::os::raw::c_void,
        restoreState: *mut NV_ENC_RESTORE_ENCODER_STATE_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncLockInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncUnlockInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeStats(
        encoder: *mut ::std::os::raw::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetSequenceParams(
        encoder: *mut ::std::os::raw::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetSequenceParamEx(
        encoder: *mut ::std::os::raw::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncRegisterAsyncEvent(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncUnregisterAsyncEvent(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncMapInputResource(
        encoder: *mut ::std::os::raw::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncUnmapInputResource(
        encoder: *mut ::std::os::raw::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncDestroyEncoder(encoder: *mut ::std::os::raw::c_void) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncInvalidateRefFrames(
        encoder: *mut ::std::os::raw::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncOpenEncodeSessionEx(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncRegisterResource(
        encoder: *mut ::std::os::raw::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncUnregisterResource(
        encoder: *mut ::std::os::raw::c_void,
        registeredResource: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncReconfigureEncoder(
        encoder: *mut ::std::os::raw::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncCreateMVBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncDestroyMVBuffer(
        encoder: *mut ::std::os::raw::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncRunMotionEstimationOnly(
        encoder: *mut ::std::os::raw::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncodeAPIGetMaxSupportedVersion(version: *mut u32) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetLastErrorString(
        encoder: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn NvEncLookaheadPicture(
        encoder: *mut ::std::os::raw::c_void,
        lookaheadParamas: *mut NV_ENC_LOOKAHEAD_PIC_PARAMS,
    ) -> NVENCSTATUS;
}
pub type PNVENCOPENENCODESESSION = ::std::option::Option<
    unsafe extern "C" fn(
        device: *mut ::std::os::raw::c_void,
        deviceType: u32,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPROFILEGUIDCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPROFILEGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODECAPS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::std::os::raw::c_int,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIG = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIGEX = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCINITIALIZEENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCENCODEPICTURE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODESTATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYENCODER = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> NVENCSTATUS,
>;
pub type PNVENCINVALIDATEREFFRAMES = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS,
>;
pub type PNVENCOPENENCODESESSIONEX = ::std::option::Option<
    unsafe extern "C" fn(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registeredRes: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRECONFIGUREENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRUNMOTIONESTIMATIONONLY = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETLASTERROR = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
>;
pub type PNVENCSETIOCUDASTREAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMEX = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRESTOREENCODERSTATE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        restoreState: *mut NV_ENC_RESTORE_ENCODER_STATE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOOKAHEADPICTURE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lookaheadParams: *mut NV_ENC_LOOKAHEAD_PIC_PARAMS,
    ) -> NVENCSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENCODE_API_FUNCTION_LIST {
    pub version: u32,
    pub reserved: u32,
    pub nvEncOpenEncodeSession: PNVENCOPENENCODESESSION,
    pub nvEncGetEncodeGUIDCount: PNVENCGETENCODEGUIDCOUNT,
    pub nvEncGetEncodeProfileGUIDCount: PNVENCGETENCODEPROFILEGUIDCOUNT,
    pub nvEncGetEncodeProfileGUIDs: PNVENCGETENCODEPROFILEGUIDS,
    pub nvEncGetEncodeGUIDs: PNVENCGETENCODEGUIDS,
    pub nvEncGetInputFormatCount: PNVENCGETINPUTFORMATCOUNT,
    pub nvEncGetInputFormats: PNVENCGETINPUTFORMATS,
    pub nvEncGetEncodeCaps: PNVENCGETENCODECAPS,
    pub nvEncGetEncodePresetCount: PNVENCGETENCODEPRESETCOUNT,
    pub nvEncGetEncodePresetGUIDs: PNVENCGETENCODEPRESETGUIDS,
    pub nvEncGetEncodePresetConfig: PNVENCGETENCODEPRESETCONFIG,
    pub nvEncInitializeEncoder: PNVENCINITIALIZEENCODER,
    pub nvEncCreateInputBuffer: PNVENCCREATEINPUTBUFFER,
    pub nvEncDestroyInputBuffer: PNVENCDESTROYINPUTBUFFER,
    pub nvEncCreateBitstreamBuffer: PNVENCCREATEBITSTREAMBUFFER,
    pub nvEncDestroyBitstreamBuffer: PNVENCDESTROYBITSTREAMBUFFER,
    pub nvEncEncodePicture: PNVENCENCODEPICTURE,
    pub nvEncLockBitstream: PNVENCLOCKBITSTREAM,
    pub nvEncUnlockBitstream: PNVENCUNLOCKBITSTREAM,
    pub nvEncLockInputBuffer: PNVENCLOCKINPUTBUFFER,
    pub nvEncUnlockInputBuffer: PNVENCUNLOCKINPUTBUFFER,
    pub nvEncGetEncodeStats: PNVENCGETENCODESTATS,
    pub nvEncGetSequenceParams: PNVENCGETSEQUENCEPARAMS,
    pub nvEncRegisterAsyncEvent: PNVENCREGISTERASYNCEVENT,
    pub nvEncUnregisterAsyncEvent: PNVENCUNREGISTERASYNCEVENT,
    pub nvEncMapInputResource: PNVENCMAPINPUTRESOURCE,
    pub nvEncUnmapInputResource: PNVENCUNMAPINPUTRESOURCE,
    pub nvEncDestroyEncoder: PNVENCDESTROYENCODER,
    pub nvEncInvalidateRefFrames: PNVENCINVALIDATEREFFRAMES,
    pub nvEncOpenEncodeSessionEx: PNVENCOPENENCODESESSIONEX,
    pub nvEncRegisterResource: PNVENCREGISTERRESOURCE,
    pub nvEncUnregisterResource: PNVENCUNREGISTERRESOURCE,
    pub nvEncReconfigureEncoder: PNVENCRECONFIGUREENCODER,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub nvEncCreateMVBuffer: PNVENCCREATEMVBUFFER,
    pub nvEncDestroyMVBuffer: PNVENCDESTROYMVBUFFER,
    pub nvEncRunMotionEstimationOnly: PNVENCRUNMOTIONESTIMATIONONLY,
    pub nvEncGetLastErrorString: PNVENCGETLASTERROR,
    pub nvEncSetIOCudaStreams: PNVENCSETIOCUDASTREAMS,
    pub nvEncGetEncodePresetConfigEx: PNVENCGETENCODEPRESETCONFIGEX,
    pub nvEncGetSequenceParamEx: PNVENCGETSEQUENCEPARAMEX,
    pub nvEncRestoreEncoderState: PNVENCRESTOREENCODERSTATE,
    pub nvEncLookaheadPicture: PNVENCLOOKAHEADPICTURE,
    pub reserved2: [*mut ::std::os::raw::c_void; 275usize],
}
impl Default for _NV_ENCODE_API_FUNCTION_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENCODE_API_FUNCTION_LIST = _NV_ENCODE_API_FUNCTION_LIST;
unsafe extern "C" {
    pub fn NvEncodeAPICreateInstance(functionList: *mut NV_ENCODE_API_FUNCTION_LIST)
        -> NVENCSTATUS;
}
pub type tcu_ulong = ::std::os::raw::c_ulong;
pub type CUvideodecoder = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUcontextlock_st {
    _unused: [u8; 0],
}
pub type CUvideoctxlock = *mut _CUcontextlock_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoCodec_enum {
    cudaVideoCodec_MPEG1 = 0,
    cudaVideoCodec_MPEG2 = 1,
    cudaVideoCodec_MPEG4 = 2,
    cudaVideoCodec_VC1 = 3,
    cudaVideoCodec_H264 = 4,
    cudaVideoCodec_JPEG = 5,
    cudaVideoCodec_H264_SVC = 6,
    cudaVideoCodec_H264_MVC = 7,
    cudaVideoCodec_HEVC = 8,
    cudaVideoCodec_VP8 = 9,
    cudaVideoCodec_VP9 = 10,
    cudaVideoCodec_AV1 = 11,
    cudaVideoCodec_NumCodecs = 12,
    cudaVideoCodec_YUV420 = 1230591318,
    cudaVideoCodec_YV12 = 1498820914,
    cudaVideoCodec_NV12 = 1314271538,
    cudaVideoCodec_YUYV = 1498765654,
    cudaVideoCodec_UYVY = 1431918169,
}
pub use self::cudaVideoCodec_enum as cudaVideoCodec;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoSurfaceFormat_enum {
    cudaVideoSurfaceFormat_NV12 = 0,
    cudaVideoSurfaceFormat_P016 = 1,
    cudaVideoSurfaceFormat_YUV444 = 2,
    cudaVideoSurfaceFormat_YUV444_16Bit = 3,
    cudaVideoSurfaceFormat_NV16 = 4,
    cudaVideoSurfaceFormat_P216 = 5,
}
pub use self::cudaVideoSurfaceFormat_enum as cudaVideoSurfaceFormat;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoDeinterlaceMode_enum {
    cudaVideoDeinterlaceMode_Weave = 0,
    cudaVideoDeinterlaceMode_Bob = 1,
    cudaVideoDeinterlaceMode_Adaptive = 2,
}
pub use self::cudaVideoDeinterlaceMode_enum as cudaVideoDeinterlaceMode;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoChromaFormat_enum {
    cudaVideoChromaFormat_Monochrome = 0,
    cudaVideoChromaFormat_420 = 1,
    cudaVideoChromaFormat_422 = 2,
    cudaVideoChromaFormat_444 = 3,
}
pub use self::cudaVideoChromaFormat_enum as cudaVideoChromaFormat;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoCreateFlags_enum {
    cudaVideoCreate_Default = 0,
    cudaVideoCreate_PreferCUDA = 1,
    cudaVideoCreate_PreferDXVA = 2,
    cudaVideoCreate_PreferCUVID = 4,
}
pub use self::cudaVideoCreateFlags_enum as cudaVideoCreateFlags;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cuvidDecodeStatus_enum {
    cuvidDecodeStatus_Invalid = 0,
    cuvidDecodeStatus_InProgress = 1,
    cuvidDecodeStatus_Success = 2,
    cuvidDecodeStatus_Error = 8,
    cuvidDecodeStatus_Error_Concealed = 9,
}
pub use self::cuvidDecodeStatus_enum as cuvidDecodeStatus;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDDECODECAPS {
    pub eCodecType: cudaVideoCodec,
    pub eChromaFormat: cudaVideoChromaFormat,
    pub nBitDepthMinus8: ::std::os::raw::c_uint,
    pub reserved1: [::std::os::raw::c_uint; 3usize],
    pub bIsSupported: ::std::os::raw::c_uchar,
    pub nNumNVDECs: ::std::os::raw::c_uchar,
    pub nOutputFormatMask: ::std::os::raw::c_ushort,
    pub nMaxWidth: ::std::os::raw::c_uint,
    pub nMaxHeight: ::std::os::raw::c_uint,
    pub nMaxMBCount: ::std::os::raw::c_uint,
    pub nMinWidth: ::std::os::raw::c_ushort,
    pub nMinHeight: ::std::os::raw::c_ushort,
    pub bIsHistogramSupported: ::std::os::raw::c_uchar,
    pub nCounterBitDepth: ::std::os::raw::c_uchar,
    pub nMaxHistogramBins: ::std::os::raw::c_ushort,
    pub reserved3: [::std::os::raw::c_uint; 10usize],
}
impl Default for _CUVIDDECODECAPS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDDECODECAPS = _CUVIDDECODECAPS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDDECODECREATEINFO {
    pub ulWidth: tcu_ulong,
    pub ulHeight: tcu_ulong,
    pub ulNumDecodeSurfaces: tcu_ulong,
    pub CodecType: cudaVideoCodec,
    pub ChromaFormat: cudaVideoChromaFormat,
    pub ulCreationFlags: tcu_ulong,
    pub bitDepthMinus8: tcu_ulong,
    pub ulIntraDecodeOnly: tcu_ulong,
    pub ulMaxWidth: tcu_ulong,
    pub ulMaxHeight: tcu_ulong,
    pub Reserved1: tcu_ulong,
    pub display_area: _CUVIDDECODECREATEINFO__bindgen_ty_1,
    pub OutputFormat: cudaVideoSurfaceFormat,
    pub DeinterlaceMode: cudaVideoDeinterlaceMode,
    pub ulTargetWidth: tcu_ulong,
    pub ulTargetHeight: tcu_ulong,
    pub ulNumOutputSurfaces: tcu_ulong,
    pub vidLock: CUvideoctxlock,
    pub target_rect: _CUVIDDECODECREATEINFO__bindgen_ty_2,
    pub enableHistogram: tcu_ulong,
    pub Reserved2: [tcu_ulong; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDDECODECREATEINFO__bindgen_ty_1 {
    pub left: ::std::os::raw::c_short,
    pub top: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDDECODECREATEINFO__bindgen_ty_2 {
    pub left: ::std::os::raw::c_short,
    pub top: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
}
impl Default for _CUVIDDECODECREATEINFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDDECODECREATEINFO = _CUVIDDECODECREATEINFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDH264DPBENTRY {
    pub PicIdx: ::std::os::raw::c_int,
    pub FrameIdx: ::std::os::raw::c_int,
    pub is_long_term: ::std::os::raw::c_int,
    pub not_existing: ::std::os::raw::c_int,
    pub used_for_reference: ::std::os::raw::c_int,
    pub FieldOrderCnt: [::std::os::raw::c_int; 2usize],
}
pub type CUVIDH264DPBENTRY = _CUVIDH264DPBENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDH264MVCEXT {
    pub num_views_minus1: ::std::os::raw::c_int,
    pub view_id: ::std::os::raw::c_int,
    pub inter_view_flag: ::std::os::raw::c_uchar,
    pub num_inter_view_refs_l0: ::std::os::raw::c_uchar,
    pub num_inter_view_refs_l1: ::std::os::raw::c_uchar,
    pub MVCReserved8Bits: ::std::os::raw::c_uchar,
    pub InterViewRefsL0: [::std::os::raw::c_int; 16usize],
    pub InterViewRefsL1: [::std::os::raw::c_int; 16usize],
}
pub type CUVIDH264MVCEXT = _CUVIDH264MVCEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDH264SVCEXT {
    pub profile_idc: ::std::os::raw::c_uchar,
    pub level_idc: ::std::os::raw::c_uchar,
    pub DQId: ::std::os::raw::c_uchar,
    pub DQIdMax: ::std::os::raw::c_uchar,
    pub disable_inter_layer_deblocking_filter_idc: ::std::os::raw::c_uchar,
    pub ref_layer_chroma_phase_y_plus1: ::std::os::raw::c_uchar,
    pub inter_layer_slice_alpha_c0_offset_div2: ::std::os::raw::c_schar,
    pub inter_layer_slice_beta_offset_div2: ::std::os::raw::c_schar,
    pub DPBEntryValidFlag: ::std::os::raw::c_ushort,
    pub inter_layer_deblocking_filter_control_present_flag: ::std::os::raw::c_uchar,
    pub extended_spatial_scalability_idc: ::std::os::raw::c_uchar,
    pub adaptive_tcoeff_level_prediction_flag: ::std::os::raw::c_uchar,
    pub slice_header_restriction_flag: ::std::os::raw::c_uchar,
    pub chroma_phase_x_plus1_flag: ::std::os::raw::c_uchar,
    pub chroma_phase_y_plus1: ::std::os::raw::c_uchar,
    pub tcoeff_level_prediction_flag: ::std::os::raw::c_uchar,
    pub constrained_intra_resampling_flag: ::std::os::raw::c_uchar,
    pub ref_layer_chroma_phase_x_plus1_flag: ::std::os::raw::c_uchar,
    pub store_ref_base_pic_flag: ::std::os::raw::c_uchar,
    pub Reserved8BitsA: ::std::os::raw::c_uchar,
    pub Reserved8BitsB: ::std::os::raw::c_uchar,
    pub scaled_ref_layer_left_offset: ::std::os::raw::c_short,
    pub scaled_ref_layer_top_offset: ::std::os::raw::c_short,
    pub scaled_ref_layer_right_offset: ::std::os::raw::c_short,
    pub scaled_ref_layer_bottom_offset: ::std::os::raw::c_short,
    pub Reserved16Bits: ::std::os::raw::c_ushort,
    pub pNextLayer: *mut _CUVIDPICPARAMS,
    pub bRefBaseLayer: ::std::os::raw::c_int,
}
impl Default for _CUVIDH264SVCEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDH264SVCEXT = _CUVIDH264SVCEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CUVIDH264PICPARAMS {
    pub log2_max_frame_num_minus4: ::std::os::raw::c_int,
    pub pic_order_cnt_type: ::std::os::raw::c_int,
    pub log2_max_pic_order_cnt_lsb_minus4: ::std::os::raw::c_int,
    pub delta_pic_order_always_zero_flag: ::std::os::raw::c_int,
    pub frame_mbs_only_flag: ::std::os::raw::c_int,
    pub direct_8x8_inference_flag: ::std::os::raw::c_int,
    pub num_ref_frames: ::std::os::raw::c_int,
    pub residual_colour_transform_flag: ::std::os::raw::c_uchar,
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    pub qpprime_y_zero_transform_bypass_flag: ::std::os::raw::c_uchar,
    pub entropy_coding_mode_flag: ::std::os::raw::c_int,
    pub pic_order_present_flag: ::std::os::raw::c_int,
    pub num_ref_idx_l0_active_minus1: ::std::os::raw::c_int,
    pub num_ref_idx_l1_active_minus1: ::std::os::raw::c_int,
    pub weighted_pred_flag: ::std::os::raw::c_int,
    pub weighted_bipred_idc: ::std::os::raw::c_int,
    pub pic_init_qp_minus26: ::std::os::raw::c_int,
    pub deblocking_filter_control_present_flag: ::std::os::raw::c_int,
    pub redundant_pic_cnt_present_flag: ::std::os::raw::c_int,
    pub transform_8x8_mode_flag: ::std::os::raw::c_int,
    pub MbaffFrameFlag: ::std::os::raw::c_int,
    pub constrained_intra_pred_flag: ::std::os::raw::c_int,
    pub chroma_qp_index_offset: ::std::os::raw::c_int,
    pub second_chroma_qp_index_offset: ::std::os::raw::c_int,
    pub ref_pic_flag: ::std::os::raw::c_int,
    pub frame_num: ::std::os::raw::c_int,
    pub CurrFieldOrderCnt: [::std::os::raw::c_int; 2usize],
    pub dpb: [CUVIDH264DPBENTRY; 16usize],
    pub WeightScale4x4: [[::std::os::raw::c_uchar; 16usize]; 6usize],
    pub WeightScale8x8: [[::std::os::raw::c_uchar; 64usize]; 2usize],
    pub fmo_aso_enable: ::std::os::raw::c_uchar,
    pub num_slice_groups_minus1: ::std::os::raw::c_uchar,
    pub slice_group_map_type: ::std::os::raw::c_uchar,
    pub pic_init_qs_minus26: ::std::os::raw::c_schar,
    pub slice_group_change_rate_minus1: ::std::os::raw::c_uint,
    pub fmo: _CUVIDH264PICPARAMS__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub Reserved: [::std::os::raw::c_uint; 11usize],
    pub __bindgen_anon_1: _CUVIDH264PICPARAMS__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDH264PICPARAMS__bindgen_ty_1 {
    pub slice_group_map_addr: ::std::os::raw::c_ulonglong,
    pub pMb2SliceGroupMap: *const ::std::os::raw::c_uchar,
}
impl Default for _CUVIDH264PICPARAMS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDH264PICPARAMS__bindgen_ty_2 {
    pub mvcext: CUVIDH264MVCEXT,
    pub svcext: CUVIDH264SVCEXT,
}
impl Default for _CUVIDH264PICPARAMS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CUVIDH264PICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CUVIDH264PICPARAMS {
    #[inline]
    pub fn mb_adaptive_frame_field_flag(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mb_adaptive_frame_field_flag(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mb_adaptive_frame_field_flag_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mb_adaptive_frame_field_flag_raw(
        this: *mut Self,
        val: ::std::os::raw::c_uint,
    ) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mb_adaptive_frame_field_flag: ::std::os::raw::c_uint,
        Reserved1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mb_adaptive_frame_field_flag: u32 =
                unsafe { ::std::mem::transmute(mb_adaptive_frame_field_flag) };
            mb_adaptive_frame_field_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type CUVIDH264PICPARAMS = _CUVIDH264PICPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDMPEG2PICPARAMS {
    pub ForwardRefIdx: ::std::os::raw::c_int,
    pub BackwardRefIdx: ::std::os::raw::c_int,
    pub picture_coding_type: ::std::os::raw::c_int,
    pub full_pel_forward_vector: ::std::os::raw::c_int,
    pub full_pel_backward_vector: ::std::os::raw::c_int,
    pub f_code: [[::std::os::raw::c_int; 2usize]; 2usize],
    pub intra_dc_precision: ::std::os::raw::c_int,
    pub frame_pred_frame_dct: ::std::os::raw::c_int,
    pub concealment_motion_vectors: ::std::os::raw::c_int,
    pub q_scale_type: ::std::os::raw::c_int,
    pub intra_vlc_format: ::std::os::raw::c_int,
    pub alternate_scan: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub QuantMatrixIntra: [::std::os::raw::c_uchar; 64usize],
    pub QuantMatrixInter: [::std::os::raw::c_uchar; 64usize],
}
impl Default for _CUVIDMPEG2PICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDMPEG2PICPARAMS = _CUVIDMPEG2PICPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDMPEG4PICPARAMS {
    pub ForwardRefIdx: ::std::os::raw::c_int,
    pub BackwardRefIdx: ::std::os::raw::c_int,
    pub video_object_layer_width: ::std::os::raw::c_int,
    pub video_object_layer_height: ::std::os::raw::c_int,
    pub vop_time_increment_bitcount: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub resync_marker_disable: ::std::os::raw::c_int,
    pub quant_type: ::std::os::raw::c_int,
    pub quarter_sample: ::std::os::raw::c_int,
    pub short_video_header: ::std::os::raw::c_int,
    pub divx_flags: ::std::os::raw::c_int,
    pub vop_coding_type: ::std::os::raw::c_int,
    pub vop_coded: ::std::os::raw::c_int,
    pub vop_rounding_type: ::std::os::raw::c_int,
    pub alternate_vertical_scan_flag: ::std::os::raw::c_int,
    pub interlaced: ::std::os::raw::c_int,
    pub vop_fcode_forward: ::std::os::raw::c_int,
    pub vop_fcode_backward: ::std::os::raw::c_int,
    pub trd: [::std::os::raw::c_int; 2usize],
    pub trb: [::std::os::raw::c_int; 2usize],
    pub QuantMatrixIntra: [::std::os::raw::c_uchar; 64usize],
    pub QuantMatrixInter: [::std::os::raw::c_uchar; 64usize],
    pub gmc_enabled: ::std::os::raw::c_int,
}
impl Default for _CUVIDMPEG4PICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDMPEG4PICPARAMS = _CUVIDMPEG4PICPARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDVC1PICPARAMS {
    pub ForwardRefIdx: ::std::os::raw::c_int,
    pub BackwardRefIdx: ::std::os::raw::c_int,
    pub FrameWidth: ::std::os::raw::c_int,
    pub FrameHeight: ::std::os::raw::c_int,
    pub intra_pic_flag: ::std::os::raw::c_int,
    pub ref_pic_flag: ::std::os::raw::c_int,
    pub progressive_fcm: ::std::os::raw::c_int,
    pub profile: ::std::os::raw::c_int,
    pub postprocflag: ::std::os::raw::c_int,
    pub pulldown: ::std::os::raw::c_int,
    pub interlace: ::std::os::raw::c_int,
    pub tfcntrflag: ::std::os::raw::c_int,
    pub finterpflag: ::std::os::raw::c_int,
    pub psf: ::std::os::raw::c_int,
    pub multires: ::std::os::raw::c_int,
    pub syncmarker: ::std::os::raw::c_int,
    pub rangered: ::std::os::raw::c_int,
    pub maxbframes: ::std::os::raw::c_int,
    pub panscan_flag: ::std::os::raw::c_int,
    pub refdist_flag: ::std::os::raw::c_int,
    pub extended_mv: ::std::os::raw::c_int,
    pub dquant: ::std::os::raw::c_int,
    pub vstransform: ::std::os::raw::c_int,
    pub loopfilter: ::std::os::raw::c_int,
    pub fastuvmc: ::std::os::raw::c_int,
    pub overlap: ::std::os::raw::c_int,
    pub quantizer: ::std::os::raw::c_int,
    pub extended_dmv: ::std::os::raw::c_int,
    pub range_mapy_flag: ::std::os::raw::c_int,
    pub range_mapy: ::std::os::raw::c_int,
    pub range_mapuv_flag: ::std::os::raw::c_int,
    pub range_mapuv: ::std::os::raw::c_int,
    pub rangeredfrm: ::std::os::raw::c_int,
}
pub type CUVIDVC1PICPARAMS = _CUVIDVC1PICPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDJPEGPICPARAMS {
    pub numComponents: ::std::os::raw::c_uchar,
    pub bitDepth: ::std::os::raw::c_uchar,
    pub quantizationTableSelector: [::std::os::raw::c_uchar; 4usize],
    pub scanOffset: [::std::os::raw::c_uint; 4usize],
    pub scanSize: [::std::os::raw::c_uint; 4usize],
    pub restartInterval: ::std::os::raw::c_ushort,
    pub componentIdentifier: [::std::os::raw::c_uchar; 4usize],
    pub hasQMatrix: ::std::os::raw::c_uchar,
    pub hasHuffman: ::std::os::raw::c_uchar,
    pub quantvals: [[::std::os::raw::c_ushort; 64usize]; 4usize],
    pub bits_ac: [[::std::os::raw::c_uchar; 16usize]; 4usize],
    pub table_ac: [[::std::os::raw::c_uchar; 256usize]; 4usize],
    pub bits_dc: [[::std::os::raw::c_uchar; 16usize]; 4usize],
    pub table_dc: [[::std::os::raw::c_uchar; 256usize]; 4usize],
}
impl Default for _CUVIDJPEGPICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDJPEGPICPARAMS = _CUVIDJPEGPICPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDHEVCPICPARAMS {
    pub pic_width_in_luma_samples: ::std::os::raw::c_int,
    pub pic_height_in_luma_samples: ::std::os::raw::c_int,
    pub log2_min_luma_coding_block_size_minus3: ::std::os::raw::c_uchar,
    pub log2_diff_max_min_luma_coding_block_size: ::std::os::raw::c_uchar,
    pub log2_min_transform_block_size_minus2: ::std::os::raw::c_uchar,
    pub log2_diff_max_min_transform_block_size: ::std::os::raw::c_uchar,
    pub pcm_enabled_flag: ::std::os::raw::c_uchar,
    pub log2_min_pcm_luma_coding_block_size_minus3: ::std::os::raw::c_uchar,
    pub log2_diff_max_min_pcm_luma_coding_block_size: ::std::os::raw::c_uchar,
    pub pcm_sample_bit_depth_luma_minus1: ::std::os::raw::c_uchar,
    pub pcm_sample_bit_depth_chroma_minus1: ::std::os::raw::c_uchar,
    pub pcm_loop_filter_disabled_flag: ::std::os::raw::c_uchar,
    pub strong_intra_smoothing_enabled_flag: ::std::os::raw::c_uchar,
    pub max_transform_hierarchy_depth_intra: ::std::os::raw::c_uchar,
    pub max_transform_hierarchy_depth_inter: ::std::os::raw::c_uchar,
    pub amp_enabled_flag: ::std::os::raw::c_uchar,
    pub separate_colour_plane_flag: ::std::os::raw::c_uchar,
    pub log2_max_pic_order_cnt_lsb_minus4: ::std::os::raw::c_uchar,
    pub num_short_term_ref_pic_sets: ::std::os::raw::c_uchar,
    pub long_term_ref_pics_present_flag: ::std::os::raw::c_uchar,
    pub num_long_term_ref_pics_sps: ::std::os::raw::c_uchar,
    pub sps_temporal_mvp_enabled_flag: ::std::os::raw::c_uchar,
    pub sample_adaptive_offset_enabled_flag: ::std::os::raw::c_uchar,
    pub scaling_list_enable_flag: ::std::os::raw::c_uchar,
    pub IrapPicFlag: ::std::os::raw::c_uchar,
    pub IdrPicFlag: ::std::os::raw::c_uchar,
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    pub log2_max_transform_skip_block_size_minus2: ::std::os::raw::c_uchar,
    pub log2_sao_offset_scale_luma: ::std::os::raw::c_uchar,
    pub log2_sao_offset_scale_chroma: ::std::os::raw::c_uchar,
    pub high_precision_offsets_enabled_flag: ::std::os::raw::c_uchar,
    pub reserved1: [::std::os::raw::c_uchar; 10usize],
    pub dependent_slice_segments_enabled_flag: ::std::os::raw::c_uchar,
    pub slice_segment_header_extension_present_flag: ::std::os::raw::c_uchar,
    pub sign_data_hiding_enabled_flag: ::std::os::raw::c_uchar,
    pub cu_qp_delta_enabled_flag: ::std::os::raw::c_uchar,
    pub diff_cu_qp_delta_depth: ::std::os::raw::c_uchar,
    pub init_qp_minus26: ::std::os::raw::c_schar,
    pub pps_cb_qp_offset: ::std::os::raw::c_schar,
    pub pps_cr_qp_offset: ::std::os::raw::c_schar,
    pub constrained_intra_pred_flag: ::std::os::raw::c_uchar,
    pub weighted_pred_flag: ::std::os::raw::c_uchar,
    pub weighted_bipred_flag: ::std::os::raw::c_uchar,
    pub transform_skip_enabled_flag: ::std::os::raw::c_uchar,
    pub transquant_bypass_enabled_flag: ::std::os::raw::c_uchar,
    pub entropy_coding_sync_enabled_flag: ::std::os::raw::c_uchar,
    pub log2_parallel_merge_level_minus2: ::std::os::raw::c_uchar,
    pub num_extra_slice_header_bits: ::std::os::raw::c_uchar,
    pub loop_filter_across_tiles_enabled_flag: ::std::os::raw::c_uchar,
    pub loop_filter_across_slices_enabled_flag: ::std::os::raw::c_uchar,
    pub output_flag_present_flag: ::std::os::raw::c_uchar,
    pub num_ref_idx_l0_default_active_minus1: ::std::os::raw::c_uchar,
    pub num_ref_idx_l1_default_active_minus1: ::std::os::raw::c_uchar,
    pub lists_modification_present_flag: ::std::os::raw::c_uchar,
    pub cabac_init_present_flag: ::std::os::raw::c_uchar,
    pub pps_slice_chroma_qp_offsets_present_flag: ::std::os::raw::c_uchar,
    pub deblocking_filter_override_enabled_flag: ::std::os::raw::c_uchar,
    pub pps_deblocking_filter_disabled_flag: ::std::os::raw::c_uchar,
    pub pps_beta_offset_div2: ::std::os::raw::c_schar,
    pub pps_tc_offset_div2: ::std::os::raw::c_schar,
    pub tiles_enabled_flag: ::std::os::raw::c_uchar,
    pub uniform_spacing_flag: ::std::os::raw::c_uchar,
    pub num_tile_columns_minus1: ::std::os::raw::c_uchar,
    pub num_tile_rows_minus1: ::std::os::raw::c_uchar,
    pub column_width_minus1: [::std::os::raw::c_ushort; 21usize],
    pub row_height_minus1: [::std::os::raw::c_ushort; 21usize],
    pub sps_range_extension_flag: ::std::os::raw::c_uchar,
    pub transform_skip_rotation_enabled_flag: ::std::os::raw::c_uchar,
    pub transform_skip_context_enabled_flag: ::std::os::raw::c_uchar,
    pub implicit_rdpcm_enabled_flag: ::std::os::raw::c_uchar,
    pub explicit_rdpcm_enabled_flag: ::std::os::raw::c_uchar,
    pub extended_precision_processing_flag: ::std::os::raw::c_uchar,
    pub intra_smoothing_disabled_flag: ::std::os::raw::c_uchar,
    pub persistent_rice_adaptation_enabled_flag: ::std::os::raw::c_uchar,
    pub cabac_bypass_alignment_enabled_flag: ::std::os::raw::c_uchar,
    pub pps_range_extension_flag: ::std::os::raw::c_uchar,
    pub cross_component_prediction_enabled_flag: ::std::os::raw::c_uchar,
    pub chroma_qp_offset_list_enabled_flag: ::std::os::raw::c_uchar,
    pub diff_cu_chroma_qp_offset_depth: ::std::os::raw::c_uchar,
    pub chroma_qp_offset_list_len_minus1: ::std::os::raw::c_uchar,
    pub cb_qp_offset_list: [::std::os::raw::c_schar; 6usize],
    pub cr_qp_offset_list: [::std::os::raw::c_schar; 6usize],
    pub reserved2: [::std::os::raw::c_uchar; 2usize],
    pub reserved3: [::std::os::raw::c_uint; 8usize],
    pub NumBitsForShortTermRPSInSlice: ::std::os::raw::c_int,
    pub NumDeltaPocsOfRefRpsIdx: ::std::os::raw::c_int,
    pub NumPocTotalCurr: ::std::os::raw::c_int,
    pub NumPocStCurrBefore: ::std::os::raw::c_int,
    pub NumPocStCurrAfter: ::std::os::raw::c_int,
    pub NumPocLtCurr: ::std::os::raw::c_int,
    pub CurrPicOrderCntVal: ::std::os::raw::c_int,
    pub RefPicIdx: [::std::os::raw::c_int; 16usize],
    pub PicOrderCntVal: [::std::os::raw::c_int; 16usize],
    pub IsLongTerm: [::std::os::raw::c_uchar; 16usize],
    pub RefPicSetStCurrBefore: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetStCurrAfter: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetLtCurr: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetInterLayer0: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetInterLayer1: [::std::os::raw::c_uchar; 8usize],
    pub reserved4: [::std::os::raw::c_uint; 12usize],
    pub ScalingList4x4: [[::std::os::raw::c_uchar; 16usize]; 6usize],
    pub ScalingList8x8: [[::std::os::raw::c_uchar; 64usize]; 6usize],
    pub ScalingList16x16: [[::std::os::raw::c_uchar; 64usize]; 6usize],
    pub ScalingList32x32: [[::std::os::raw::c_uchar; 64usize]; 2usize],
    pub ScalingListDCCoeff16x16: [::std::os::raw::c_uchar; 6usize],
    pub ScalingListDCCoeff32x32: [::std::os::raw::c_uchar; 2usize],
}
impl Default for _CUVIDHEVCPICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDHEVCPICPARAMS = _CUVIDHEVCPICPARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CUVIDVP8PICPARAMS {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub first_partition_size: ::std::os::raw::c_uint,
    pub LastRefIdx: ::std::os::raw::c_uchar,
    pub GoldenRefIdx: ::std::os::raw::c_uchar,
    pub AltRefIdx: ::std::os::raw::c_uchar,
    pub __bindgen_anon_1: _CUVIDVP8PICPARAMS__bindgen_ty_1,
    pub Reserved1: [::std::os::raw::c_uchar; 4usize],
    pub Reserved2: [::std::os::raw::c_uint; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDVP8PICPARAMS__bindgen_ty_1 {
    pub vp8_frame_tag: _CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1,
    pub wFrameTagFlags: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frame_type_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_frame_type_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn version_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_version_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn show_frame(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn show_frame_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_show_frame_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn update_mb_segmentation_data(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_update_mb_segmentation_data(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn update_mb_segmentation_data_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_update_mb_segmentation_data_raw(
        this: *mut Self,
        val: ::std::os::raw::c_uchar,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2Bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved2Bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2Bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2Bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_type: ::std::os::raw::c_uchar,
        version: ::std::os::raw::c_uchar,
        show_frame: ::std::os::raw::c_uchar,
        update_mb_segmentation_data: ::std::os::raw::c_uchar,
        Reserved2Bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frame_type: u8 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let version: u8 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let show_frame: u8 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let update_mb_segmentation_data: u8 =
                unsafe { ::std::mem::transmute(update_mb_segmentation_data) };
            update_mb_segmentation_data as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Reserved2Bits: u8 = unsafe { ::std::mem::transmute(Reserved2Bits) };
            Reserved2Bits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _CUVIDVP8PICPARAMS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CUVIDVP8PICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDVP8PICPARAMS = _CUVIDVP8PICPARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDVP9PICPARAMS {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub LastRefIdx: ::std::os::raw::c_uchar,
    pub GoldenRefIdx: ::std::os::raw::c_uchar,
    pub AltRefIdx: ::std::os::raw::c_uchar,
    pub colorSpace: ::std::os::raw::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub reserved16Bits: ::std::os::raw::c_ushort,
    pub refFrameSignBias: [::std::os::raw::c_uchar; 4usize],
    pub bitDepthMinus8Luma: ::std::os::raw::c_uchar,
    pub bitDepthMinus8Chroma: ::std::os::raw::c_uchar,
    pub loopFilterLevel: ::std::os::raw::c_uchar,
    pub loopFilterSharpness: ::std::os::raw::c_uchar,
    pub modeRefLfEnabled: ::std::os::raw::c_uchar,
    pub log2_tile_columns: ::std::os::raw::c_uchar,
    pub log2_tile_rows: ::std::os::raw::c_uchar,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub segmentFeatureEnable: [[::std::os::raw::c_uchar; 4usize]; 8usize],
    pub segmentFeatureData: [[::std::os::raw::c_short; 4usize]; 8usize],
    pub mb_segment_tree_probs: [::std::os::raw::c_uchar; 7usize],
    pub segment_pred_probs: [::std::os::raw::c_uchar; 3usize],
    pub reservedSegment16Bits: [::std::os::raw::c_uchar; 2usize],
    pub qpYAc: ::std::os::raw::c_int,
    pub qpYDc: ::std::os::raw::c_int,
    pub qpChDc: ::std::os::raw::c_int,
    pub qpChAc: ::std::os::raw::c_int,
    pub activeRefIdx: [::std::os::raw::c_uint; 3usize],
    pub resetFrameContext: ::std::os::raw::c_uint,
    pub mcomp_filter_type: ::std::os::raw::c_uint,
    pub mbRefLfDelta: [::std::os::raw::c_uint; 4usize],
    pub mbModeLfDelta: [::std::os::raw::c_uint; 2usize],
    pub frameTagSize: ::std::os::raw::c_uint,
    pub offsetToDctParts: ::std::os::raw::c_uint,
    pub reserved128Bits: [::std::os::raw::c_uint; 4usize],
}
impl _CUVIDVP9PICPARAMS {
    #[inline]
    pub fn profile(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_profile(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn profile_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_profile_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn frameContextIdx(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_frameContextIdx(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frameContextIdx_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_frameContextIdx_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn frameType(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_frameType(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frameType_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_frameType_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn showFrame(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_showFrame(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn showFrame_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_showFrame_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn errorResilient(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_errorResilient(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn errorResilient_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_errorResilient_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn frameParallelDecoding(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_frameParallelDecoding(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frameParallelDecoding_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_frameParallelDecoding_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn subSamplingX(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_subSamplingX(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn subSamplingX_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_subSamplingX_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn subSamplingY(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_subSamplingY(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn subSamplingY_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_subSamplingY_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intraOnly(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_intraOnly(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intraOnly_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_intraOnly_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_high_precision_mv_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_allow_high_precision_mv_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn refreshEntropyProbs(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_refreshEntropyProbs(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn refreshEntropyProbs_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_refreshEntropyProbs_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved2Bits(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_reserved2Bits(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved2Bits_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reserved2Bits_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        profile: ::std::os::raw::c_ushort,
        frameContextIdx: ::std::os::raw::c_ushort,
        frameType: ::std::os::raw::c_ushort,
        showFrame: ::std::os::raw::c_ushort,
        errorResilient: ::std::os::raw::c_ushort,
        frameParallelDecoding: ::std::os::raw::c_ushort,
        subSamplingX: ::std::os::raw::c_ushort,
        subSamplingY: ::std::os::raw::c_ushort,
        intraOnly: ::std::os::raw::c_ushort,
        allow_high_precision_mv: ::std::os::raw::c_ushort,
        refreshEntropyProbs: ::std::os::raw::c_ushort,
        reserved2Bits: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let profile: u16 = unsafe { ::std::mem::transmute(profile) };
            profile as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let frameContextIdx: u16 = unsafe { ::std::mem::transmute(frameContextIdx) };
            frameContextIdx as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frameType: u16 = unsafe { ::std::mem::transmute(frameType) };
            frameType as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let showFrame: u16 = unsafe { ::std::mem::transmute(showFrame) };
            showFrame as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let errorResilient: u16 = unsafe { ::std::mem::transmute(errorResilient) };
            errorResilient as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let frameParallelDecoding: u16 =
                unsafe { ::std::mem::transmute(frameParallelDecoding) };
            frameParallelDecoding as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let subSamplingX: u16 = unsafe { ::std::mem::transmute(subSamplingX) };
            subSamplingX as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let subSamplingY: u16 = unsafe { ::std::mem::transmute(subSamplingY) };
            subSamplingY as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let intraOnly: u16 = unsafe { ::std::mem::transmute(intraOnly) };
            intraOnly as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let allow_high_precision_mv: u16 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let refreshEntropyProbs: u16 = unsafe { ::std::mem::transmute(refreshEntropyProbs) };
            refreshEntropyProbs as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let reserved2Bits: u16 = unsafe { ::std::mem::transmute(reserved2Bits) };
            reserved2Bits as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn segmentEnabled(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentEnabled(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentEnabled_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentEnabled_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn segmentMapUpdate(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentMapUpdate(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentMapUpdate_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentMapUpdate_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn segmentMapTemporalUpdate(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentMapTemporalUpdate(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentMapTemporalUpdate_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentMapTemporalUpdate_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn segmentFeatureMode(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentFeatureMode(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentFeatureMode_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentFeatureMode_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved4Bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved4Bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved4Bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved4Bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        segmentEnabled: ::std::os::raw::c_uchar,
        segmentMapUpdate: ::std::os::raw::c_uchar,
        segmentMapTemporalUpdate: ::std::os::raw::c_uchar,
        segmentFeatureMode: ::std::os::raw::c_uchar,
        reserved4Bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let segmentEnabled: u8 = unsafe { ::std::mem::transmute(segmentEnabled) };
            segmentEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let segmentMapUpdate: u8 = unsafe { ::std::mem::transmute(segmentMapUpdate) };
            segmentMapUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let segmentMapTemporalUpdate: u8 =
                unsafe { ::std::mem::transmute(segmentMapTemporalUpdate) };
            segmentMapTemporalUpdate as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let segmentFeatureMode: u8 = unsafe { ::std::mem::transmute(segmentFeatureMode) };
            segmentFeatureMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved4Bits: u8 = unsafe { ::std::mem::transmute(reserved4Bits) };
            reserved4Bits as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type CUVIDVP9PICPARAMS = _CUVIDVP9PICPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDAV1PICPARAMS {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub frame_offset: ::std::os::raw::c_uint,
    pub decodePicIdx: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
    pub tile_widths: [::std::os::raw::c_ushort; 64usize],
    pub tile_heights: [::std::os::raw::c_ushort; 64usize],
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub cdef_y_strength: [::std::os::raw::c_uchar; 8usize],
    pub cdef_uv_strength: [::std::os::raw::c_uchar; 8usize],
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub base_qindex: ::std::os::raw::c_uchar,
    pub qp_y_dc_delta_q: ::std::os::raw::c_char,
    pub qp_u_dc_delta_q: ::std::os::raw::c_char,
    pub qp_v_dc_delta_q: ::std::os::raw::c_char,
    pub qp_u_ac_delta_q: ::std::os::raw::c_char,
    pub qp_v_ac_delta_q: ::std::os::raw::c_char,
    pub qm_y: ::std::os::raw::c_uchar,
    pub qm_u: ::std::os::raw::c_uchar,
    pub qm_v: ::std::os::raw::c_uchar,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub segmentation_feature_data: [[::std::os::raw::c_short; 8usize]; 8usize],
    pub segmentation_feature_mask: [::std::os::raw::c_uchar; 8usize],
    pub loop_filter_level: [::std::os::raw::c_uchar; 2usize],
    pub loop_filter_level_u: ::std::os::raw::c_uchar,
    pub loop_filter_level_v: ::std::os::raw::c_uchar,
    pub loop_filter_sharpness: ::std::os::raw::c_uchar,
    pub loop_filter_ref_deltas: [::std::os::raw::c_char; 8usize],
    pub loop_filter_mode_deltas: [::std::os::raw::c_char; 2usize],
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub lr_unit_size: [::std::os::raw::c_uchar; 3usize],
    pub lr_type: [::std::os::raw::c_uchar; 3usize],
    pub primary_ref_frame: ::std::os::raw::c_uchar,
    pub ref_frame_map: [::std::os::raw::c_uchar; 8usize],
    pub _bitfield_align_6: [u8; 0],
    pub _bitfield_6: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved5_32bits: [::std::os::raw::c_uchar; 4usize],
    pub ref_frame: [_CUVIDAV1PICPARAMS__bindgen_ty_1; 7usize],
    pub global_motion: [_CUVIDAV1PICPARAMS__bindgen_ty_2; 7usize],
    pub _bitfield_align_7: [u8; 0],
    pub _bitfield_7: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub num_y_points: ::std::os::raw::c_uchar,
    pub scaling_points_y: [[::std::os::raw::c_uchar; 2usize]; 14usize],
    pub num_cb_points: ::std::os::raw::c_uchar,
    pub scaling_points_cb: [[::std::os::raw::c_uchar; 2usize]; 10usize],
    pub num_cr_points: ::std::os::raw::c_uchar,
    pub scaling_points_cr: [[::std::os::raw::c_uchar; 2usize]; 10usize],
    pub reserved7_8bits: ::std::os::raw::c_uchar,
    pub random_seed: ::std::os::raw::c_ushort,
    pub ar_coeffs_y: [::std::os::raw::c_short; 24usize],
    pub ar_coeffs_cb: [::std::os::raw::c_short; 25usize],
    pub ar_coeffs_cr: [::std::os::raw::c_short; 25usize],
    pub cb_mult: ::std::os::raw::c_uchar,
    pub cb_luma_mult: ::std::os::raw::c_uchar,
    pub cb_offset: ::std::os::raw::c_short,
    pub cr_mult: ::std::os::raw::c_uchar,
    pub cr_luma_mult: ::std::os::raw::c_uchar,
    pub cr_offset: ::std::os::raw::c_short,
    pub reserved: [::std::os::raw::c_int; 7usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDAV1PICPARAMS__bindgen_ty_1 {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub index: ::std::os::raw::c_uchar,
    pub reserved24Bits: [::std::os::raw::c_uchar; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDAV1PICPARAMS__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved24Bits: [::std::os::raw::c_char; 3usize],
    pub wmmat: [::std::os::raw::c_int; 6usize],
}
impl _CUVIDAV1PICPARAMS__bindgen_ty_2 {
    #[inline]
    pub fn invalid(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_invalid(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn invalid_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_invalid_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wmtype(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_wmtype(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wmtype_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_wmtype_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved5Bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved5Bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved5Bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved5Bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        invalid: ::std::os::raw::c_uchar,
        wmtype: ::std::os::raw::c_uchar,
        reserved5Bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let invalid: u8 = unsafe { ::std::mem::transmute(invalid) };
            invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let wmtype: u8 = unsafe { ::std::mem::transmute(wmtype) };
            wmtype as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved5Bits: u8 = unsafe { ::std::mem::transmute(reserved5Bits) };
            reserved5Bits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _CUVIDAV1PICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CUVIDAV1PICPARAMS {
    #[inline]
    pub fn profile(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_profile(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn profile_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_profile_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_128x128_superblock(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_128x128_superblock(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_128x128_superblock_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_128x128_superblock_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn subsampling_x(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_x(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn subsampling_x_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_subsampling_x_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn subsampling_y(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_y(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn subsampling_y_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_subsampling_y_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mono_chrome(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mono_chrome(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mono_chrome_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mono_chrome_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bit_depth_minus8(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bit_depth_minus8(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bit_depth_minus8_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bit_depth_minus8_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_filter_intra(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_filter_intra(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_filter_intra_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_filter_intra_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_intra_edge_filter(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_intra_edge_filter(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_intra_edge_filter_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_intra_edge_filter_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_interintra_compound(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_interintra_compound(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_interintra_compound_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_interintra_compound_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_masked_compound(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_masked_compound(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_masked_compound_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_masked_compound_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_dual_filter(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_dual_filter(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_dual_filter_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_dual_filter_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_order_hint(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_order_hint(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_order_hint_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_order_hint_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn order_hint_bits_minus1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_order_hint_bits_minus1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn order_hint_bits_minus1_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_order_hint_bits_minus1_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_jnt_comp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_jnt_comp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_jnt_comp_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_jnt_comp_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_superres(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_superres(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_superres_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_superres_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_cdef(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_cdef(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_cdef_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_cdef_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_restoration(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_restoration(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_restoration_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_restoration_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enable_fgs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_fgs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enable_fgs_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enable_fgs_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved0_7bits(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0_7bits(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved0_7bits_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved0_7bits_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn frame_type(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frame_type_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_frame_type_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn show_frame(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn show_frame_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_show_frame_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disable_cdf_update(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_cdf_update(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disable_cdf_update_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disable_cdf_update_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_screen_content_tools(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_screen_content_tools(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_screen_content_tools_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_allow_screen_content_tools_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn force_integer_mv(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_integer_mv(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn force_integer_mv_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_force_integer_mv_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn coded_denom(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_coded_denom(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn coded_denom_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_coded_denom_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_intrabc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_intrabc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_intrabc_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                41usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_allow_intrabc_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_high_precision_mv_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                42usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_allow_high_precision_mv_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn interp_filter(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_interp_filter(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn interp_filter_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                43usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_interp_filter_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                43usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn switchable_motion_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_switchable_motion_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn switchable_motion_mode_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                46usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_switchable_motion_mode_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                46usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_ref_frame_mvs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_ref_frame_mvs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_ref_frame_mvs_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                47usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_ref_frame_mvs_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disable_frame_end_update_cdf(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_frame_end_update_cdf(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disable_frame_end_update_cdf_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disable_frame_end_update_cdf_raw(
        this: *mut Self,
        val: ::std::os::raw::c_uint,
    ) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn delta_q_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_q_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn delta_q_present_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_delta_q_present_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn delta_q_res(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_delta_q_res(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn delta_q_res_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                50usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_delta_q_res_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                50usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn using_qmatrix(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_using_qmatrix(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn using_qmatrix_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                52usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_using_qmatrix_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn coded_lossless(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_coded_lossless(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn coded_lossless_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                53usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_coded_lossless_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_superres(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_superres(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_superres_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                54usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_superres_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                54usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tx_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tx_mode_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                55usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tx_mode_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                55usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reference_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reference_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reference_mode_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                57usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reference_mode_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                57usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_warped_motion(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_warped_motion(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_warped_motion_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                58usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_allow_warped_motion_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                58usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reduced_tx_set(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reduced_tx_set(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reduced_tx_set_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reduced_tx_set_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_mode_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                60usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_mode_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1_3bits(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1_3bits(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_3bits_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                61usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_3bits_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                61usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn num_tile_cols(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_num_tile_cols(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn num_tile_cols_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                64usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_num_tile_cols_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                64usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn num_tile_rows(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_num_tile_rows(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn num_tile_rows_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                72usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_num_tile_rows_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                72usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn context_update_tile_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_context_update_tile_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn context_update_tile_id_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                80usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_context_update_tile_id_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                80usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        profile: ::std::os::raw::c_uint,
        use_128x128_superblock: ::std::os::raw::c_uint,
        subsampling_x: ::std::os::raw::c_uint,
        subsampling_y: ::std::os::raw::c_uint,
        mono_chrome: ::std::os::raw::c_uint,
        bit_depth_minus8: ::std::os::raw::c_uint,
        enable_filter_intra: ::std::os::raw::c_uint,
        enable_intra_edge_filter: ::std::os::raw::c_uint,
        enable_interintra_compound: ::std::os::raw::c_uint,
        enable_masked_compound: ::std::os::raw::c_uint,
        enable_dual_filter: ::std::os::raw::c_uint,
        enable_order_hint: ::std::os::raw::c_uint,
        order_hint_bits_minus1: ::std::os::raw::c_uint,
        enable_jnt_comp: ::std::os::raw::c_uint,
        enable_superres: ::std::os::raw::c_uint,
        enable_cdef: ::std::os::raw::c_uint,
        enable_restoration: ::std::os::raw::c_uint,
        enable_fgs: ::std::os::raw::c_uint,
        reserved0_7bits: ::std::os::raw::c_uint,
        frame_type: ::std::os::raw::c_uint,
        show_frame: ::std::os::raw::c_uint,
        disable_cdf_update: ::std::os::raw::c_uint,
        allow_screen_content_tools: ::std::os::raw::c_uint,
        force_integer_mv: ::std::os::raw::c_uint,
        coded_denom: ::std::os::raw::c_uint,
        allow_intrabc: ::std::os::raw::c_uint,
        allow_high_precision_mv: ::std::os::raw::c_uint,
        interp_filter: ::std::os::raw::c_uint,
        switchable_motion_mode: ::std::os::raw::c_uint,
        use_ref_frame_mvs: ::std::os::raw::c_uint,
        disable_frame_end_update_cdf: ::std::os::raw::c_uint,
        delta_q_present: ::std::os::raw::c_uint,
        delta_q_res: ::std::os::raw::c_uint,
        using_qmatrix: ::std::os::raw::c_uint,
        coded_lossless: ::std::os::raw::c_uint,
        use_superres: ::std::os::raw::c_uint,
        tx_mode: ::std::os::raw::c_uint,
        reference_mode: ::std::os::raw::c_uint,
        allow_warped_motion: ::std::os::raw::c_uint,
        reduced_tx_set: ::std::os::raw::c_uint,
        skip_mode: ::std::os::raw::c_uint,
        reserved1_3bits: ::std::os::raw::c_uint,
        num_tile_cols: ::std::os::raw::c_uint,
        num_tile_rows: ::std::os::raw::c_uint,
        context_update_tile_id: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let profile: u32 = unsafe { ::std::mem::transmute(profile) };
            profile as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let use_128x128_superblock: u32 =
                unsafe { ::std::mem::transmute(use_128x128_superblock) };
            use_128x128_superblock as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let subsampling_x: u32 = unsafe { ::std::mem::transmute(subsampling_x) };
            subsampling_x as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let subsampling_y: u32 = unsafe { ::std::mem::transmute(subsampling_y) };
            subsampling_y as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mono_chrome: u32 = unsafe { ::std::mem::transmute(mono_chrome) };
            mono_chrome as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let bit_depth_minus8: u32 = unsafe { ::std::mem::transmute(bit_depth_minus8) };
            bit_depth_minus8 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enable_filter_intra: u32 = unsafe { ::std::mem::transmute(enable_filter_intra) };
            enable_filter_intra as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enable_intra_edge_filter: u32 =
                unsafe { ::std::mem::transmute(enable_intra_edge_filter) };
            enable_intra_edge_filter as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enable_interintra_compound: u32 =
                unsafe { ::std::mem::transmute(enable_interintra_compound) };
            enable_interintra_compound as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enable_masked_compound: u32 =
                unsafe { ::std::mem::transmute(enable_masked_compound) };
            enable_masked_compound as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enable_dual_filter: u32 = unsafe { ::std::mem::transmute(enable_dual_filter) };
            enable_dual_filter as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enable_order_hint: u32 = unsafe { ::std::mem::transmute(enable_order_hint) };
            enable_order_hint as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let order_hint_bits_minus1: u32 =
                unsafe { ::std::mem::transmute(order_hint_bits_minus1) };
            order_hint_bits_minus1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let enable_jnt_comp: u32 = unsafe { ::std::mem::transmute(enable_jnt_comp) };
            enable_jnt_comp as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let enable_superres: u32 = unsafe { ::std::mem::transmute(enable_superres) };
            enable_superres as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let enable_cdef: u32 = unsafe { ::std::mem::transmute(enable_cdef) };
            enable_cdef as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let enable_restoration: u32 = unsafe { ::std::mem::transmute(enable_restoration) };
            enable_restoration as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let enable_fgs: u32 = unsafe { ::std::mem::transmute(enable_fgs) };
            enable_fgs as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved0_7bits: u32 = unsafe { ::std::mem::transmute(reserved0_7bits) };
            reserved0_7bits as u64
        });
        __bindgen_bitfield_unit.set(32usize, 2u8, {
            let frame_type: u32 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let show_frame: u32 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let disable_cdf_update: u32 = unsafe { ::std::mem::transmute(disable_cdf_update) };
            disable_cdf_update as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let allow_screen_content_tools: u32 =
                unsafe { ::std::mem::transmute(allow_screen_content_tools) };
            allow_screen_content_tools as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let force_integer_mv: u32 = unsafe { ::std::mem::transmute(force_integer_mv) };
            force_integer_mv as u64
        });
        __bindgen_bitfield_unit.set(38usize, 3u8, {
            let coded_denom: u32 = unsafe { ::std::mem::transmute(coded_denom) };
            coded_denom as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let allow_intrabc: u32 = unsafe { ::std::mem::transmute(allow_intrabc) };
            allow_intrabc as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let allow_high_precision_mv: u32 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(43usize, 3u8, {
            let interp_filter: u32 = unsafe { ::std::mem::transmute(interp_filter) };
            interp_filter as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let switchable_motion_mode: u32 =
                unsafe { ::std::mem::transmute(switchable_motion_mode) };
            switchable_motion_mode as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let use_ref_frame_mvs: u32 = unsafe { ::std::mem::transmute(use_ref_frame_mvs) };
            use_ref_frame_mvs as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let disable_frame_end_update_cdf: u32 =
                unsafe { ::std::mem::transmute(disable_frame_end_update_cdf) };
            disable_frame_end_update_cdf as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let delta_q_present: u32 = unsafe { ::std::mem::transmute(delta_q_present) };
            delta_q_present as u64
        });
        __bindgen_bitfield_unit.set(50usize, 2u8, {
            let delta_q_res: u32 = unsafe { ::std::mem::transmute(delta_q_res) };
            delta_q_res as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let using_qmatrix: u32 = unsafe { ::std::mem::transmute(using_qmatrix) };
            using_qmatrix as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let coded_lossless: u32 = unsafe { ::std::mem::transmute(coded_lossless) };
            coded_lossless as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let use_superres: u32 = unsafe { ::std::mem::transmute(use_superres) };
            use_superres as u64
        });
        __bindgen_bitfield_unit.set(55usize, 2u8, {
            let tx_mode: u32 = unsafe { ::std::mem::transmute(tx_mode) };
            tx_mode as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let reference_mode: u32 = unsafe { ::std::mem::transmute(reference_mode) };
            reference_mode as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let allow_warped_motion: u32 = unsafe { ::std::mem::transmute(allow_warped_motion) };
            allow_warped_motion as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let reduced_tx_set: u32 = unsafe { ::std::mem::transmute(reduced_tx_set) };
            reduced_tx_set as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let skip_mode: u32 = unsafe { ::std::mem::transmute(skip_mode) };
            skip_mode as u64
        });
        __bindgen_bitfield_unit.set(61usize, 3u8, {
            let reserved1_3bits: u32 = unsafe { ::std::mem::transmute(reserved1_3bits) };
            reserved1_3bits as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let num_tile_cols: u32 = unsafe { ::std::mem::transmute(num_tile_cols) };
            num_tile_cols as u64
        });
        __bindgen_bitfield_unit.set(72usize, 8u8, {
            let num_tile_rows: u32 = unsafe { ::std::mem::transmute(num_tile_rows) };
            num_tile_rows as u64
        });
        __bindgen_bitfield_unit.set(80usize, 16u8, {
            let context_update_tile_id: u32 =
                unsafe { ::std::mem::transmute(context_update_tile_id) };
            context_update_tile_id as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cdef_damping_minus_3(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_cdef_damping_minus_3(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cdef_damping_minus_3_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_cdef_damping_minus_3_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cdef_bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_cdef_bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cdef_bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_cdef_bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved2_4bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved2_4bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved2_4bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved2_4bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        cdef_damping_minus_3: ::std::os::raw::c_uchar,
        cdef_bits: ::std::os::raw::c_uchar,
        reserved2_4bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cdef_damping_minus_3: u8 = unsafe { ::std::mem::transmute(cdef_damping_minus_3) };
            cdef_damping_minus_3 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let cdef_bits: u8 = unsafe { ::std::mem::transmute(cdef_bits) };
            cdef_bits as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved2_4bits: u8 = unsafe { ::std::mem::transmute(reserved2_4bits) };
            reserved2_4bits as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn SkipModeFrame0(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_SkipModeFrame0(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SkipModeFrame0_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SkipModeFrame0_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SkipModeFrame1(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_SkipModeFrame1(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SkipModeFrame1_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_3),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_SkipModeFrame1_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_3),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        SkipModeFrame0: ::std::os::raw::c_uchar,
        SkipModeFrame1: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SkipModeFrame0: u8 = unsafe { ::std::mem::transmute(SkipModeFrame0) };
            SkipModeFrame0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let SkipModeFrame1: u8 = unsafe { ::std::mem::transmute(SkipModeFrame1) };
            SkipModeFrame1 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentation_enabled_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentation_enabled_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn segmentation_update_map(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_update_map(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentation_update_map_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentation_update_map_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn segmentation_update_data(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_update_data(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentation_update_data_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentation_update_data_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn segmentation_temporal_update(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_temporal_update(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentation_temporal_update_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentation_temporal_update_raw(
        this: *mut Self,
        val: ::std::os::raw::c_uchar,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved3_4bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved3_4bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved3_4bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_4),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved3_4bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_4),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        segmentation_enabled: ::std::os::raw::c_uchar,
        segmentation_update_map: ::std::os::raw::c_uchar,
        segmentation_update_data: ::std::os::raw::c_uchar,
        segmentation_temporal_update: ::std::os::raw::c_uchar,
        reserved3_4bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let segmentation_enabled: u8 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let segmentation_update_map: u8 =
                unsafe { ::std::mem::transmute(segmentation_update_map) };
            segmentation_update_map as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let segmentation_update_data: u8 =
                unsafe { ::std::mem::transmute(segmentation_update_data) };
            segmentation_update_data as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let segmentation_temporal_update: u8 =
                unsafe { ::std::mem::transmute(segmentation_temporal_update) };
            segmentation_temporal_update as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved3_4bits: u8 = unsafe { ::std::mem::transmute(reserved3_4bits) };
            reserved3_4bits as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn loop_filter_delta_enabled(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_loop_filter_delta_enabled(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn loop_filter_delta_enabled_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_loop_filter_delta_enabled_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn loop_filter_delta_update(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_loop_filter_delta_update(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn loop_filter_delta_update_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_loop_filter_delta_update_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn delta_lf_present(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_delta_lf_present(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn delta_lf_present_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_delta_lf_present_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn delta_lf_res(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_delta_lf_res(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn delta_lf_res_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                3usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_delta_lf_res_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn delta_lf_multi(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_delta_lf_multi(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn delta_lf_multi_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_delta_lf_multi_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved4_2bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_reserved4_2bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved4_2bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_5),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved4_2bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_5),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_5(
        loop_filter_delta_enabled: ::std::os::raw::c_uchar,
        loop_filter_delta_update: ::std::os::raw::c_uchar,
        delta_lf_present: ::std::os::raw::c_uchar,
        delta_lf_res: ::std::os::raw::c_uchar,
        delta_lf_multi: ::std::os::raw::c_uchar,
        reserved4_2bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let loop_filter_delta_enabled: u8 =
                unsafe { ::std::mem::transmute(loop_filter_delta_enabled) };
            loop_filter_delta_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let loop_filter_delta_update: u8 =
                unsafe { ::std::mem::transmute(loop_filter_delta_update) };
            loop_filter_delta_update as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let delta_lf_present: u8 = unsafe { ::std::mem::transmute(delta_lf_present) };
            delta_lf_present as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let delta_lf_res: u8 = unsafe { ::std::mem::transmute(delta_lf_res) };
            delta_lf_res as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let delta_lf_multi: u8 = unsafe { ::std::mem::transmute(delta_lf_multi) };
            delta_lf_multi as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let reserved4_2bits: u8 = unsafe { ::std::mem::transmute(reserved4_2bits) };
            reserved4_2bits as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn temporal_layer_id(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_temporal_layer_id(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_6.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn temporal_layer_id_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_temporal_layer_id_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spatial_layer_id(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_spatial_layer_id(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_6.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spatial_layer_id_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_6),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_spatial_layer_id_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_6),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_6(
        temporal_layer_id: ::std::os::raw::c_uchar,
        spatial_layer_id: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let temporal_layer_id: u8 = unsafe { ::std::mem::transmute(temporal_layer_id) };
            temporal_layer_id as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let spatial_layer_id: u8 = unsafe { ::std::mem::transmute(spatial_layer_id) };
            spatial_layer_id as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn apply_grain(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_apply_grain(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn apply_grain_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_apply_grain_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn overlap_flag(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_overlap_flag(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn overlap_flag_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_overlap_flag_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scaling_shift_minus8(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_scaling_shift_minus8(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scaling_shift_minus8_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                2usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_scaling_shift_minus8_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn chroma_scaling_from_luma(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_chroma_scaling_from_luma(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn chroma_scaling_from_luma_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_chroma_scaling_from_luma_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ar_coeff_lag(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_ar_coeff_lag(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ar_coeff_lag_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                5usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ar_coeff_lag_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                5usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ar_coeff_shift_minus6(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(7usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_ar_coeff_shift_minus6(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ar_coeff_shift_minus6_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                7usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ar_coeff_shift_minus6_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                7usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn grain_scale_shift(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(9usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_grain_scale_shift(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn grain_scale_shift_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                9usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_grain_scale_shift_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                9usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn clip_to_restricted_range(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_clip_to_restricted_range(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn clip_to_restricted_range_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_clip_to_restricted_range_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved6_4bits(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_reserved6_4bits(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved6_4bits_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_7),
                12usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reserved6_4bits_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_7),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_7(
        apply_grain: ::std::os::raw::c_ushort,
        overlap_flag: ::std::os::raw::c_ushort,
        scaling_shift_minus8: ::std::os::raw::c_ushort,
        chroma_scaling_from_luma: ::std::os::raw::c_ushort,
        ar_coeff_lag: ::std::os::raw::c_ushort,
        ar_coeff_shift_minus6: ::std::os::raw::c_ushort,
        grain_scale_shift: ::std::os::raw::c_ushort,
        clip_to_restricted_range: ::std::os::raw::c_ushort,
        reserved6_4bits: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let apply_grain: u16 = unsafe { ::std::mem::transmute(apply_grain) };
            apply_grain as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let overlap_flag: u16 = unsafe { ::std::mem::transmute(overlap_flag) };
            overlap_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let scaling_shift_minus8: u16 = unsafe { ::std::mem::transmute(scaling_shift_minus8) };
            scaling_shift_minus8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let chroma_scaling_from_luma: u16 =
                unsafe { ::std::mem::transmute(chroma_scaling_from_luma) };
            chroma_scaling_from_luma as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ar_coeff_lag: u16 = unsafe { ::std::mem::transmute(ar_coeff_lag) };
            ar_coeff_lag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let ar_coeff_shift_minus6: u16 =
                unsafe { ::std::mem::transmute(ar_coeff_shift_minus6) };
            ar_coeff_shift_minus6 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let grain_scale_shift: u16 = unsafe { ::std::mem::transmute(grain_scale_shift) };
            grain_scale_shift as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let clip_to_restricted_range: u16 =
                unsafe { ::std::mem::transmute(clip_to_restricted_range) };
            clip_to_restricted_range as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved6_4bits: u16 = unsafe { ::std::mem::transmute(reserved6_4bits) };
            reserved6_4bits as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type CUVIDAV1PICPARAMS = _CUVIDAV1PICPARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CUVIDPICPARAMS {
    pub PicWidthInMbs: ::std::os::raw::c_int,
    pub FrameHeightInMbs: ::std::os::raw::c_int,
    pub CurrPicIdx: ::std::os::raw::c_int,
    pub field_pic_flag: ::std::os::raw::c_int,
    pub bottom_field_flag: ::std::os::raw::c_int,
    pub second_field: ::std::os::raw::c_int,
    pub nBitstreamDataLen: ::std::os::raw::c_uint,
    pub pBitstreamData: *const ::std::os::raw::c_uchar,
    pub nNumSlices: ::std::os::raw::c_uint,
    pub pSliceDataOffsets: *const ::std::os::raw::c_uint,
    pub ref_pic_flag: ::std::os::raw::c_int,
    pub intra_pic_flag: ::std::os::raw::c_int,
    pub Reserved: [::std::os::raw::c_uint; 30usize],
    pub CodecSpecific: _CUVIDPICPARAMS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDPICPARAMS__bindgen_ty_1 {
    pub mpeg2: CUVIDMPEG2PICPARAMS,
    pub h264: CUVIDH264PICPARAMS,
    pub vc1: CUVIDVC1PICPARAMS,
    pub mpeg4: CUVIDMPEG4PICPARAMS,
    pub jpeg: CUVIDJPEGPICPARAMS,
    pub hevc: CUVIDHEVCPICPARAMS,
    pub vp8: CUVIDVP8PICPARAMS,
    pub vp9: CUVIDVP9PICPARAMS,
    pub av1: CUVIDAV1PICPARAMS,
    pub CodecReserved: [::std::os::raw::c_uint; 1024usize],
}
impl Default for _CUVIDPICPARAMS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CUVIDPICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDPICPARAMS = _CUVIDPICPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDPROCPARAMS {
    pub progressive_frame: ::std::os::raw::c_int,
    pub second_field: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub unpaired_field: ::std::os::raw::c_int,
    pub reserved_flags: ::std::os::raw::c_uint,
    pub reserved_zero: ::std::os::raw::c_uint,
    pub raw_input_dptr: ::std::os::raw::c_ulonglong,
    pub raw_input_pitch: ::std::os::raw::c_uint,
    pub raw_input_format: ::std::os::raw::c_uint,
    pub raw_output_dptr: ::std::os::raw::c_ulonglong,
    pub raw_output_pitch: ::std::os::raw::c_uint,
    pub Reserved1: ::std::os::raw::c_uint,
    pub output_stream: CUstream,
    pub Reserved: [::std::os::raw::c_uint; 46usize],
    pub histogram_dptr: *mut ::std::os::raw::c_ulonglong,
    pub Reserved2: [*mut ::std::os::raw::c_void; 1usize],
}
impl Default for _CUVIDPROCPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDPROCPARAMS = _CUVIDPROCPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDGETDECODESTATUS {
    pub decodeStatus: cuvidDecodeStatus,
    pub reserved: [::std::os::raw::c_uint; 31usize],
    pub pReserved: [*mut ::std::os::raw::c_void; 8usize],
}
impl Default for _CUVIDGETDECODESTATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDGETDECODESTATUS = _CUVIDGETDECODESTATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDRECONFIGUREDECODERINFO {
    pub ulWidth: ::std::os::raw::c_uint,
    pub ulHeight: ::std::os::raw::c_uint,
    pub ulTargetWidth: ::std::os::raw::c_uint,
    pub ulTargetHeight: ::std::os::raw::c_uint,
    pub ulNumDecodeSurfaces: ::std::os::raw::c_uint,
    pub reserved1: [::std::os::raw::c_uint; 12usize],
    pub display_area: _CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1,
    pub target_rect: _CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2,
    pub reserved2: [::std::os::raw::c_uint; 11usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1 {
    pub left: ::std::os::raw::c_short,
    pub top: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2 {
    pub left: ::std::os::raw::c_short,
    pub top: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
}
pub type CUVIDRECONFIGUREDECODERINFO = _CUVIDRECONFIGUREDECODERINFO;
pub type tcuvidGetDecoderCaps =
    ::std::option::Option<unsafe extern "C" fn(pdc: *mut CUVIDDECODECAPS) -> CUresult>;
pub type tcuvidCreateDecoder = ::std::option::Option<
    unsafe extern "C" fn(
        phDecoder: *mut CUvideodecoder,
        pdci: *mut CUVIDDECODECREATEINFO,
    ) -> CUresult,
>;
pub type tcuvidDestroyDecoder =
    ::std::option::Option<unsafe extern "C" fn(hDecoder: CUvideodecoder) -> CUresult>;
pub type tcuvidDecodePicture = ::std::option::Option<
    unsafe extern "C" fn(hDecoder: CUvideodecoder, pPicParams: *mut CUVIDPICPARAMS) -> CUresult,
>;
pub type tcuvidGetDecodeStatus = ::std::option::Option<
    unsafe extern "C" fn(
        hDecoder: CUvideodecoder,
        nPicIdx: ::std::os::raw::c_int,
        pDecodeStatus: *mut CUVIDGETDECODESTATUS,
    ) -> CUresult,
>;
pub type tcuvidReconfigureDecoder = ::std::option::Option<
    unsafe extern "C" fn(
        hDecoder: CUvideodecoder,
        pDecReconfigParams: *mut CUVIDRECONFIGUREDECODERINFO,
    ) -> CUresult,
>;
pub type tcuvidMapVideoFrame64 = ::std::option::Option<
    unsafe extern "C" fn(
        hDecoder: CUvideodecoder,
        nPicIdx: ::std::os::raw::c_int,
        pDevPtr: *mut ::std::os::raw::c_ulonglong,
        pPitch: *mut ::std::os::raw::c_uint,
        pVPP: *mut CUVIDPROCPARAMS,
    ) -> CUresult,
>;
pub type tcuvidUnmapVideoFrame64 = ::std::option::Option<
    unsafe extern "C" fn(hDecoder: CUvideodecoder, DevPtr: ::std::os::raw::c_ulonglong) -> CUresult,
>;
pub type tcuvidCtxLockCreate = ::std::option::Option<
    unsafe extern "C" fn(pLock: *mut CUvideoctxlock, ctx: CUcontext) -> CUresult,
>;
pub type tcuvidCtxLockDestroy =
    ::std::option::Option<unsafe extern "C" fn(lck: CUvideoctxlock) -> CUresult>;
pub type tcuvidCtxLock = ::std::option::Option<
    unsafe extern "C" fn(lck: CUvideoctxlock, reserved_flags: ::std::os::raw::c_uint) -> CUresult,
>;
pub type tcuvidCtxUnlock = ::std::option::Option<
    unsafe extern "C" fn(lck: CUvideoctxlock, reserved_flags: ::std::os::raw::c_uint) -> CUresult,
>;
pub type CUvideosource = *mut ::std::os::raw::c_void;
pub type CUvideoparser = *mut ::std::os::raw::c_void;
pub type CUvideotimestamp = ::std::os::raw::c_longlong;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoState {
    cudaVideoState_Error = -1,
    cudaVideoState_Stopped = 0,
    cudaVideoState_Started = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaAudioCodec {
    cudaAudioCodec_MPEG1 = 0,
    cudaAudioCodec_MPEG2 = 1,
    cudaAudioCodec_MP3 = 2,
    cudaAudioCodec_AC3 = 3,
    cudaAudioCodec_LPCM = 4,
    cudaAudioCodec_AAC = 5,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _TIMECODESET {
    pub time_offset_value: ::std::os::raw::c_uint,
    pub n_frames: ::std::os::raw::c_ushort,
    pub clock_timestamp_flag: ::std::os::raw::c_uchar,
    pub units_field_based_flag: ::std::os::raw::c_uchar,
    pub counting_type: ::std::os::raw::c_uchar,
    pub full_timestamp_flag: ::std::os::raw::c_uchar,
    pub discontinuity_flag: ::std::os::raw::c_uchar,
    pub cnt_dropped_flag: ::std::os::raw::c_uchar,
    pub seconds_value: ::std::os::raw::c_uchar,
    pub minutes_value: ::std::os::raw::c_uchar,
    pub hours_value: ::std::os::raw::c_uchar,
    pub seconds_flag: ::std::os::raw::c_uchar,
    pub minutes_flag: ::std::os::raw::c_uchar,
    pub hours_flag: ::std::os::raw::c_uchar,
    pub time_offset_length: ::std::os::raw::c_uchar,
    pub reserved: ::std::os::raw::c_uchar,
}
pub type TIMECODESET = _TIMECODESET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _TIMECODE {
    pub time_code_set: [TIMECODESET; 3usize],
    pub num_clock_ts: ::std::os::raw::c_uchar,
}
pub type TIMECODE = _TIMECODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _SEIMASTERINGDISPLAYINFO {
    pub display_primaries_x: [::std::os::raw::c_ushort; 3usize],
    pub display_primaries_y: [::std::os::raw::c_ushort; 3usize],
    pub white_point_x: ::std::os::raw::c_ushort,
    pub white_point_y: ::std::os::raw::c_ushort,
    pub max_display_mastering_luminance: ::std::os::raw::c_uint,
    pub min_display_mastering_luminance: ::std::os::raw::c_uint,
}
pub type SEIMASTERINGDISPLAYINFO = _SEIMASTERINGDISPLAYINFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _SEICONTENTLIGHTLEVELINFO {
    pub max_content_light_level: ::std::os::raw::c_ushort,
    pub max_pic_average_light_level: ::std::os::raw::c_ushort,
    pub reserved: ::std::os::raw::c_uint,
}
pub type SEICONTENTLIGHTLEVELINFO = _SEICONTENTLIGHTLEVELINFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _TIMECODEMPEG2 {
    pub drop_frame_flag: ::std::os::raw::c_uchar,
    pub time_code_hours: ::std::os::raw::c_uchar,
    pub time_code_minutes: ::std::os::raw::c_uchar,
    pub marker_bit: ::std::os::raw::c_uchar,
    pub time_code_seconds: ::std::os::raw::c_uchar,
    pub time_code_pictures: ::std::os::raw::c_uchar,
}
pub type TIMECODEMPEG2 = _TIMECODEMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _SEIALTERNATIVETRANSFERCHARACTERISTICS {
    pub preferred_transfer_characteristics: ::std::os::raw::c_uchar,
}
pub type SEIALTERNATIVETRANSFERCHARACTERISTICS = _SEIALTERNATIVETRANSFERCHARACTERISTICS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUSEIMESSAGE {
    pub sei_message_type: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 3usize],
    pub sei_message_size: ::std::os::raw::c_uint,
}
pub type CUSEIMESSAGE = _CUSEIMESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMAT {
    pub codec: cudaVideoCodec,
    pub frame_rate: CUVIDEOFORMAT__bindgen_ty_1,
    pub progressive_sequence: ::std::os::raw::c_uchar,
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    pub min_num_decode_surfaces: ::std::os::raw::c_uchar,
    pub coded_width: ::std::os::raw::c_uint,
    pub coded_height: ::std::os::raw::c_uint,
    pub display_area: CUVIDEOFORMAT__bindgen_ty_2,
    pub chroma_format: cudaVideoChromaFormat,
    pub bitrate: ::std::os::raw::c_uint,
    pub display_aspect_ratio: CUVIDEOFORMAT__bindgen_ty_3,
    pub video_signal_description: CUVIDEOFORMAT__bindgen_ty_4,
    pub seqhdr_data_length: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_1 {
    pub numerator: ::std::os::raw::c_uint,
    pub denominator: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_2 {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_3 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub color_primaries: ::std::os::raw::c_uchar,
    pub transfer_characteristics: ::std::os::raw::c_uchar,
    pub matrix_coefficients: ::std::os::raw::c_uchar,
}
impl CUVIDEOFORMAT__bindgen_ty_4 {
    #[inline]
    pub fn video_format(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_video_format(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn video_format_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_video_format_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn video_full_range_flag(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_video_full_range_flag(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn video_full_range_flag_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_video_full_range_flag_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_zero_bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved_zero_bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_zero_bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_zero_bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        video_format: ::std::os::raw::c_uchar,
        video_full_range_flag: ::std::os::raw::c_uchar,
        reserved_zero_bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let video_format: u8 = unsafe { ::std::mem::transmute(video_format) };
            video_format as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let video_full_range_flag: u8 = unsafe { ::std::mem::transmute(video_full_range_flag) };
            video_full_range_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved_zero_bits: u8 = unsafe { ::std::mem::transmute(reserved_zero_bits) };
            reserved_zero_bits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for CUVIDEOFORMAT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUVIDOPERATINGPOINTINFO {
    pub codec: cudaVideoCodec,
    pub __bindgen_anon_1: CUVIDOPERATINGPOINTINFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUVIDOPERATINGPOINTINFO__bindgen_ty_1 {
    pub av1: CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1,
    pub CodecReserved: [::std::os::raw::c_uchar; 1024usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1 {
    pub operating_points_cnt: ::std::os::raw::c_uchar,
    pub reserved24_bits: [::std::os::raw::c_uchar; 3usize],
    pub operating_points_idc: [::std::os::raw::c_ushort; 32usize],
}
impl Default for CUVIDOPERATINGPOINTINFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUVIDOPERATINGPOINTINFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDSEIMESSAGEINFO {
    pub pSEIData: *mut ::std::os::raw::c_void,
    pub pSEIMessage: *mut CUSEIMESSAGE,
    pub sei_message_count: ::std::os::raw::c_uint,
    pub picIdx: ::std::os::raw::c_uint,
}
impl Default for _CUVIDSEIMESSAGEINFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDSEIMESSAGEINFO = _CUVIDSEIMESSAGEINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDAV1SEQHDR {
    pub max_width: ::std::os::raw::c_uint,
    pub max_height: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 1016usize],
}
impl Default for CUVIDAV1SEQHDR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUVIDEOFORMATEX {
    pub format: CUVIDEOFORMAT,
    pub __bindgen_anon_1: CUVIDEOFORMATEX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUVIDEOFORMATEX__bindgen_ty_1 {
    pub av1: CUVIDAV1SEQHDR,
    pub raw_seqhdr_data: [::std::os::raw::c_uchar; 1024usize],
}
impl Default for CUVIDEOFORMATEX__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUVIDEOFORMATEX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUAUDIOFORMAT {
    pub codec: cudaAudioCodec,
    pub channels: ::std::os::raw::c_uint,
    pub samplespersec: ::std::os::raw::c_uint,
    pub bitrate: ::std::os::raw::c_uint,
    pub reserved1: ::std::os::raw::c_uint,
    pub reserved2: ::std::os::raw::c_uint,
}
impl Default for CUAUDIOFORMAT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUvideopacketflags {
    CUVID_PKT_ENDOFSTREAM = 1,
    CUVID_PKT_TIMESTAMP = 2,
    CUVID_PKT_DISCONTINUITY = 4,
    CUVID_PKT_ENDOFPICTURE = 8,
    CUVID_PKT_NOTIFY_EOS = 16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDSOURCEDATAPACKET {
    pub flags: tcu_ulong,
    pub payload_size: tcu_ulong,
    pub payload: *const ::std::os::raw::c_uchar,
    pub timestamp: CUvideotimestamp,
}
impl Default for _CUVIDSOURCEDATAPACKET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDSOURCEDATAPACKET = _CUVIDSOURCEDATAPACKET;
pub type PFNVIDSOURCECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDSOURCEDATAPACKET,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDSOURCEPARAMS {
    pub ulClockRate: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub uReserved1: [::std::os::raw::c_uint; 6usize],
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnVideoDataHandler: PFNVIDSOURCECALLBACK,
    pub pfnAudioDataHandler: PFNVIDSOURCECALLBACK,
    pub pvReserved2: [*mut ::std::os::raw::c_void; 8usize],
}
impl Default for _CUVIDSOURCEPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CUVIDSOURCEPARAMS {
    #[inline]
    pub fn bAnnexb(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bAnnexb(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bAnnexb_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bAnnexb_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uReserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_uReserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uReserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uReserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bAnnexb: ::std::os::raw::c_uint,
        uReserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bAnnexb: u32 = unsafe { ::std::mem::transmute(bAnnexb) };
            bAnnexb as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let uReserved: u32 = unsafe { ::std::mem::transmute(uReserved) };
            uReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type CUVIDSOURCEPARAMS = _CUVIDSOURCEPARAMS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUvideosourceformat_flags {
    CUVID_FMT_EXTFORMATINFO = 256,
}
pub type tcuvidCreateVideoSource = ::std::option::Option<
    unsafe extern "C" fn(
        pObj: *mut CUvideosource,
        pszFileName: *const ::std::os::raw::c_char,
        pParams: *mut CUVIDSOURCEPARAMS,
    ) -> CUresult,
>;
pub type tcuvidCreateVideoSourceW = ::std::option::Option<
    unsafe extern "C" fn(
        pObj: *mut CUvideosource,
        pwszFileName: *const wchar_t,
        pParams: *mut CUVIDSOURCEPARAMS,
    ) -> CUresult,
>;
pub type tcuvidDestroyVideoSource =
    ::std::option::Option<unsafe extern "C" fn(obj: CUvideosource) -> CUresult>;
pub type tcuvidSetVideoSourceState = ::std::option::Option<
    unsafe extern "C" fn(obj: CUvideosource, state: cudaVideoState) -> CUresult,
>;
pub type tcuvidGetVideoSourceState =
    ::std::option::Option<unsafe extern "C" fn(obj: CUvideosource) -> cudaVideoState>;
pub type tcuvidGetSourceVideoFormat = ::std::option::Option<
    unsafe extern "C" fn(
        obj: CUvideosource,
        pvidfmt: *mut CUVIDEOFORMAT,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuvidGetSourceAudioFormat = ::std::option::Option<
    unsafe extern "C" fn(
        obj: CUvideosource,
        paudfmt: *mut CUAUDIOFORMAT,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDPARSERDISPINFO {
    pub picture_index: ::std::os::raw::c_int,
    pub progressive_frame: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub repeat_first_field: ::std::os::raw::c_int,
    pub timestamp: CUvideotimestamp,
}
pub type CUVIDPARSERDISPINFO = _CUVIDPARSERDISPINFO;
pub type PFNVIDSEQUENCECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDEOFORMAT,
    ) -> ::std::os::raw::c_int,
>;
pub type PFNVIDDECODECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDPICPARAMS,
    ) -> ::std::os::raw::c_int,
>;
pub type PFNVIDDISPLAYCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDPARSERDISPINFO,
    ) -> ::std::os::raw::c_int,
>;
pub type PFNVIDOPPOINTCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDOPERATINGPOINTINFO,
    ) -> ::std::os::raw::c_int,
>;
pub type PFNVIDSEIMSGCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDSEIMESSAGEINFO,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDPARSERPARAMS {
    pub CodecType: cudaVideoCodec,
    pub ulMaxNumDecodeSurfaces: ::std::os::raw::c_uint,
    pub ulClockRate: ::std::os::raw::c_uint,
    pub ulErrorThreshold: ::std::os::raw::c_uint,
    pub ulMaxDisplayDelay: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub uReserved1: [::std::os::raw::c_uint; 4usize],
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnSequenceCallback: PFNVIDSEQUENCECALLBACK,
    pub pfnDecodePicture: PFNVIDDECODECALLBACK,
    pub pfnDisplayPicture: PFNVIDDISPLAYCALLBACK,
    pub pfnGetOperatingPoint: PFNVIDOPPOINTCALLBACK,
    pub pfnGetSEIMsg: PFNVIDSEIMSGCALLBACK,
    pub pvReserved2: [*mut ::std::os::raw::c_void; 5usize],
    pub pExtVideoInfo: *mut CUVIDEOFORMATEX,
}
impl Default for _CUVIDPARSERPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CUVIDPARSERPARAMS {
    #[inline]
    pub fn bAnnexb(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bAnnexb(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bAnnexb_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bAnnexb_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bMemoryOptimize(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bMemoryOptimize(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bMemoryOptimize_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bMemoryOptimize_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uReserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_uReserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uReserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uReserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bAnnexb: ::std::os::raw::c_uint,
        bMemoryOptimize: ::std::os::raw::c_uint,
        uReserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bAnnexb: u32 = unsafe { ::std::mem::transmute(bAnnexb) };
            bAnnexb as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bMemoryOptimize: u32 = unsafe { ::std::mem::transmute(bMemoryOptimize) };
            bMemoryOptimize as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let uReserved: u32 = unsafe { ::std::mem::transmute(uReserved) };
            uReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type CUVIDPARSERPARAMS = _CUVIDPARSERPARAMS;
pub type tcuvidCreateVideoParser = ::std::option::Option<
    unsafe extern "C" fn(pObj: *mut CUvideoparser, pParams: *mut CUVIDPARSERPARAMS) -> CUresult,
>;
pub type tcuvidParseVideoData = ::std::option::Option<
    unsafe extern "C" fn(obj: CUvideoparser, pPacket: *mut CUVIDSOURCEDATAPACKET) -> CUresult,
>;
pub type tcuvidDestroyVideoParser =
    ::std::option::Option<unsafe extern "C" fn(obj: CUvideoparser) -> CUresult>;
