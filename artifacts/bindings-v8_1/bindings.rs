/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CUDA_VERSION: u32 = 7050;
pub const CU_CTX_SCHED_BLOCKING_SYNC: u32 = 4;
pub const CU_EGL_FRAME_MAX_PLANES: u32 = 3;
pub const CU_STREAM_DEFAULT: u32 = 0;
pub const CU_STREAM_NON_BLOCKING: u32 = 1;
pub const CU_EVENT_DEFAULT: u32 = 0;
pub const CU_EVENT_BLOCKING_SYNC: u32 = 1;
pub const CU_EVENT_DISABLE_TIMING: u32 = 2;
pub const CU_EVENT_WAIT_DEFAULT: u32 = 0;
pub const CU_EVENT_WAIT_EXTERNAL: u32 = 1;
pub const CU_TRSF_READ_AS_INTEGER: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const NVENCAPI_MAJOR_VERSION: u32 = 8;
pub const NVENCAPI_MINOR_VERSION: u32 = 1;
pub const NVENCAPI_VERSION: u32 = 16777224;
pub const NVENC_INFINITE_GOPLENGTH: u32 = 4294967295;
pub const NV_MAX_SEQ_HDR_LEN: u32 = 512;
pub const NVDECAPI_MAJOR_VERSION: u32 = 8;
pub const NVDECAPI_MINOR_VERSION: u32 = 1;
pub const NVDECAPI_VERSION: u32 = 16777224;
pub const I_VOP: u32 = 0;
pub const P_VOP: u32 = 1;
pub const B_VOP: u32 = 2;
pub const S_VOP: u32 = 3;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type CUdevice = ::std::os::raw::c_int;
pub type CUdeviceptr = ::std::os::raw::c_ulonglong;
pub type CUtexObject = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarray_st {
    _unused: [u8; 0],
}
pub type CUarray = *mut CUarray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type CUfunction = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmod_st {
    _unused: [u8; 0],
}
pub type CUmodule = *mut CUmod_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmipmappedArray_st {
    _unused: [u8; 0],
}
pub type CUmipmappedArray = *mut CUmipmappedArray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphicsResource_st {
    _unused: [u8; 0],
}
pub type CUgraphicsResource = *mut CUgraphicsResource_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextMemory_st {
    _unused: [u8; 0],
}
pub type CUexternalMemory = *mut CUextMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextSemaphore_st {
    _unused: [u8; 0],
}
pub type CUexternalSemaphore = *mut CUextSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUeglStreamConnection_st {
    _unused: [u8; 0],
}
pub type CUeglStreamConnection = *mut CUeglStreamConnection_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlinkState_st {
    _unused: [u8; 0],
}
pub type CUlinkState = *mut CUlinkState_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaError_enum {
    CUDA_SUCCESS = 0,
    CUDA_ERROR_NOT_READY = 600,
    CUDA_ERROR_LAUNCH_TIMEOUT = 702,
    CUDA_ERROR_UNKNOWN = 999,
}
pub use self::cudaError_enum as CUresult;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUdevice_attribute_enum {
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,
    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,
}
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUarray_format_enum {
    CU_AD_FORMAT_UNSIGNED_INT8 = 1,
    CU_AD_FORMAT_UNSIGNED_INT16 = 2,
    CU_AD_FORMAT_UNSIGNED_INT32 = 3,
    CU_AD_FORMAT_SIGNED_INT8 = 8,
    CU_AD_FORMAT_SIGNED_INT16 = 9,
    CU_AD_FORMAT_SIGNED_INT32 = 10,
    CU_AD_FORMAT_HALF = 16,
    CU_AD_FORMAT_FLOAT = 32,
}
pub use self::CUarray_format_enum as CUarray_format;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUmemorytype_enum {
    CU_MEMORYTYPE_HOST = 1,
    CU_MEMORYTYPE_DEVICE = 2,
    CU_MEMORYTYPE_ARRAY = 3,
}
pub use self::CUmemorytype_enum as CUmemorytype;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUlimit_enum {
    CU_LIMIT_STACK_SIZE = 0,
    CU_LIMIT_PRINTF_FIFO_SIZE = 1,
    CU_LIMIT_MALLOC_HEAP_SIZE = 2,
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = 3,
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 4,
}
pub use self::CUlimit_enum as CUlimit;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUresourcetype_enum {
    CU_RESOURCE_TYPE_ARRAY = 0,
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 1,
    CU_RESOURCE_TYPE_LINEAR = 2,
    CU_RESOURCE_TYPE_PITCH2D = 3,
}
pub use self::CUresourcetype_enum as CUresourcetype;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUaddress_mode_enum {
    CU_TR_ADDRESS_MODE_WRAP = 0,
    CU_TR_ADDRESS_MODE_CLAMP = 1,
    CU_TR_ADDRESS_MODE_MIRROR = 2,
    CU_TR_ADDRESS_MODE_BORDER = 3,
}
pub use self::CUaddress_mode_enum as CUaddress_mode;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUfilter_mode_enum {
    CU_TR_FILTER_MODE_POINT = 0,
    CU_TR_FILTER_MODE_LINEAR = 1,
}
pub use self::CUfilter_mode_enum as CUfilter_mode;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUgraphicsRegisterFlags_enum {
    CU_GRAPHICS_REGISTER_FLAGS_NONE = 0,
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = 1,
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = 2,
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4,
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8,
}
pub use self::CUgraphicsRegisterFlags_enum as CUgraphicsRegisterFlags;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUexternalMemoryHandleType_enum {
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = 1,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = 4,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = 5,
}
pub use self::CUexternalMemoryHandleType_enum as CUexternalMemoryHandleType;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUexternalSemaphoreHandleType_enum {
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = 1,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = 4,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = 9,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10,
}
pub use self::CUexternalSemaphoreHandleType_enum as CUexternalSemaphoreHandleType;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUjit_option_enum {
    CU_JIT_MAX_REGISTERS = 0,
    CU_JIT_THREADS_PER_BLOCK = 1,
    CU_JIT_WALL_TIME = 2,
    CU_JIT_INFO_LOG_BUFFER = 3,
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES = 4,
    CU_JIT_ERROR_LOG_BUFFER = 5,
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = 6,
    CU_JIT_OPTIMIZATION_LEVEL = 7,
    CU_JIT_TARGET_FROM_CUCONTEXT = 8,
    CU_JIT_TARGET = 9,
    CU_JIT_FALLBACK_STRATEGY = 10,
    CU_JIT_GENERATE_DEBUG_INFO = 11,
    CU_JIT_LOG_VERBOSE = 12,
    CU_JIT_GENERATE_LINE_INFO = 13,
    CU_JIT_CACHE_MODE = 14,
    CU_JIT_NEW_SM3X_OPT = 15,
    CU_JIT_FAST_COMPILE = 16,
    CU_JIT_GLOBAL_SYMBOL_NAMES = 17,
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES = 18,
    CU_JIT_GLOBAL_SYMBOL_COUNT = 19,
    CU_JIT_NUM_OPTIONS = 20,
}
pub use self::CUjit_option_enum as CUjit_option;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUjitInputType_enum {
    CU_JIT_INPUT_CUBIN = 0,
    CU_JIT_INPUT_PTX = 1,
    CU_JIT_INPUT_FATBINARY = 2,
    CU_JIT_INPUT_OBJECT = 3,
    CU_JIT_INPUT_LIBRARY = 4,
    CU_JIT_NUM_INPUT_TYPES = 5,
}
pub use self::CUjitInputType_enum as CUjitInputType;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUeglFrameType {
    CU_EGL_FRAME_TYPE_ARRAY = 0,
    CU_EGL_FRAME_TYPE_PITCH = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUeglColorFormat {
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR = 0,
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR = 1,
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR = 21,
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR = 23,
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR = 25,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUd3d11DeviceList_enum {
    CU_D3D11_DEVICE_LIST_ALL = 1,
    CU_D3D11_DEVICE_LIST_CURRENT_FRAME = 2,
    CU_D3D11_DEVICE_LIST_NEXT_FRAME = 3,
}
pub use self::CUd3d11DeviceList_enum as CUd3d11DeviceList;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
pub type CUuuid = CUuuid_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_MEMCPY2D_st {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub srcPitch: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub dstPitch: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
}
impl Default for CUDA_MEMCPY2D_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_MEMCPY2D = CUDA_MEMCPY2D_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st {
    pub resType: CUresourcetype,
    pub res: CUDA_RESOURCE_DESC_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub hArray: CUarray,
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    pub hMipmappedArray: CUmipmappedArray,
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: CUdeviceptr,
    pub format: CUarray_format,
    pub numChannels: ::std::os::raw::c_uint,
    pub sizeInBytes: usize,
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: CUdeviceptr,
    pub format: CUarray_format,
    pub numChannels: ::std::os::raw::c_uint,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUDA_RESOURCE_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_RESOURCE_DESC = CUDA_RESOURCE_DESC_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct CUDA_TEXTURE_DESC_st {
    pub addressMode: [CUaddress_mode; 3usize],
    pub filterMode: CUfilter_mode,
    pub flags: ::std::os::raw::c_uint,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: CUfilter_mode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
impl Default for CUDA_TEXTURE_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_TEXTURE_DESC = CUDA_TEXTURE_DESC_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_VIEW_DESC_st {
    _unused: [u8; 0],
}
pub type CUDA_RESOURCE_VIEW_DESC = CUDA_RESOURCE_VIEW_DESC_st;
pub type GLenum = ::std::os::raw::c_uint;
pub type GLuint = ::std::os::raw::c_uint;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUGLDeviceList_enum {
    CU_GL_DEVICE_LIST_ALL = 1,
    CU_GL_DEVICE_LIST_CURRENT_FRAME = 2,
    CU_GL_DEVICE_LIST_NEXT_FRAME = 3,
}
pub use self::CUGLDeviceList_enum as CUGLDeviceList;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    pub type_: CUexternalMemoryHandleType,
    pub handle: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    pub type_: CUexternalSemaphoreHandleType,
    pub handle: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st;
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_ARRAY_DESCRIPTOR_st {
    pub Width: usize,
    pub Height: usize,
    pub Format: CUarray_format,
    pub NumChannels: ::std::os::raw::c_uint,
}
impl Default for CUDA_ARRAY_DESCRIPTOR_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_ARRAY_DESCRIPTOR = CUDA_ARRAY_DESCRIPTOR_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_ARRAY3D_DESCRIPTOR_st {
    pub Width: usize,
    pub Height: usize,
    pub Depth: usize,
    pub Format: CUarray_format,
    pub NumChannels: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_uint,
}
impl Default for CUDA_ARRAY3D_DESCRIPTOR_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_ARRAY3D_DESCRIPTOR = CUDA_ARRAY3D_DESCRIPTOR_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub arrayDesc: CUDA_ARRAY3D_DESCRIPTOR,
    pub numLevels: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
impl Default for CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC = CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUeglFrame_st {
    pub frame: CUeglFrame_st__bindgen_ty_1,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
    pub pitch: ::std::os::raw::c_uint,
    pub planeCount: ::std::os::raw::c_uint,
    pub numChannels: ::std::os::raw::c_uint,
    pub frameType: CUeglFrameType,
    pub eglColorFormat: CUeglColorFormat,
    pub cuFormat: CUarray_format,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUeglFrame_st__bindgen_ty_1 {
    pub pArray: [CUarray; 3usize],
    pub pPitch: [*mut ::std::os::raw::c_void; 3usize],
}
impl Default for CUeglFrame_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CUeglFrame_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUeglFrame = CUeglFrame_st;
pub type CUstreamCallback = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        status: CUresult,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type tcuInit =
    ::std::option::Option<unsafe extern "C" fn(Flags: ::std::os::raw::c_uint) -> CUresult>;
pub type tcuDriverGetVersion = ::std::option::Option<
    unsafe extern "C" fn(driverVersion: *mut ::std::os::raw::c_int) -> CUresult,
>;
pub type tcuDeviceGetCount =
    ::std::option::Option<unsafe extern "C" fn(count: *mut ::std::os::raw::c_int) -> CUresult>;
pub type tcuDeviceGet = ::std::option::Option<
    unsafe extern "C" fn(device: *mut CUdevice, ordinal: ::std::os::raw::c_int) -> CUresult,
>;
pub type tcuDeviceGetAttribute = ::std::option::Option<
    unsafe extern "C" fn(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUdevice_attribute,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuDeviceGetName = ::std::option::Option<
    unsafe extern "C" fn(
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuDeviceGetUuid =
    ::std::option::Option<unsafe extern "C" fn(uuid: *mut CUuuid, dev: CUdevice) -> CUresult>;
pub type tcuDeviceGetUuid_v2 =
    ::std::option::Option<unsafe extern "C" fn(uuid: *mut CUuuid, dev: CUdevice) -> CUresult>;
pub type tcuDeviceGetLuid = ::std::option::Option<
    unsafe extern "C" fn(
        luid: *mut ::std::os::raw::c_char,
        deviceNodeMask: *mut ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuDeviceGetByPCIBusId = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut CUdevice, pciBusId: *const ::std::os::raw::c_char) -> CUresult,
>;
pub type tcuDeviceGetPCIBusId = ::std::option::Option<
    unsafe extern "C" fn(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuDeviceComputeCapability = ::std::option::Option<
    unsafe extern "C" fn(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuCtxCreate_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        pctx: *mut CUcontext,
        flags: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult,
>;
pub type tcuCtxGetCurrent =
    ::std::option::Option<unsafe extern "C" fn(pctx: *mut CUcontext) -> CUresult>;
pub type tcuCtxSetLimit =
    ::std::option::Option<unsafe extern "C" fn(limit: CUlimit, value: usize) -> CUresult>;
pub type tcuCtxPushCurrent_v2 =
    ::std::option::Option<unsafe extern "C" fn(pctx: CUcontext) -> CUresult>;
pub type tcuCtxPopCurrent_v2 =
    ::std::option::Option<unsafe extern "C" fn(pctx: *mut CUcontext) -> CUresult>;
pub type tcuCtxDestroy_v2 = ::std::option::Option<unsafe extern "C" fn(ctx: CUcontext) -> CUresult>;
pub type tcuMemAlloc_v2 = ::std::option::Option<
    unsafe extern "C" fn(dptr: *mut CUdeviceptr, bytesize: usize) -> CUresult,
>;
pub type tcuMemAllocPitch_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dptr: *mut CUdeviceptr,
        pPitch: *mut usize,
        WidthInBytes: usize,
        Height: usize,
        ElementSizeBytes: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuMemAllocManaged = ::std::option::Option<
    unsafe extern "C" fn(
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuMemsetD8Async = ::std::option::Option<
    unsafe extern "C" fn(
        dstDevice: CUdeviceptr,
        uc: ::std::os::raw::c_uchar,
        N: usize,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuMemFree_v2 = ::std::option::Option<unsafe extern "C" fn(dptr: CUdeviceptr) -> CUresult>;
pub type tcuMemcpy = ::std::option::Option<
    unsafe extern "C" fn(dst: CUdeviceptr, src: CUdeviceptr, bytesize: usize) -> CUresult,
>;
pub type tcuMemcpyAsync = ::std::option::Option<
    unsafe extern "C" fn(
        dst: CUdeviceptr,
        src: CUdeviceptr,
        bytesize: usize,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuMemcpy2D_v2 =
    ::std::option::Option<unsafe extern "C" fn(pcopy: *const CUDA_MEMCPY2D) -> CUresult>;
pub type tcuMemcpy2DAsync_v2 = ::std::option::Option<
    unsafe extern "C" fn(pcopy: *const CUDA_MEMCPY2D, hStream: CUstream) -> CUresult,
>;
pub type tcuMemcpyHtoD_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
    ) -> CUresult,
>;
pub type tcuMemcpyHtoDAsync_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuMemcpyDtoH_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult,
>;
pub type tcuMemcpyDtoHAsync_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuMemcpyDtoD_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult,
>;
pub type tcuMemcpyDtoDAsync_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuGetErrorName = ::std::option::Option<
    unsafe extern "C" fn(error: CUresult, pstr: *mut *const ::std::os::raw::c_char) -> CUresult,
>;
pub type tcuGetErrorString = ::std::option::Option<
    unsafe extern "C" fn(error: CUresult, pstr: *mut *const ::std::os::raw::c_char) -> CUresult,
>;
pub type tcuCtxGetDevice =
    ::std::option::Option<unsafe extern "C" fn(device: *mut CUdevice) -> CUresult>;
pub type tcuDevicePrimaryCtxRetain =
    ::std::option::Option<unsafe extern "C" fn(pctx: *mut CUcontext, dev: CUdevice) -> CUresult>;
pub type tcuDevicePrimaryCtxRelease =
    ::std::option::Option<unsafe extern "C" fn(dev: CUdevice) -> CUresult>;
pub type tcuDevicePrimaryCtxSetFlags = ::std::option::Option<
    unsafe extern "C" fn(dev: CUdevice, flags: ::std::os::raw::c_uint) -> CUresult,
>;
pub type tcuDevicePrimaryCtxGetState = ::std::option::Option<
    unsafe extern "C" fn(
        dev: CUdevice,
        flags: *mut ::std::os::raw::c_uint,
        active: *mut ::std::os::raw::c_int,
    ) -> CUresult,
>;
pub type tcuDevicePrimaryCtxReset =
    ::std::option::Option<unsafe extern "C" fn(dev: CUdevice) -> CUresult>;
pub type tcuStreamCreate = ::std::option::Option<
    unsafe extern "C" fn(phStream: *mut CUstream, flags: ::std::os::raw::c_uint) -> CUresult,
>;
pub type tcuStreamQuery =
    ::std::option::Option<unsafe extern "C" fn(hStream: CUstream) -> CUresult>;
pub type tcuStreamSynchronize =
    ::std::option::Option<unsafe extern "C" fn(hStream: CUstream) -> CUresult>;
pub type tcuStreamDestroy_v2 =
    ::std::option::Option<unsafe extern "C" fn(hStream: CUstream) -> CUresult>;
pub type tcuStreamAddCallback = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        callback: CUstreamCallback,
        userdata: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuStreamWaitEvent = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        hEvent: CUevent,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuEventCreate = ::std::option::Option<
    unsafe extern "C" fn(phEvent: *mut CUevent, flags: ::std::os::raw::c_uint) -> CUresult,
>;
pub type tcuEventDestroy_v2 =
    ::std::option::Option<unsafe extern "C" fn(hEvent: CUevent) -> CUresult>;
pub type tcuEventSynchronize =
    ::std::option::Option<unsafe extern "C" fn(hEvent: CUevent) -> CUresult>;
pub type tcuEventQuery = ::std::option::Option<unsafe extern "C" fn(hEvent: CUevent) -> CUresult>;
pub type tcuEventRecord =
    ::std::option::Option<unsafe extern "C" fn(hEvent: CUevent, hStream: CUstream) -> CUresult>;
pub type tcuLaunchKernel = ::std::option::Option<
    unsafe extern "C" fn(
        f: CUfunction,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult,
>;
pub type tcuLinkCreate = ::std::option::Option<
    unsafe extern "C" fn(
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
        stateOut: *mut CUlinkState,
    ) -> CUresult,
>;
pub type tcuLinkAddData = ::std::option::Option<
    unsafe extern "C" fn(
        state: CUlinkState,
        type_: CUjitInputType,
        data: *mut ::std::os::raw::c_void,
        size: usize,
        name: *const ::std::os::raw::c_char,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult,
>;
pub type tcuLinkComplete = ::std::option::Option<
    unsafe extern "C" fn(
        state: CUlinkState,
        cubinOut: *mut *mut ::std::os::raw::c_void,
        sizeOut: *mut usize,
    ) -> CUresult,
>;
pub type tcuLinkDestroy =
    ::std::option::Option<unsafe extern "C" fn(state: CUlinkState) -> CUresult>;
pub type tcuModuleLoadData = ::std::option::Option<
    unsafe extern "C" fn(module: *mut CUmodule, image: *const ::std::os::raw::c_void) -> CUresult,
>;
pub type tcuModuleUnload = ::std::option::Option<unsafe extern "C" fn(hmod: CUmodule) -> CUresult>;
pub type tcuModuleGetFunction = ::std::option::Option<
    unsafe extern "C" fn(
        hfunc: *mut CUfunction,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult,
>;
pub type tcuModuleGetGlobal = ::std::option::Option<
    unsafe extern "C" fn(
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult,
>;
pub type tcuTexObjectCreate = ::std::option::Option<
    unsafe extern "C" fn(
        pTexObject: *mut CUtexObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
        pTexDesc: *const CUDA_TEXTURE_DESC,
        pResViewDesc: *const CUDA_RESOURCE_VIEW_DESC,
    ) -> CUresult,
>;
pub type tcuTexObjectDestroy =
    ::std::option::Option<unsafe extern "C" fn(texObject: CUtexObject) -> CUresult>;
pub type tcuGLGetDevices_v2 = ::std::option::Option<
    unsafe extern "C" fn(
        pCudaDeviceCount: *mut ::std::os::raw::c_uint,
        pCudaDevices: *mut CUdevice,
        cudaDeviceCount: ::std::os::raw::c_uint,
        deviceList: CUGLDeviceList,
    ) -> CUresult,
>;
pub type tcuGraphicsGLRegisterImage = ::std::option::Option<
    unsafe extern "C" fn(
        pCudaResource: *mut CUgraphicsResource,
        image: GLuint,
        target: GLenum,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuGraphicsUnregisterResource =
    ::std::option::Option<unsafe extern "C" fn(resource: CUgraphicsResource) -> CUresult>;
pub type tcuGraphicsMapResources = ::std::option::Option<
    unsafe extern "C" fn(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuGraphicsUnmapResources = ::std::option::Option<
    unsafe extern "C" fn(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult,
>;
pub type tcuGraphicsSubResourceGetMappedArray = ::std::option::Option<
    unsafe extern "C" fn(
        pArray: *mut CUarray,
        resource: CUgraphicsResource,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuGraphicsResourceGetMappedPointer = ::std::option::Option<
    unsafe extern "C" fn(
        devPtrOut: *mut CUdeviceptr,
        sizeOut: *mut usize,
        resource: CUgraphicsResource,
    ) -> CUresult,
>;
pub type tcuImportExternalMemory = ::std::option::Option<
    unsafe extern "C" fn(
        extMem_out: *mut CUexternalMemory,
        memHandleDesc: *const CUDA_EXTERNAL_MEMORY_HANDLE_DESC,
    ) -> CUresult,
>;
pub type tcuDestroyExternalMemory =
    ::std::option::Option<unsafe extern "C" fn(extMem: CUexternalMemory) -> CUresult>;
pub type tcuExternalMemoryGetMappedBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        devPtr: *mut CUdeviceptr,
        extMem: CUexternalMemory,
        bufferDesc: *const CUDA_EXTERNAL_MEMORY_BUFFER_DESC,
    ) -> CUresult,
>;
pub type tcuExternalMemoryGetMappedMipmappedArray = ::std::option::Option<
    unsafe extern "C" fn(
        mipmap: *mut CUmipmappedArray,
        extMem: CUexternalMemory,
        mipmapDesc: *const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC,
    ) -> CUresult,
>;
pub type tcuMipmappedArrayGetLevel = ::std::option::Option<
    unsafe extern "C" fn(
        pLevelArray: *mut CUarray,
        hMipmappedArray: CUmipmappedArray,
        level: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuMipmappedArrayDestroy =
    ::std::option::Option<unsafe extern "C" fn(hMipmappedArray: CUmipmappedArray) -> CUresult>;
pub type tcuImportExternalSemaphore = ::std::option::Option<
    unsafe extern "C" fn(
        extSem_out: *mut CUexternalSemaphore,
        semHandleDesc: *const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC,
    ) -> CUresult,
>;
pub type tcuDestroyExternalSemaphore =
    ::std::option::Option<unsafe extern "C" fn(extSem: CUexternalSemaphore) -> CUresult>;
pub type tcuSignalExternalSemaphoresAsync = ::std::option::Option<
    unsafe extern "C" fn(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult,
>;
pub type tcuWaitExternalSemaphoresAsync = ::std::option::Option<
    unsafe extern "C" fn(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult,
>;
pub type tcuArrayCreate = ::std::option::Option<
    unsafe extern "C" fn(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY_DESCRIPTOR,
    ) -> CUresult,
>;
pub type tcuArray3DCreate = ::std::option::Option<
    unsafe extern "C" fn(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY3D_DESCRIPTOR,
    ) -> CUresult,
>;
pub type tcuArrayDestroy = ::std::option::Option<unsafe extern "C" fn(hArray: CUarray) -> CUresult>;
pub type tcuEGLStreamProducerConnect = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut CUeglStreamConnection,
        stream: ffnv_EGLStreamKHR,
        width: ffnv_EGLint,
        height: ffnv_EGLint,
    ) -> CUresult,
>;
pub type tcuEGLStreamProducerDisconnect =
    ::std::option::Option<unsafe extern "C" fn(conn: *mut CUeglStreamConnection) -> CUresult>;
pub type tcuEGLStreamConsumerDisconnect =
    ::std::option::Option<unsafe extern "C" fn(conn: *mut CUeglStreamConnection) -> CUresult>;
pub type tcuEGLStreamProducerPresentFrame = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut CUeglStreamConnection,
        eglframe: CUeglFrame,
        pStream: *mut CUstream,
    ) -> CUresult,
>;
pub type tcuEGLStreamProducerReturnFrame = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut CUeglStreamConnection,
        eglframe: *mut CUeglFrame,
        pStream: *mut CUstream,
    ) -> CUresult,
>;
pub type tcuD3D11GetDevice = ::std::option::Option<
    unsafe extern "C" fn(
        device: *mut CUdevice,
        dxgiAdapter: *mut ::std::os::raw::c_void,
    ) -> CUresult,
>;
pub type tcuD3D11GetDevices = ::std::option::Option<
    unsafe extern "C" fn(
        deviceCountOut: *mut ::std::os::raw::c_uint,
        devices: *mut CUdevice,
        deviceCount: ::std::os::raw::c_uint,
        d3d11device: *mut ::std::os::raw::c_void,
        listType: CUd3d11DeviceList,
    ) -> CUresult,
>;
pub type tcuGraphicsD3D11RegisterResource = ::std::option::Option<
    unsafe extern "C" fn(
        cudaResourceOut: *mut CUgraphicsResource,
        d3d11Resource: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GUID {
    pub Data1: u32,
    pub Data2: u16,
    pub Data3: u16,
    pub Data4: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVENC_RECT {
    pub left: u32,
    pub top: u32,
    pub right: u32,
    pub bottom: u32,
}
pub type NVENC_RECT = _NVENC_RECT;
pub type NV_ENC_INPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_OUTPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_REGISTERED_PTR = *mut ::std::os::raw::c_void;
unsafe extern "C" {
    pub static NV_ENC_CODEC_H264_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_CODEC_HEVC_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_BASELINE_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_MAIN_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_HIGH_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_HIGH_444_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_STEREO_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_SVC_TEMPORAL_SCALABILTY: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_HEVC_PROFILE_MAIN_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_HEVC_PROFILE_MAIN10_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_HEVC_PROFILE_FREXT_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_DEFAULT_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_HP_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_HQ_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_BD_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_LOW_LATENCY_HQ_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_LOW_LATENCY_HP_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_LOSSLESS_DEFAULT_GUID: GUID;
}
unsafe extern "C" {
    pub static NV_ENC_PRESET_LOSSLESS_HP_GUID: GUID;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_PARAMS_FRAME_FIELD_MODE {
    NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME = 1,
    NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD = 2,
    NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF = 3,
}
pub use self::_NV_ENC_PARAMS_FRAME_FIELD_MODE as NV_ENC_PARAMS_FRAME_FIELD_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_PARAMS_RC_MODE {
    NV_ENC_PARAMS_RC_CONSTQP = 0,
    NV_ENC_PARAMS_RC_VBR = 1,
    NV_ENC_PARAMS_RC_CBR = 2,
    NV_ENC_PARAMS_RC_CBR_LOWDELAY_HQ = 8,
    NV_ENC_PARAMS_RC_CBR_HQ = 16,
    NV_ENC_PARAMS_RC_VBR_HQ = 32,
}
pub use self::_NV_ENC_PARAMS_RC_MODE as NV_ENC_PARAMS_RC_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_EMPHASIS_MAP_LEVEL {
    NV_ENC_EMPHASIS_MAP_LEVEL_0 = 0,
    NV_ENC_EMPHASIS_MAP_LEVEL_1 = 1,
    NV_ENC_EMPHASIS_MAP_LEVEL_2 = 2,
    NV_ENC_EMPHASIS_MAP_LEVEL_3 = 3,
    NV_ENC_EMPHASIS_MAP_LEVEL_4 = 4,
    NV_ENC_EMPHASIS_MAP_LEVEL_5 = 5,
}
pub use self::_NV_ENC_EMPHASIS_MAP_LEVEL as NV_ENC_EMPHASIS_MAP_LEVEL;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_QP_MAP_MODE {
    NV_ENC_QP_MAP_DISABLED = 0,
    NV_ENC_QP_MAP_EMPHASIS = 1,
    NV_ENC_QP_MAP_DELTA = 2,
    NV_ENC_QP_MAP = 3,
}
pub use self::_NV_ENC_QP_MAP_MODE as NV_ENC_QP_MAP_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_PIC_STRUCT {
    NV_ENC_PIC_STRUCT_FRAME = 1,
    NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM = 2,
    NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP = 3,
}
pub use self::_NV_ENC_PIC_STRUCT as NV_ENC_PIC_STRUCT;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_PIC_TYPE {
    NV_ENC_PIC_TYPE_P = 0,
    NV_ENC_PIC_TYPE_B = 1,
    NV_ENC_PIC_TYPE_I = 2,
    NV_ENC_PIC_TYPE_IDR = 3,
    NV_ENC_PIC_TYPE_BI = 4,
    NV_ENC_PIC_TYPE_SKIPPED = 5,
    NV_ENC_PIC_TYPE_INTRA_REFRESH = 6,
    NV_ENC_PIC_TYPE_UNKNOWN = 255,
}
pub use self::_NV_ENC_PIC_TYPE as NV_ENC_PIC_TYPE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_MV_PRECISION {
    NV_ENC_MV_PRECISION_DEFAULT = 0,
    NV_ENC_MV_PRECISION_FULL_PEL = 1,
    NV_ENC_MV_PRECISION_HALF_PEL = 2,
    NV_ENC_MV_PRECISION_QUARTER_PEL = 3,
}
pub use self::_NV_ENC_MV_PRECISION as NV_ENC_MV_PRECISION;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_BUFFER_FORMAT {
    NV_ENC_BUFFER_FORMAT_UNDEFINED = 0,
    NV_ENC_BUFFER_FORMAT_NV12 = 1,
    NV_ENC_BUFFER_FORMAT_YV12 = 16,
    NV_ENC_BUFFER_FORMAT_IYUV = 256,
    NV_ENC_BUFFER_FORMAT_YUV444 = 4096,
    NV_ENC_BUFFER_FORMAT_YUV420_10BIT = 65536,
    NV_ENC_BUFFER_FORMAT_YUV444_10BIT = 1048576,
    NV_ENC_BUFFER_FORMAT_ARGB = 16777216,
    NV_ENC_BUFFER_FORMAT_ARGB10 = 33554432,
    NV_ENC_BUFFER_FORMAT_AYUV = 67108864,
    NV_ENC_BUFFER_FORMAT_ABGR = 268435456,
    NV_ENC_BUFFER_FORMAT_ABGR10 = 536870912,
}
pub use self::_NV_ENC_BUFFER_FORMAT as NV_ENC_BUFFER_FORMAT;
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_HEVC_1: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_3;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_HEVC_MAIN: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_LEVEL {
    NV_ENC_LEVEL_AUTOSELECT = 0,
    NV_ENC_LEVEL_H264_1 = 10,
    NV_ENC_LEVEL_H264_1b = 9,
    NV_ENC_LEVEL_H264_11 = 11,
    NV_ENC_LEVEL_H264_12 = 12,
    NV_ENC_LEVEL_H264_13 = 13,
    NV_ENC_LEVEL_H264_2 = 20,
    NV_ENC_LEVEL_H264_21 = 21,
    NV_ENC_LEVEL_H264_22 = 22,
    NV_ENC_LEVEL_H264_3 = 30,
    NV_ENC_LEVEL_H264_31 = 31,
    NV_ENC_LEVEL_H264_32 = 32,
    NV_ENC_LEVEL_H264_4 = 40,
    NV_ENC_LEVEL_H264_41 = 41,
    NV_ENC_LEVEL_H264_42 = 42,
    NV_ENC_LEVEL_H264_5 = 50,
    NV_ENC_LEVEL_H264_51 = 51,
    NV_ENC_LEVEL_H264_52 = 52,
    NV_ENC_LEVEL_HEVC_2 = 60,
    NV_ENC_LEVEL_HEVC_21 = 63,
    NV_ENC_LEVEL_HEVC_3 = 90,
    NV_ENC_LEVEL_HEVC_31 = 93,
    NV_ENC_LEVEL_HEVC_4 = 120,
    NV_ENC_LEVEL_HEVC_41 = 123,
    NV_ENC_LEVEL_HEVC_5 = 150,
    NV_ENC_LEVEL_HEVC_51 = 153,
    NV_ENC_LEVEL_HEVC_52 = 156,
    NV_ENC_LEVEL_HEVC_6 = 180,
    NV_ENC_LEVEL_HEVC_61 = 183,
    NV_ENC_LEVEL_HEVC_62 = 186,
    NV_ENC_TIER_HEVC_HIGH = 1,
}
pub use self::_NV_ENC_LEVEL as NV_ENC_LEVEL;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NVENCSTATUS {
    NV_ENC_SUCCESS = 0,
    NV_ENC_ERR_NO_ENCODE_DEVICE = 1,
    NV_ENC_ERR_UNSUPPORTED_DEVICE = 2,
    NV_ENC_ERR_INVALID_ENCODERDEVICE = 3,
    NV_ENC_ERR_INVALID_DEVICE = 4,
    NV_ENC_ERR_DEVICE_NOT_EXIST = 5,
    NV_ENC_ERR_INVALID_PTR = 6,
    NV_ENC_ERR_INVALID_EVENT = 7,
    NV_ENC_ERR_INVALID_PARAM = 8,
    NV_ENC_ERR_INVALID_CALL = 9,
    NV_ENC_ERR_OUT_OF_MEMORY = 10,
    NV_ENC_ERR_ENCODER_NOT_INITIALIZED = 11,
    NV_ENC_ERR_UNSUPPORTED_PARAM = 12,
    NV_ENC_ERR_LOCK_BUSY = 13,
    NV_ENC_ERR_NOT_ENOUGH_BUFFER = 14,
    NV_ENC_ERR_INVALID_VERSION = 15,
    NV_ENC_ERR_MAP_FAILED = 16,
    NV_ENC_ERR_NEED_MORE_INPUT = 17,
    NV_ENC_ERR_ENCODER_BUSY = 18,
    NV_ENC_ERR_EVENT_NOT_REGISTERD = 19,
    NV_ENC_ERR_GENERIC = 20,
    NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY = 21,
    NV_ENC_ERR_UNIMPLEMENTED = 22,
    NV_ENC_ERR_RESOURCE_REGISTER_FAILED = 23,
    NV_ENC_ERR_RESOURCE_NOT_REGISTERED = 24,
    NV_ENC_ERR_RESOURCE_NOT_MAPPED = 25,
}
pub use self::_NVENCSTATUS as NVENCSTATUS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_PIC_FLAGS {
    NV_ENC_PIC_FLAG_FORCEINTRA = 1,
    NV_ENC_PIC_FLAG_FORCEIDR = 2,
    NV_ENC_PIC_FLAG_OUTPUT_SPSPPS = 4,
    NV_ENC_PIC_FLAG_EOS = 8,
}
pub use self::_NV_ENC_PIC_FLAGS as NV_ENC_PIC_FLAGS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_MEMORY_HEAP {
    NV_ENC_MEMORY_HEAP_AUTOSELECT = 0,
    NV_ENC_MEMORY_HEAP_VID = 1,
    NV_ENC_MEMORY_HEAP_SYSMEM_CACHED = 2,
    NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED = 3,
}
pub use self::_NV_ENC_MEMORY_HEAP as NV_ENC_MEMORY_HEAP;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_BFRAME_REF_MODE {
    NV_ENC_BFRAME_REF_MODE_DISABLED = 0,
    NV_ENC_BFRAME_REF_MODE_EACH = 1,
    NV_ENC_BFRAME_REF_MODE_MIDDLE = 2,
}
pub use self::_NV_ENC_BFRAME_REF_MODE as NV_ENC_BFRAME_REF_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_H264_ENTROPY_CODING_MODE {
    NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT = 0,
    NV_ENC_H264_ENTROPY_CODING_MODE_CABAC = 1,
    NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC = 2,
}
pub use self::_NV_ENC_H264_ENTROPY_CODING_MODE as NV_ENC_H264_ENTROPY_CODING_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_H264_BDIRECT_MODE {
    NV_ENC_H264_BDIRECT_MODE_AUTOSELECT = 0,
    NV_ENC_H264_BDIRECT_MODE_DISABLE = 1,
    NV_ENC_H264_BDIRECT_MODE_TEMPORAL = 2,
    NV_ENC_H264_BDIRECT_MODE_SPATIAL = 3,
}
pub use self::_NV_ENC_H264_BDIRECT_MODE as NV_ENC_H264_BDIRECT_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_H264_FMO_MODE {
    NV_ENC_H264_FMO_AUTOSELECT = 0,
    NV_ENC_H264_FMO_ENABLE = 1,
    NV_ENC_H264_FMO_DISABLE = 2,
}
pub use self::_NV_ENC_H264_FMO_MODE as NV_ENC_H264_FMO_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE {
    NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT = 0,
    NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE = 1,
    NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE = 2,
}
pub use self::_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE as NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_STEREO_PACKING_MODE {
    NV_ENC_STEREO_PACKING_MODE_NONE = 0,
    NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD = 1,
    NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE = 2,
    NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE = 3,
    NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE = 4,
    NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM = 5,
    NV_ENC_STEREO_PACKING_MODE_FRAMESEQ = 6,
}
pub use self::_NV_ENC_STEREO_PACKING_MODE as NV_ENC_STEREO_PACKING_MODE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_INPUT_RESOURCE_TYPE {
    NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX = 0,
    NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR = 1,
    NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY = 2,
    NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX = 3,
}
pub use self::_NV_ENC_INPUT_RESOURCE_TYPE as NV_ENC_INPUT_RESOURCE_TYPE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_DEVICE_TYPE {
    NV_ENC_DEVICE_TYPE_DIRECTX = 0,
    NV_ENC_DEVICE_TYPE_CUDA = 1,
    NV_ENC_DEVICE_TYPE_OPENGL = 2,
}
pub use self::_NV_ENC_DEVICE_TYPE as NV_ENC_DEVICE_TYPE;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_CAPS {
    NV_ENC_CAPS_NUM_MAX_BFRAMES = 0,
    NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES = 1,
    NV_ENC_CAPS_SUPPORT_FIELD_ENCODING = 2,
    NV_ENC_CAPS_SUPPORT_MONOCHROME = 3,
    NV_ENC_CAPS_SUPPORT_FMO = 4,
    NV_ENC_CAPS_SUPPORT_QPELMV = 5,
    NV_ENC_CAPS_SUPPORT_BDIRECT_MODE = 6,
    NV_ENC_CAPS_SUPPORT_CABAC = 7,
    NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM = 8,
    NV_ENC_CAPS_SUPPORT_RESERVED = 9,
    NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS = 10,
    NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES = 11,
    NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES = 12,
    NV_ENC_CAPS_LEVEL_MAX = 13,
    NV_ENC_CAPS_LEVEL_MIN = 14,
    NV_ENC_CAPS_SEPARATE_COLOUR_PLANE = 15,
    NV_ENC_CAPS_WIDTH_MAX = 16,
    NV_ENC_CAPS_HEIGHT_MAX = 17,
    NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC = 18,
    NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE = 19,
    NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE = 20,
    NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP = 21,
    NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE = 22,
    NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK = 23,
    NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING = 24,
    NV_ENC_CAPS_SUPPORT_INTRA_REFRESH = 25,
    NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE = 26,
    NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE = 27,
    NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION = 28,
    NV_ENC_CAPS_PREPROC_SUPPORT = 29,
    NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT = 30,
    NV_ENC_CAPS_MB_NUM_MAX = 31,
    NV_ENC_CAPS_MB_PER_SEC_MAX = 32,
    NV_ENC_CAPS_SUPPORT_YUV444_ENCODE = 33,
    NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE = 34,
    NV_ENC_CAPS_SUPPORT_SAO = 35,
    NV_ENC_CAPS_SUPPORT_MEONLY_MODE = 36,
    NV_ENC_CAPS_SUPPORT_LOOKAHEAD = 37,
    NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ = 38,
    NV_ENC_CAPS_SUPPORT_10BIT_ENCODE = 39,
    NV_ENC_CAPS_NUM_MAX_LTR_FRAMES = 40,
    NV_ENC_CAPS_SUPPORT_WEIGHTED_PREDICTION = 41,
    NV_ENC_CAPS_DYNAMIC_QUERY_ENCODER_CAPACITY = 42,
    NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE = 43,
    NV_ENC_CAPS_SUPPORT_EMPHASIS_LEVEL_MAP = 44,
    NV_ENC_CAPS_EXPOSED_COUNT = 45,
}
pub use self::_NV_ENC_CAPS as NV_ENC_CAPS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NV_ENC_HEVC_CUSIZE {
    NV_ENC_HEVC_CUSIZE_AUTOSELECT = 0,
    NV_ENC_HEVC_CUSIZE_8x8 = 1,
    NV_ENC_HEVC_CUSIZE_16x16 = 2,
    NV_ENC_HEVC_CUSIZE_32x32 = 3,
    NV_ENC_HEVC_CUSIZE_64x64 = 4,
}
pub use self::_NV_ENC_HEVC_CUSIZE as NV_ENC_HEVC_CUSIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CAPS_PARAM {
    pub version: u32,
    pub capsToQuery: NV_ENC_CAPS,
    pub reserved: [u32; 62usize],
}
impl Default for _NV_ENC_CAPS_PARAM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CAPS_PARAM = _NV_ENC_CAPS_PARAM;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_INPUT_BUFFER {
    pub version: u32,
    pub width: u32,
    pub height: u32,
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub reserved: u32,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub pSysMemBuffer: *mut ::std::os::raw::c_void,
    pub reserved1: [u32; 57usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
impl Default for _NV_ENC_CREATE_INPUT_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CREATE_INPUT_BUFFER = _NV_ENC_CREATE_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_BITSTREAM_BUFFER {
    pub version: u32,
    pub size: u32,
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    pub reserved: u32,
    pub bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    pub reserved1: [u32; 58usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CREATE_BITSTREAM_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CREATE_BITSTREAM_BUFFER = _NV_ENC_CREATE_BITSTREAM_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_MVECTOR {
    pub mvx: i16,
    pub mvy: i16,
}
pub type NV_ENC_MVECTOR = _NV_ENC_MVECTOR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_H264_MV_DATA {
    pub mv: [NV_ENC_MVECTOR; 4usize],
    pub mbType: u8,
    pub partitionType: u8,
    pub reserved: u16,
    pub mbCost: u32,
}
pub type NV_ENC_H264_MV_DATA = _NV_ENC_H264_MV_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_HEVC_MV_DATA {
    pub mv: [NV_ENC_MVECTOR; 4usize],
    pub cuType: u8,
    pub cuSize: u8,
    pub partitionMode: u8,
    pub lastCUInCTB: u8,
}
pub type NV_ENC_HEVC_MV_DATA = _NV_ENC_HEVC_MV_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_MV_BUFFER {
    pub version: u32,
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    pub reserved1: [u32; 255usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
impl Default for _NV_ENC_CREATE_MV_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CREATE_MV_BUFFER = _NV_ENC_CREATE_MV_BUFFER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_QP {
    pub qpInterP: u32,
    pub qpInterB: u32,
    pub qpIntra: u32,
}
pub type NV_ENC_QP = _NV_ENC_QP;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_RC_PARAMS {
    pub version: u32,
    pub rateControlMode: NV_ENC_PARAMS_RC_MODE,
    pub constQP: NV_ENC_QP,
    pub averageBitRate: u32,
    pub maxBitRate: u32,
    pub vbvBufferSize: u32,
    pub vbvInitialDelay: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub minQP: NV_ENC_QP,
    pub maxQP: NV_ENC_QP,
    pub initialRCQP: NV_ENC_QP,
    pub temporallayerIdxMask: u32,
    pub temporalLayerQP: [u8; 8usize],
    pub targetQuality: u8,
    pub targetQualityLSB: u8,
    pub lookaheadDepth: u16,
    pub reserved1: u32,
    pub qpMapMode: NV_ENC_QP_MAP_MODE,
    pub reserved: [u32; 7usize],
}
impl Default for _NV_ENC_RC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_RC_PARAMS {
    #[inline]
    pub fn enableMinQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMinQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMinQP_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMinQP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableMaxQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMaxQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMaxQP_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMaxQP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableInitialRCQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableInitialRCQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableInitialRCQP_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableInitialRCQP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableAQ_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableAQ_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitField1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitField1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitField1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLookahead(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLookahead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLookahead_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLookahead_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableIadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableIadapt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableIadapt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableBadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableBadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableBadapt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableBadapt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableTemporalAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTemporalAQ_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTemporalAQ_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn zeroReorderDelay(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zeroReorderDelay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn zeroReorderDelay_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_zeroReorderDelay_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableNonRefP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableNonRefP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableNonRefP_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableNonRefP_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn strictGOPTarget(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strictGOPTarget(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strictGOPTarget_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_strictGOPTarget_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn aqStrength(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_aqStrength(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn aqStrength_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_aqStrength_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableMinQP: u32,
        enableMaxQP: u32,
        enableInitialRCQP: u32,
        enableAQ: u32,
        reservedBitField1: u32,
        enableLookahead: u32,
        disableIadapt: u32,
        disableBadapt: u32,
        enableTemporalAQ: u32,
        zeroReorderDelay: u32,
        enableNonRefP: u32,
        strictGOPTarget: u32,
        aqStrength: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableMinQP: u32 = unsafe { ::std::mem::transmute(enableMinQP) };
            enableMinQP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableMaxQP: u32 = unsafe { ::std::mem::transmute(enableMaxQP) };
            enableMaxQP as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableInitialRCQP: u32 = unsafe { ::std::mem::transmute(enableInitialRCQP) };
            enableInitialRCQP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableAQ: u32 = unsafe { ::std::mem::transmute(enableAQ) };
            enableAQ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reservedBitField1: u32 = unsafe { ::std::mem::transmute(reservedBitField1) };
            reservedBitField1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLookahead: u32 = unsafe { ::std::mem::transmute(enableLookahead) };
            enableLookahead as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableIadapt: u32 = unsafe { ::std::mem::transmute(disableIadapt) };
            disableIadapt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableBadapt: u32 = unsafe { ::std::mem::transmute(disableBadapt) };
            disableBadapt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableTemporalAQ: u32 = unsafe { ::std::mem::transmute(enableTemporalAQ) };
            enableTemporalAQ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let zeroReorderDelay: u32 = unsafe { ::std::mem::transmute(zeroReorderDelay) };
            zeroReorderDelay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableNonRefP: u32 = unsafe { ::std::mem::transmute(enableNonRefP) };
            enableNonRefP as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let strictGOPTarget: u32 = unsafe { ::std::mem::transmute(strictGOPTarget) };
            strictGOPTarget as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let aqStrength: u32 = unsafe { ::std::mem::transmute(aqStrength) };
            aqStrength as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_RC_PARAMS = _NV_ENC_RC_PARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    pub overscanInfoPresentFlag: u32,
    pub overscanInfo: u32,
    pub videoSignalTypePresentFlag: u32,
    pub videoFormat: u32,
    pub videoFullRangeFlag: u32,
    pub colourDescriptionPresentFlag: u32,
    pub colourPrimaries: u32,
    pub transferCharacteristics: u32,
    pub colourMatrix: u32,
    pub chromaSampleLocationFlag: u32,
    pub chromaSampleLocationTop: u32,
    pub chromaSampleLocationBot: u32,
    pub bitstreamRestrictionFlag: u32,
    pub reserved: [u32; 15usize],
}
pub type NV_ENC_CONFIG_H264_VUI_PARAMETERS = _NV_ENC_CONFIG_H264_VUI_PARAMETERS;
pub type NV_ENC_CONFIG_HEVC_VUI_PARAMETERS = NV_ENC_CONFIG_H264_VUI_PARAMETERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 3usize],
}
impl _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    #[inline]
    pub fn numCandsPerBlk16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk16x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk16x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerBlk16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk16x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk16x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk8x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk8x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numCandsPerBlk8x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numCandsPerBlk8x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        numCandsPerBlk16x16: u32,
        numCandsPerBlk16x8: u32,
        numCandsPerBlk8x16: u32,
        numCandsPerBlk8x8: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let numCandsPerBlk16x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x16) };
            numCandsPerBlk16x16 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let numCandsPerBlk16x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x8) };
            numCandsPerBlk16x8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numCandsPerBlk8x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x16) };
            numCandsPerBlk8x16 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCandsPerBlk8x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x8) };
            numCandsPerBlk8x8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE = _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NVENC_EXTERNAL_ME_HINT {
    #[inline]
    pub fn mvx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mvx_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mvx_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mvy(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mvy_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mvy_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn refidx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn refidx_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_refidx_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dir(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dir_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dir_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn partType(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_partType(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn partType_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_partType_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lastofPart(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastofPart(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lastofPart_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lastofPart_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lastOfMB(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastOfMB(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lastOfMB_raw(this: *const Self) -> i32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lastOfMB_raw(this: *mut Self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mvx: i32,
        mvy: i32,
        refidx: i32,
        dir: i32,
        partType: i32,
        lastofPart: i32,
        lastOfMB: i32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let mvx: u32 = unsafe { ::std::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(12usize, 10u8, {
            let mvy: u32 = unsafe { ::std::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let refidx: u32 = unsafe { ::std::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let dir: u32 = unsafe { ::std::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let partType: u32 = unsafe { ::std::mem::transmute(partType) };
            partType as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lastofPart: u32 = unsafe { ::std::mem::transmute(lastofPart) };
            lastofPart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lastOfMB: u32 = unsafe { ::std::mem::transmute(lastOfMB) };
            lastOfMB as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NVENC_EXTERNAL_ME_HINT = _NVENC_EXTERNAL_ME_HINT;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub level: u32,
    pub idrPeriod: u32,
    pub separateColourPlaneFlag: u32,
    pub disableDeblockingFilterIDC: u32,
    pub numTemporalLayers: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub adaptiveTransformMode: NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE,
    pub fmoMode: NV_ENC_H264_FMO_MODE,
    pub bdirectMode: NV_ENC_H264_BDIRECT_MODE,
    pub entropyCodingMode: NV_ENC_H264_ENTROPY_CODING_MODE,
    pub stereoMode: NV_ENC_STEREO_PACKING_MODE,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFrames: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub h264VUIParameters: NV_ENC_CONFIG_H264_VUI_PARAMETERS,
    pub ltrNumFrames: u32,
    pub ltrTrustMode: u32,
    pub chromaFormatIDC: u32,
    pub maxTemporalLayers: u32,
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    pub reserved1: [u32; 269usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CONFIG_H264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_H264 {
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableTemporalSVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableTemporalSVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableStereoMVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableStereoMVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableStereoMVC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableStereoMVC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hierarchicalPFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalPFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hierarchicalPFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hierarchicalPFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hierarchicalBFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalBFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hierarchicalBFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hierarchicalBFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputBufferingPeriodSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputBufferingPeriodSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputPictureTimingSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputPictureTimingSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputAUD_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputAUD_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputFramePackingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputFramePackingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputFramePackingSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputFramePackingSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputRecoveryPointSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputRecoveryPointSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableConstrainedEncoding_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableConstrainedEncoding_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repeatSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repeatSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableVFR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableVFR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableVFR_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableVFR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLTR_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLTR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn qpPrimeYZeroTransformBypassFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_qpPrimeYZeroTransformBypassFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn qpPrimeYZeroTransformBypassFlag_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_qpPrimeYZeroTransformBypassFlag_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn useConstrainedIntraPred_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_useConstrainedIntraPred_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                15u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableTemporalSVC: u32,
        enableStereoMVC: u32,
        hierarchicalPFrames: u32,
        hierarchicalBFrames: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        disableSPSPPS: u32,
        outputFramePackingSEI: u32,
        outputRecoveryPointSEI: u32,
        enableIntraRefresh: u32,
        enableConstrainedEncoding: u32,
        repeatSPSPPS: u32,
        enableVFR: u32,
        enableLTR: u32,
        qpPrimeYZeroTransformBypassFlag: u32,
        useConstrainedIntraPred: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::std::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableStereoMVC: u32 = unsafe { ::std::mem::transmute(enableStereoMVC) };
            enableStereoMVC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hierarchicalPFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalPFrames) };
            hierarchicalPFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hierarchicalBFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalBFrames) };
            hierarchicalBFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let outputFramePackingSEI: u32 =
                unsafe { ::std::mem::transmute(outputFramePackingSEI) };
            outputFramePackingSEI as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::std::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::std::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enableVFR: u32 = unsafe { ::std::mem::transmute(enableVFR) };
            enableVFR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let qpPrimeYZeroTransformBypassFlag: u32 =
                unsafe { ::std::mem::transmute(qpPrimeYZeroTransformBypassFlag) };
            qpPrimeYZeroTransformBypassFlag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_CONFIG_H264 = _NV_ENC_CONFIG_H264;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_HEVC {
    pub level: u32,
    pub tier: u32,
    pub minCUSize: NV_ENC_HEVC_CUSIZE,
    pub maxCUSize: NV_ENC_HEVC_CUSIZE,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub idrPeriod: u32,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFramesInDPB: u32,
    pub ltrNumFrames: u32,
    pub vpsId: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub maxTemporalLayersMinus1: u32,
    pub hevcVUIParameters: NV_ENC_CONFIG_HEVC_VUI_PARAMETERS,
    pub ltrTrustMode: u32,
    pub reserved1: [u32; 217usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CONFIG_HEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_HEVC {
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn useConstrainedIntraPred_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_useConstrainedIntraPred_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableDeblockAcrossSliceBoundary(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableDeblockAcrossSliceBoundary(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableDeblockAcrossSliceBoundary_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableDeblockAcrossSliceBoundary_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputBufferingPeriodSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputBufferingPeriodSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputPictureTimingSEI_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputPictureTimingSEI_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outputAUD_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_outputAUD_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableLTR_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableLTR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn repeatSPSPPS_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_repeatSPSPPS_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableIntraRefresh_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableIntraRefresh_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn chromaFormatIDC_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_chromaFormatIDC_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pixelBitDepthMinus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pixelBitDepthMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pixelBitDepthMinus8_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pixelBitDepthMinus8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                18u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                18u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        useConstrainedIntraPred: u32,
        disableDeblockAcrossSliceBoundary: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        enableLTR: u32,
        disableSPSPPS: u32,
        repeatSPSPPS: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        pixelBitDepthMinus8: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disableDeblockAcrossSliceBoundary: u32 =
                unsafe { ::std::mem::transmute(disableDeblockAcrossSliceBoundary) };
            disableDeblockAcrossSliceBoundary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::std::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let pixelBitDepthMinus8: u32 = unsafe { ::std::mem::transmute(pixelBitDepthMinus8) };
            pixelBitDepthMinus8 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_CONFIG_HEVC = _NV_ENC_CONFIG_HEVC;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_MEONLY {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 255usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CONFIG_H264_MEONLY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_H264_MEONLY {
    #[inline]
    pub fn disablePartition16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition16x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition16x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disablePartition8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition8x16_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition8x16_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disablePartition16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition16x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition16x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disablePartition8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disablePartition8x8_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disablePartition8x8_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableIntraSearch(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIntraSearch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableIntraSearch_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disableIntraSearch_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bStereoEnable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bStereoEnable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bStereoEnable_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bStereoEnable_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                26u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                26u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disablePartition16x16: u32,
        disablePartition8x16: u32,
        disablePartition16x8: u32,
        disablePartition8x8: u32,
        disableIntraSearch: u32,
        bStereoEnable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disablePartition16x16: u32 =
                unsafe { ::std::mem::transmute(disablePartition16x16) };
            disablePartition16x16 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disablePartition8x16: u32 = unsafe { ::std::mem::transmute(disablePartition8x16) };
            disablePartition8x16 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disablePartition16x8: u32 = unsafe { ::std::mem::transmute(disablePartition16x8) };
            disablePartition16x8 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disablePartition8x8: u32 = unsafe { ::std::mem::transmute(disablePartition8x8) };
            disablePartition8x8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableIntraSearch: u32 = unsafe { ::std::mem::transmute(disableIntraSearch) };
            disableIntraSearch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bStereoEnable: u32 = unsafe { ::std::mem::transmute(bStereoEnable) };
            bStereoEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_CONFIG_H264_MEONLY = _NV_ENC_CONFIG_H264_MEONLY;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_HEVC_MEONLY {
    pub reserved: [u32; 256usize],
    pub reserved1: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CONFIG_HEVC_MEONLY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CONFIG_HEVC_MEONLY = _NV_ENC_CONFIG_HEVC_MEONLY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_CONFIG {
    pub h264Config: NV_ENC_CONFIG_H264,
    pub hevcConfig: NV_ENC_CONFIG_HEVC,
    pub h264MeOnlyConfig: NV_ENC_CONFIG_H264_MEONLY,
    pub hevcMeOnlyConfig: NV_ENC_CONFIG_HEVC_MEONLY,
    pub reserved: [u32; 320usize],
}
impl Default for _NV_ENC_CODEC_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CODEC_CONFIG = _NV_ENC_CODEC_CONFIG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG {
    pub version: u32,
    pub profileGUID: GUID,
    pub gopLength: u32,
    pub frameIntervalP: i32,
    pub monoChromeEncoding: u32,
    pub frameFieldMode: NV_ENC_PARAMS_FRAME_FIELD_MODE,
    pub mvPrecision: NV_ENC_MV_PRECISION,
    pub rcParams: NV_ENC_RC_PARAMS,
    pub encodeCodecConfig: NV_ENC_CODEC_CONFIG,
    pub reserved: [u32; 278usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CONFIG = _NV_ENC_CONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_INITIALIZE_PARAMS {
    pub version: u32,
    pub encodeGUID: GUID,
    pub presetGUID: GUID,
    pub encodeWidth: u32,
    pub encodeHeight: u32,
    pub darWidth: u32,
    pub darHeight: u32,
    pub frameRateNum: u32,
    pub frameRateDen: u32,
    pub enableEncodeAsync: u32,
    pub enablePTD: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub privDataSize: u32,
    pub privData: *mut ::std::os::raw::c_void,
    pub encodeConfig: *mut NV_ENC_CONFIG,
    pub maxEncodeWidth: u32,
    pub maxEncodeHeight: u32,
    pub maxMEHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub reserved: [u32; 289usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_INITIALIZE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_INITIALIZE_PARAMS {
    #[inline]
    pub fn reportSliceOffsets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reportSliceOffsets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reportSliceOffsets_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reportSliceOffsets_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableSubFrameWrite(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableSubFrameWrite(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableSubFrameWrite_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableSubFrameWrite_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableExternalMEHints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableExternalMEHints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableExternalMEHints_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableExternalMEHints_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableMEOnlyMode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMEOnlyMode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableMEOnlyMode_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableMEOnlyMode_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enableWeightedPrediction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableWeightedPrediction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enableWeightedPrediction_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_enableWeightedPrediction_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reportSliceOffsets: u32,
        enableSubFrameWrite: u32,
        enableExternalMEHints: u32,
        enableMEOnlyMode: u32,
        enableWeightedPrediction: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reportSliceOffsets: u32 = unsafe { ::std::mem::transmute(reportSliceOffsets) };
            reportSliceOffsets as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableSubFrameWrite: u32 = unsafe { ::std::mem::transmute(enableSubFrameWrite) };
            enableSubFrameWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableExternalMEHints: u32 =
                unsafe { ::std::mem::transmute(enableExternalMEHints) };
            enableExternalMEHints as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableMEOnlyMode: u32 = unsafe { ::std::mem::transmute(enableMEOnlyMode) };
            enableMEOnlyMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enableWeightedPrediction: u32 =
                unsafe { ::std::mem::transmute(enableWeightedPrediction) };
            enableWeightedPrediction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_INITIALIZE_PARAMS = _NV_ENC_INITIALIZE_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_RECONFIGURE_PARAMS {
    pub version: u32,
    pub reInitEncodeParams: NV_ENC_INITIALIZE_PARAMS,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl Default for _NV_ENC_RECONFIGURE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_RECONFIGURE_PARAMS {
    #[inline]
    pub fn resetEncoder(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resetEncoder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resetEncoder_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_resetEncoder_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn forceIDR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceIDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn forceIDR_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_forceIDR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        resetEncoder: u32,
        forceIDR: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resetEncoder: u32 = unsafe { ::std::mem::transmute(resetEncoder) };
            resetEncoder as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let forceIDR: u32 = unsafe { ::std::mem::transmute(forceIDR) };
            forceIDR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_RECONFIGURE_PARAMS = _NV_ENC_RECONFIGURE_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PRESET_CONFIG {
    pub version: u32,
    pub presetCfg: NV_ENC_CONFIG,
    pub reserved1: [u32; 255usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_PRESET_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_PRESET_CONFIG = _NV_ENC_PRESET_CONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_SEI_PAYLOAD {
    pub payloadSize: u32,
    pub payloadType: u32,
    pub payload: *mut u8,
}
impl Default for _NV_ENC_SEI_PAYLOAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_SEI_PAYLOAD = _NV_ENC_SEI_PAYLOAD;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_H264 {
    pub displayPOCSyntax: u32,
    pub reserved3: u32,
    pub refPicFlag: u32,
    pub colourPlaneId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sliceTypeData: *mut u8,
    pub sliceTypeArrayCnt: u32,
    pub seiPayloadArrayCnt: u32,
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub ltrMarkFrameIdx: u32,
    pub ltrUseFrameBitmap: u32,
    pub ltrUsageMode: u32,
    pub reserved: [u32; 243usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 62usize],
}
impl Default for _NV_ENC_PIC_PARAMS_H264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_H264 {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn constrainedFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_constrainedFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sliceModeDataUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sliceModeDataUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrMarkFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrMarkFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrUseFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrUseFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_PIC_PARAMS_H264 = _NV_ENC_PIC_PARAMS_H264;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_HEVC {
    pub displayPOCSyntax: u32,
    pub refPicFlag: u32,
    pub temporalId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sliceTypeData: *mut u8,
    pub sliceTypeArrayCnt: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub ltrMarkFrameIdx: u32,
    pub ltrUseFrameBitmap: u32,
    pub ltrUsageMode: u32,
    pub seiPayloadArrayCnt: u32,
    pub reserved: u32,
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub reserved2: [u32; 244usize],
    pub reserved3: [*mut ::std::os::raw::c_void; 61usize],
}
impl Default for _NV_ENC_PIC_PARAMS_HEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_HEVC {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn constrainedFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_constrainedFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sliceModeDataUpdate_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sliceModeDataUpdate_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrMarkFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrMarkFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrUseFrames_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrUseFrames_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_PIC_PARAMS_HEVC = _NV_ENC_PIC_PARAMS_HEVC;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_PIC_PARAMS {
    pub h264PicParams: NV_ENC_PIC_PARAMS_H264,
    pub hevcPicParams: NV_ENC_PIC_PARAMS_HEVC,
    pub reserved: [u32; 256usize],
}
impl Default for _NV_ENC_CODEC_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_CODEC_PIC_PARAMS = _NV_ENC_CODEC_PIC_PARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS {
    pub version: u32,
    pub inputWidth: u32,
    pub inputHeight: u32,
    pub inputPitch: u32,
    pub encodePicFlags: u32,
    pub frameIdx: u32,
    pub inputTimeStamp: u64,
    pub inputDuration: u64,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub outputBitstream: NV_ENC_OUTPUT_PTR,
    pub completionEvent: *mut ::std::os::raw::c_void,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    pub pictureType: NV_ENC_PIC_TYPE,
    pub codecPicParams: NV_ENC_CODEC_PIC_PARAMS,
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    pub reserved1: [u32; 6usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 2usize],
    pub qpDeltaMap: *mut i8,
    pub qpDeltaMapSize: u32,
    pub reservedBitFields: u32,
    pub meHintRefPicDist: [u16; 2usize],
    pub reserved3: [u32; 286usize],
    pub reserved4: [*mut ::std::os::raw::c_void; 60usize],
}
impl Default for _NV_ENC_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_PIC_PARAMS = _NV_ENC_PIC_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_MEONLY_PARAMS {
    pub version: u32,
    pub inputWidth: u32,
    pub inputHeight: u32,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub referenceFrame: NV_ENC_INPUT_PTR,
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub completionEvent: *mut ::std::os::raw::c_void,
    pub viewID: u32,
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    pub reserved1: [u32; 243usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 59usize],
}
impl Default for _NV_ENC_MEONLY_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_MEONLY_PARAMS = _NV_ENC_MEONLY_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_LOCK_BITSTREAM {
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub outputBitstream: *mut ::std::os::raw::c_void,
    pub sliceOffsets: *mut u32,
    pub frameIdx: u32,
    pub hwEncodeStatus: u32,
    pub numSlices: u32,
    pub bitstreamSizeInBytes: u32,
    pub outputTimeStamp: u64,
    pub outputDuration: u64,
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    pub pictureType: NV_ENC_PIC_TYPE,
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    pub frameAvgQP: u32,
    pub frameSatd: u32,
    pub ltrFrameIdx: u32,
    pub ltrFrameBitmap: u32,
    pub reserved: [u32; 236usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_LOCK_BITSTREAM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_LOCK_BITSTREAM {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn doNotWait_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_doNotWait_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ltrFrame_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ltrFrame_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        ltrFrame: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::std::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_LOCK_BITSTREAM = _NV_ENC_LOCK_BITSTREAM;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_LOCK_INPUT_BUFFER {
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub bufferDataPtr: *mut ::std::os::raw::c_void,
    pub pitch: u32,
    pub reserved1: [u32; 251usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_LOCK_INPUT_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_LOCK_INPUT_BUFFER {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn doNotWait_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_doNotWait_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reservedBitFields_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reservedBitFields_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NV_ENC_LOCK_INPUT_BUFFER = _NV_ENC_LOCK_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_MAP_INPUT_RESOURCE {
    pub version: u32,
    pub subResourceIndex: u32,
    pub inputResource: *mut ::std::os::raw::c_void,
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    pub mappedResource: NV_ENC_INPUT_PTR,
    pub mappedBufferFmt: NV_ENC_BUFFER_FORMAT,
    pub reserved1: [u32; 251usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
impl Default for _NV_ENC_MAP_INPUT_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_MAP_INPUT_RESOURCE = _NV_ENC_MAP_INPUT_RESOURCE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX {
    pub texture: u32,
    pub target: u32,
}
pub type NV_ENC_INPUT_RESOURCE_OPENGL_TEX = _NV_ENC_INPUT_RESOURCE_OPENGL_TEX;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_REGISTER_RESOURCE {
    pub version: u32,
    pub resourceType: NV_ENC_INPUT_RESOURCE_TYPE,
    pub width: u32,
    pub height: u32,
    pub pitch: u32,
    pub subResourceIndex: u32,
    pub resourceToRegister: *mut ::std::os::raw::c_void,
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    pub reserved1: [u32; 248usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 62usize],
}
impl Default for _NV_ENC_REGISTER_RESOURCE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_REGISTER_RESOURCE = _NV_ENC_REGISTER_RESOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_STAT {
    pub version: u32,
    pub reserved: u32,
    pub outputBitStream: NV_ENC_OUTPUT_PTR,
    pub bitStreamSize: u32,
    pub picType: u32,
    pub lastValidByteOffset: u32,
    pub sliceOffsets: [u32; 16usize],
    pub picIdx: u32,
    pub reserved1: [u32; 233usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_STAT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_STAT = _NV_ENC_STAT;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    pub version: u32,
    pub inBufferSize: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub spsppsBuffer: *mut ::std::os::raw::c_void,
    pub outSPSPPSPayloadSize: *mut u32,
    pub reserved: [u32; 250usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_SEQUENCE_PARAM_PAYLOAD = _NV_ENC_SEQUENCE_PARAM_PAYLOAD;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_EVENT_PARAMS {
    pub version: u32,
    pub reserved: u32,
    pub completionEvent: *mut ::std::os::raw::c_void,
    pub reserved1: [u32; 253usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_EVENT_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_EVENT_PARAMS = _NV_ENC_EVENT_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    pub version: u32,
    pub deviceType: NV_ENC_DEVICE_TYPE,
    pub device: *mut ::std::os::raw::c_void,
    pub reserved: *mut ::std::os::raw::c_void,
    pub apiVersion: u32,
    pub reserved1: [u32; 253usize],
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
impl Default for _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS = _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS;
unsafe extern "C" {
    pub fn NvEncOpenEncodeSession(
        device: *mut ::std::os::raw::c_void,
        deviceType: u32,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeGUIDCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeProfileGUIDCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeProfileGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetInputFormatCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetInputFormats(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeCaps(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::std::os::raw::c_int,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodePresetCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodePresetGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodePresetConfig(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncInitializeEncoder(
        encoder: *mut ::std::os::raw::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncCreateInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncDestroyInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncCreateBitstreamBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncDestroyBitstreamBuffer(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncEncodePicture(
        encoder: *mut ::std::os::raw::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncLockBitstream(
        encoder: *mut ::std::os::raw::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncUnlockBitstream(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncLockInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncUnlockInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetEncodeStats(
        encoder: *mut ::std::os::raw::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncGetSequenceParams(
        encoder: *mut ::std::os::raw::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncRegisterAsyncEvent(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncUnregisterAsyncEvent(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncMapInputResource(
        encoder: *mut ::std::os::raw::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncUnmapInputResource(
        encoder: *mut ::std::os::raw::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncDestroyEncoder(encoder: *mut ::std::os::raw::c_void) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncInvalidateRefFrames(
        encoder: *mut ::std::os::raw::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncOpenEncodeSessionEx(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncRegisterResource(
        encoder: *mut ::std::os::raw::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncUnregisterResource(
        encoder: *mut ::std::os::raw::c_void,
        registeredResource: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncReconfigureEncoder(
        encoder: *mut ::std::os::raw::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncCreateMVBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncDestroyMVBuffer(
        encoder: *mut ::std::os::raw::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncRunMotionEstimationOnly(
        encoder: *mut ::std::os::raw::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS;
}
unsafe extern "C" {
    pub fn NvEncodeAPIGetMaxSupportedVersion(version: *mut u32) -> NVENCSTATUS;
}
pub type PNVENCOPENENCODESESSION = ::std::option::Option<
    unsafe extern "C" fn(
        device: *mut ::std::os::raw::c_void,
        deviceType: u32,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPROFILEGUIDCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPROFILEGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODECAPS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::std::os::raw::c_int,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIG = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCINITIALIZEENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCENCODEPICTURE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODESTATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYENCODER = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> NVENCSTATUS,
>;
pub type PNVENCINVALIDATEREFFRAMES = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS,
>;
pub type PNVENCOPENENCODESESSIONEX = ::std::option::Option<
    unsafe extern "C" fn(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registeredRes: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRECONFIGUREENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRUNMOTIONESTIMATIONONLY = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _NV_ENCODE_API_FUNCTION_LIST {
    pub version: u32,
    pub reserved: u32,
    pub nvEncOpenEncodeSession: PNVENCOPENENCODESESSION,
    pub nvEncGetEncodeGUIDCount: PNVENCGETENCODEGUIDCOUNT,
    pub nvEncGetEncodeProfileGUIDCount: PNVENCGETENCODEPRESETCOUNT,
    pub nvEncGetEncodeProfileGUIDs: PNVENCGETENCODEPRESETGUIDS,
    pub nvEncGetEncodeGUIDs: PNVENCGETENCODEGUIDS,
    pub nvEncGetInputFormatCount: PNVENCGETINPUTFORMATCOUNT,
    pub nvEncGetInputFormats: PNVENCGETINPUTFORMATS,
    pub nvEncGetEncodeCaps: PNVENCGETENCODECAPS,
    pub nvEncGetEncodePresetCount: PNVENCGETENCODEPRESETCOUNT,
    pub nvEncGetEncodePresetGUIDs: PNVENCGETENCODEPRESETGUIDS,
    pub nvEncGetEncodePresetConfig: PNVENCGETENCODEPRESETCONFIG,
    pub nvEncInitializeEncoder: PNVENCINITIALIZEENCODER,
    pub nvEncCreateInputBuffer: PNVENCCREATEINPUTBUFFER,
    pub nvEncDestroyInputBuffer: PNVENCDESTROYINPUTBUFFER,
    pub nvEncCreateBitstreamBuffer: PNVENCCREATEBITSTREAMBUFFER,
    pub nvEncDestroyBitstreamBuffer: PNVENCDESTROYBITSTREAMBUFFER,
    pub nvEncEncodePicture: PNVENCENCODEPICTURE,
    pub nvEncLockBitstream: PNVENCLOCKBITSTREAM,
    pub nvEncUnlockBitstream: PNVENCUNLOCKBITSTREAM,
    pub nvEncLockInputBuffer: PNVENCLOCKINPUTBUFFER,
    pub nvEncUnlockInputBuffer: PNVENCUNLOCKINPUTBUFFER,
    pub nvEncGetEncodeStats: PNVENCGETENCODESTATS,
    pub nvEncGetSequenceParams: PNVENCGETSEQUENCEPARAMS,
    pub nvEncRegisterAsyncEvent: PNVENCREGISTERASYNCEVENT,
    pub nvEncUnregisterAsyncEvent: PNVENCUNREGISTERASYNCEVENT,
    pub nvEncMapInputResource: PNVENCMAPINPUTRESOURCE,
    pub nvEncUnmapInputResource: PNVENCUNMAPINPUTRESOURCE,
    pub nvEncDestroyEncoder: PNVENCDESTROYENCODER,
    pub nvEncInvalidateRefFrames: PNVENCINVALIDATEREFFRAMES,
    pub nvEncOpenEncodeSessionEx: PNVENCOPENENCODESESSIONEX,
    pub nvEncRegisterResource: PNVENCREGISTERRESOURCE,
    pub nvEncUnregisterResource: PNVENCUNREGISTERRESOURCE,
    pub nvEncReconfigureEncoder: PNVENCRECONFIGUREENCODER,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub nvEncCreateMVBuffer: PNVENCCREATEMVBUFFER,
    pub nvEncDestroyMVBuffer: PNVENCDESTROYMVBUFFER,
    pub nvEncRunMotionEstimationOnly: PNVENCRUNMOTIONESTIMATIONONLY,
    pub reserved2: [*mut ::std::os::raw::c_void; 281usize],
}
impl Default for _NV_ENCODE_API_FUNCTION_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NV_ENCODE_API_FUNCTION_LIST = _NV_ENCODE_API_FUNCTION_LIST;
unsafe extern "C" {
    pub fn NvEncodeAPICreateInstance(functionList: *mut NV_ENCODE_API_FUNCTION_LIST)
        -> NVENCSTATUS;
}
pub type tcu_ulong = ::std::os::raw::c_ulong;
pub type CUvideodecoder = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUcontextlock_st {
    _unused: [u8; 0],
}
pub type CUvideoctxlock = *mut _CUcontextlock_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoCodec_enum {
    cudaVideoCodec_MPEG1 = 0,
    cudaVideoCodec_MPEG2 = 1,
    cudaVideoCodec_MPEG4 = 2,
    cudaVideoCodec_VC1 = 3,
    cudaVideoCodec_H264 = 4,
    cudaVideoCodec_JPEG = 5,
    cudaVideoCodec_H264_SVC = 6,
    cudaVideoCodec_H264_MVC = 7,
    cudaVideoCodec_HEVC = 8,
    cudaVideoCodec_VP8 = 9,
    cudaVideoCodec_VP9 = 10,
    cudaVideoCodec_NumCodecs = 11,
    cudaVideoCodec_YUV420 = 1230591318,
    cudaVideoCodec_YV12 = 1498820914,
    cudaVideoCodec_NV12 = 1314271538,
    cudaVideoCodec_YUYV = 1498765654,
    cudaVideoCodec_UYVY = 1431918169,
}
pub use self::cudaVideoCodec_enum as cudaVideoCodec;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoSurfaceFormat_enum {
    cudaVideoSurfaceFormat_NV12 = 0,
    cudaVideoSurfaceFormat_P016 = 1,
}
pub use self::cudaVideoSurfaceFormat_enum as cudaVideoSurfaceFormat;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoDeinterlaceMode_enum {
    cudaVideoDeinterlaceMode_Weave = 0,
    cudaVideoDeinterlaceMode_Bob = 1,
    cudaVideoDeinterlaceMode_Adaptive = 2,
}
pub use self::cudaVideoDeinterlaceMode_enum as cudaVideoDeinterlaceMode;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoChromaFormat_enum {
    cudaVideoChromaFormat_Monochrome = 0,
    cudaVideoChromaFormat_420 = 1,
    cudaVideoChromaFormat_422 = 2,
    cudaVideoChromaFormat_444 = 3,
}
pub use self::cudaVideoChromaFormat_enum as cudaVideoChromaFormat;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoCreateFlags_enum {
    cudaVideoCreate_Default = 0,
    cudaVideoCreate_PreferCUDA = 1,
    cudaVideoCreate_PreferDXVA = 2,
    cudaVideoCreate_PreferCUVID = 4,
}
pub use self::cudaVideoCreateFlags_enum as cudaVideoCreateFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDDECODECAPS {
    pub eCodecType: cudaVideoCodec,
    pub eChromaFormat: cudaVideoChromaFormat,
    pub nBitDepthMinus8: ::std::os::raw::c_uint,
    pub reserved1: [::std::os::raw::c_uint; 3usize],
    pub bIsSupported: ::std::os::raw::c_uchar,
    pub reserved2: [::std::os::raw::c_uchar; 3usize],
    pub nMaxWidth: ::std::os::raw::c_uint,
    pub nMaxHeight: ::std::os::raw::c_uint,
    pub nMaxMBCount: ::std::os::raw::c_uint,
    pub nMinWidth: ::std::os::raw::c_ushort,
    pub nMinHeight: ::std::os::raw::c_ushort,
    pub reserved3: [::std::os::raw::c_uint; 11usize],
}
impl Default for _CUVIDDECODECAPS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDDECODECAPS = _CUVIDDECODECAPS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDDECODECREATEINFO {
    pub ulWidth: tcu_ulong,
    pub ulHeight: tcu_ulong,
    pub ulNumDecodeSurfaces: tcu_ulong,
    pub CodecType: cudaVideoCodec,
    pub ChromaFormat: cudaVideoChromaFormat,
    pub ulCreationFlags: tcu_ulong,
    pub bitDepthMinus8: tcu_ulong,
    pub ulIntraDecodeOnly: tcu_ulong,
    pub Reserved1: [tcu_ulong; 3usize],
    pub display_area: _CUVIDDECODECREATEINFO__bindgen_ty_1,
    pub OutputFormat: cudaVideoSurfaceFormat,
    pub DeinterlaceMode: cudaVideoDeinterlaceMode,
    pub ulTargetWidth: tcu_ulong,
    pub ulTargetHeight: tcu_ulong,
    pub ulNumOutputSurfaces: tcu_ulong,
    pub vidLock: CUvideoctxlock,
    pub target_rect: _CUVIDDECODECREATEINFO__bindgen_ty_2,
    pub Reserved2: [tcu_ulong; 5usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDDECODECREATEINFO__bindgen_ty_1 {
    pub left: ::std::os::raw::c_short,
    pub top: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDDECODECREATEINFO__bindgen_ty_2 {
    pub left: ::std::os::raw::c_short,
    pub top: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
}
impl Default for _CUVIDDECODECREATEINFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDDECODECREATEINFO = _CUVIDDECODECREATEINFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDH264DPBENTRY {
    pub PicIdx: ::std::os::raw::c_int,
    pub FrameIdx: ::std::os::raw::c_int,
    pub is_long_term: ::std::os::raw::c_int,
    pub not_existing: ::std::os::raw::c_int,
    pub used_for_reference: ::std::os::raw::c_int,
    pub FieldOrderCnt: [::std::os::raw::c_int; 2usize],
}
pub type CUVIDH264DPBENTRY = _CUVIDH264DPBENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDH264MVCEXT {
    pub num_views_minus1: ::std::os::raw::c_int,
    pub view_id: ::std::os::raw::c_int,
    pub inter_view_flag: ::std::os::raw::c_uchar,
    pub num_inter_view_refs_l0: ::std::os::raw::c_uchar,
    pub num_inter_view_refs_l1: ::std::os::raw::c_uchar,
    pub MVCReserved8Bits: ::std::os::raw::c_uchar,
    pub InterViewRefsL0: [::std::os::raw::c_int; 16usize],
    pub InterViewRefsL1: [::std::os::raw::c_int; 16usize],
}
pub type CUVIDH264MVCEXT = _CUVIDH264MVCEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDH264SVCEXT {
    pub profile_idc: ::std::os::raw::c_uchar,
    pub level_idc: ::std::os::raw::c_uchar,
    pub DQId: ::std::os::raw::c_uchar,
    pub DQIdMax: ::std::os::raw::c_uchar,
    pub disable_inter_layer_deblocking_filter_idc: ::std::os::raw::c_uchar,
    pub ref_layer_chroma_phase_y_plus1: ::std::os::raw::c_uchar,
    pub inter_layer_slice_alpha_c0_offset_div2: ::std::os::raw::c_schar,
    pub inter_layer_slice_beta_offset_div2: ::std::os::raw::c_schar,
    pub DPBEntryValidFlag: ::std::os::raw::c_ushort,
    pub inter_layer_deblocking_filter_control_present_flag: ::std::os::raw::c_uchar,
    pub extended_spatial_scalability_idc: ::std::os::raw::c_uchar,
    pub adaptive_tcoeff_level_prediction_flag: ::std::os::raw::c_uchar,
    pub slice_header_restriction_flag: ::std::os::raw::c_uchar,
    pub chroma_phase_x_plus1_flag: ::std::os::raw::c_uchar,
    pub chroma_phase_y_plus1: ::std::os::raw::c_uchar,
    pub tcoeff_level_prediction_flag: ::std::os::raw::c_uchar,
    pub constrained_intra_resampling_flag: ::std::os::raw::c_uchar,
    pub ref_layer_chroma_phase_x_plus1_flag: ::std::os::raw::c_uchar,
    pub store_ref_base_pic_flag: ::std::os::raw::c_uchar,
    pub Reserved8BitsA: ::std::os::raw::c_uchar,
    pub Reserved8BitsB: ::std::os::raw::c_uchar,
    pub scaled_ref_layer_left_offset: ::std::os::raw::c_short,
    pub scaled_ref_layer_top_offset: ::std::os::raw::c_short,
    pub scaled_ref_layer_right_offset: ::std::os::raw::c_short,
    pub scaled_ref_layer_bottom_offset: ::std::os::raw::c_short,
    pub Reserved16Bits: ::std::os::raw::c_ushort,
    pub pNextLayer: *mut _CUVIDPICPARAMS,
    pub bRefBaseLayer: ::std::os::raw::c_int,
}
impl Default for _CUVIDH264SVCEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDH264SVCEXT = _CUVIDH264SVCEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CUVIDH264PICPARAMS {
    pub log2_max_frame_num_minus4: ::std::os::raw::c_int,
    pub pic_order_cnt_type: ::std::os::raw::c_int,
    pub log2_max_pic_order_cnt_lsb_minus4: ::std::os::raw::c_int,
    pub delta_pic_order_always_zero_flag: ::std::os::raw::c_int,
    pub frame_mbs_only_flag: ::std::os::raw::c_int,
    pub direct_8x8_inference_flag: ::std::os::raw::c_int,
    pub num_ref_frames: ::std::os::raw::c_int,
    pub residual_colour_transform_flag: ::std::os::raw::c_uchar,
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    pub qpprime_y_zero_transform_bypass_flag: ::std::os::raw::c_uchar,
    pub entropy_coding_mode_flag: ::std::os::raw::c_int,
    pub pic_order_present_flag: ::std::os::raw::c_int,
    pub num_ref_idx_l0_active_minus1: ::std::os::raw::c_int,
    pub num_ref_idx_l1_active_minus1: ::std::os::raw::c_int,
    pub weighted_pred_flag: ::std::os::raw::c_int,
    pub weighted_bipred_idc: ::std::os::raw::c_int,
    pub pic_init_qp_minus26: ::std::os::raw::c_int,
    pub deblocking_filter_control_present_flag: ::std::os::raw::c_int,
    pub redundant_pic_cnt_present_flag: ::std::os::raw::c_int,
    pub transform_8x8_mode_flag: ::std::os::raw::c_int,
    pub MbaffFrameFlag: ::std::os::raw::c_int,
    pub constrained_intra_pred_flag: ::std::os::raw::c_int,
    pub chroma_qp_index_offset: ::std::os::raw::c_int,
    pub second_chroma_qp_index_offset: ::std::os::raw::c_int,
    pub ref_pic_flag: ::std::os::raw::c_int,
    pub frame_num: ::std::os::raw::c_int,
    pub CurrFieldOrderCnt: [::std::os::raw::c_int; 2usize],
    pub dpb: [CUVIDH264DPBENTRY; 16usize],
    pub WeightScale4x4: [[::std::os::raw::c_uchar; 16usize]; 6usize],
    pub WeightScale8x8: [[::std::os::raw::c_uchar; 64usize]; 2usize],
    pub fmo_aso_enable: ::std::os::raw::c_uchar,
    pub num_slice_groups_minus1: ::std::os::raw::c_uchar,
    pub slice_group_map_type: ::std::os::raw::c_uchar,
    pub pic_init_qs_minus26: ::std::os::raw::c_schar,
    pub slice_group_change_rate_minus1: ::std::os::raw::c_uint,
    pub fmo: _CUVIDH264PICPARAMS__bindgen_ty_1,
    pub Reserved: [::std::os::raw::c_uint; 12usize],
    pub __bindgen_anon_1: _CUVIDH264PICPARAMS__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDH264PICPARAMS__bindgen_ty_1 {
    pub slice_group_map_addr: ::std::os::raw::c_ulonglong,
    pub pMb2SliceGroupMap: *const ::std::os::raw::c_uchar,
}
impl Default for _CUVIDH264PICPARAMS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDH264PICPARAMS__bindgen_ty_2 {
    pub mvcext: CUVIDH264MVCEXT,
    pub svcext: CUVIDH264SVCEXT,
}
impl Default for _CUVIDH264PICPARAMS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CUVIDH264PICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDH264PICPARAMS = _CUVIDH264PICPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDMPEG2PICPARAMS {
    pub ForwardRefIdx: ::std::os::raw::c_int,
    pub BackwardRefIdx: ::std::os::raw::c_int,
    pub picture_coding_type: ::std::os::raw::c_int,
    pub full_pel_forward_vector: ::std::os::raw::c_int,
    pub full_pel_backward_vector: ::std::os::raw::c_int,
    pub f_code: [[::std::os::raw::c_int; 2usize]; 2usize],
    pub intra_dc_precision: ::std::os::raw::c_int,
    pub frame_pred_frame_dct: ::std::os::raw::c_int,
    pub concealment_motion_vectors: ::std::os::raw::c_int,
    pub q_scale_type: ::std::os::raw::c_int,
    pub intra_vlc_format: ::std::os::raw::c_int,
    pub alternate_scan: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub QuantMatrixIntra: [::std::os::raw::c_uchar; 64usize],
    pub QuantMatrixInter: [::std::os::raw::c_uchar; 64usize],
}
impl Default for _CUVIDMPEG2PICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDMPEG2PICPARAMS = _CUVIDMPEG2PICPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDMPEG4PICPARAMS {
    pub ForwardRefIdx: ::std::os::raw::c_int,
    pub BackwardRefIdx: ::std::os::raw::c_int,
    pub video_object_layer_width: ::std::os::raw::c_int,
    pub video_object_layer_height: ::std::os::raw::c_int,
    pub vop_time_increment_bitcount: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub resync_marker_disable: ::std::os::raw::c_int,
    pub quant_type: ::std::os::raw::c_int,
    pub quarter_sample: ::std::os::raw::c_int,
    pub short_video_header: ::std::os::raw::c_int,
    pub divx_flags: ::std::os::raw::c_int,
    pub vop_coding_type: ::std::os::raw::c_int,
    pub vop_coded: ::std::os::raw::c_int,
    pub vop_rounding_type: ::std::os::raw::c_int,
    pub alternate_vertical_scan_flag: ::std::os::raw::c_int,
    pub interlaced: ::std::os::raw::c_int,
    pub vop_fcode_forward: ::std::os::raw::c_int,
    pub vop_fcode_backward: ::std::os::raw::c_int,
    pub trd: [::std::os::raw::c_int; 2usize],
    pub trb: [::std::os::raw::c_int; 2usize],
    pub QuantMatrixIntra: [::std::os::raw::c_uchar; 64usize],
    pub QuantMatrixInter: [::std::os::raw::c_uchar; 64usize],
    pub gmc_enabled: ::std::os::raw::c_int,
}
impl Default for _CUVIDMPEG4PICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDMPEG4PICPARAMS = _CUVIDMPEG4PICPARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDVC1PICPARAMS {
    pub ForwardRefIdx: ::std::os::raw::c_int,
    pub BackwardRefIdx: ::std::os::raw::c_int,
    pub FrameWidth: ::std::os::raw::c_int,
    pub FrameHeight: ::std::os::raw::c_int,
    pub intra_pic_flag: ::std::os::raw::c_int,
    pub ref_pic_flag: ::std::os::raw::c_int,
    pub progressive_fcm: ::std::os::raw::c_int,
    pub profile: ::std::os::raw::c_int,
    pub postprocflag: ::std::os::raw::c_int,
    pub pulldown: ::std::os::raw::c_int,
    pub interlace: ::std::os::raw::c_int,
    pub tfcntrflag: ::std::os::raw::c_int,
    pub finterpflag: ::std::os::raw::c_int,
    pub psf: ::std::os::raw::c_int,
    pub multires: ::std::os::raw::c_int,
    pub syncmarker: ::std::os::raw::c_int,
    pub rangered: ::std::os::raw::c_int,
    pub maxbframes: ::std::os::raw::c_int,
    pub panscan_flag: ::std::os::raw::c_int,
    pub refdist_flag: ::std::os::raw::c_int,
    pub extended_mv: ::std::os::raw::c_int,
    pub dquant: ::std::os::raw::c_int,
    pub vstransform: ::std::os::raw::c_int,
    pub loopfilter: ::std::os::raw::c_int,
    pub fastuvmc: ::std::os::raw::c_int,
    pub overlap: ::std::os::raw::c_int,
    pub quantizer: ::std::os::raw::c_int,
    pub extended_dmv: ::std::os::raw::c_int,
    pub range_mapy_flag: ::std::os::raw::c_int,
    pub range_mapy: ::std::os::raw::c_int,
    pub range_mapuv_flag: ::std::os::raw::c_int,
    pub range_mapuv: ::std::os::raw::c_int,
    pub rangeredfrm: ::std::os::raw::c_int,
}
pub type CUVIDVC1PICPARAMS = _CUVIDVC1PICPARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDJPEGPICPARAMS {
    pub Reserved: ::std::os::raw::c_int,
}
pub type CUVIDJPEGPICPARAMS = _CUVIDJPEGPICPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDHEVCPICPARAMS {
    pub pic_width_in_luma_samples: ::std::os::raw::c_int,
    pub pic_height_in_luma_samples: ::std::os::raw::c_int,
    pub log2_min_luma_coding_block_size_minus3: ::std::os::raw::c_uchar,
    pub log2_diff_max_min_luma_coding_block_size: ::std::os::raw::c_uchar,
    pub log2_min_transform_block_size_minus2: ::std::os::raw::c_uchar,
    pub log2_diff_max_min_transform_block_size: ::std::os::raw::c_uchar,
    pub pcm_enabled_flag: ::std::os::raw::c_uchar,
    pub log2_min_pcm_luma_coding_block_size_minus3: ::std::os::raw::c_uchar,
    pub log2_diff_max_min_pcm_luma_coding_block_size: ::std::os::raw::c_uchar,
    pub pcm_sample_bit_depth_luma_minus1: ::std::os::raw::c_uchar,
    pub pcm_sample_bit_depth_chroma_minus1: ::std::os::raw::c_uchar,
    pub pcm_loop_filter_disabled_flag: ::std::os::raw::c_uchar,
    pub strong_intra_smoothing_enabled_flag: ::std::os::raw::c_uchar,
    pub max_transform_hierarchy_depth_intra: ::std::os::raw::c_uchar,
    pub max_transform_hierarchy_depth_inter: ::std::os::raw::c_uchar,
    pub amp_enabled_flag: ::std::os::raw::c_uchar,
    pub separate_colour_plane_flag: ::std::os::raw::c_uchar,
    pub log2_max_pic_order_cnt_lsb_minus4: ::std::os::raw::c_uchar,
    pub num_short_term_ref_pic_sets: ::std::os::raw::c_uchar,
    pub long_term_ref_pics_present_flag: ::std::os::raw::c_uchar,
    pub num_long_term_ref_pics_sps: ::std::os::raw::c_uchar,
    pub sps_temporal_mvp_enabled_flag: ::std::os::raw::c_uchar,
    pub sample_adaptive_offset_enabled_flag: ::std::os::raw::c_uchar,
    pub scaling_list_enable_flag: ::std::os::raw::c_uchar,
    pub IrapPicFlag: ::std::os::raw::c_uchar,
    pub IdrPicFlag: ::std::os::raw::c_uchar,
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    pub log2_max_transform_skip_block_size_minus2: ::std::os::raw::c_uchar,
    pub log2_sao_offset_scale_luma: ::std::os::raw::c_uchar,
    pub log2_sao_offset_scale_chroma: ::std::os::raw::c_uchar,
    pub high_precision_offsets_enabled_flag: ::std::os::raw::c_uchar,
    pub reserved1: [::std::os::raw::c_uchar; 10usize],
    pub dependent_slice_segments_enabled_flag: ::std::os::raw::c_uchar,
    pub slice_segment_header_extension_present_flag: ::std::os::raw::c_uchar,
    pub sign_data_hiding_enabled_flag: ::std::os::raw::c_uchar,
    pub cu_qp_delta_enabled_flag: ::std::os::raw::c_uchar,
    pub diff_cu_qp_delta_depth: ::std::os::raw::c_uchar,
    pub init_qp_minus26: ::std::os::raw::c_schar,
    pub pps_cb_qp_offset: ::std::os::raw::c_schar,
    pub pps_cr_qp_offset: ::std::os::raw::c_schar,
    pub constrained_intra_pred_flag: ::std::os::raw::c_uchar,
    pub weighted_pred_flag: ::std::os::raw::c_uchar,
    pub weighted_bipred_flag: ::std::os::raw::c_uchar,
    pub transform_skip_enabled_flag: ::std::os::raw::c_uchar,
    pub transquant_bypass_enabled_flag: ::std::os::raw::c_uchar,
    pub entropy_coding_sync_enabled_flag: ::std::os::raw::c_uchar,
    pub log2_parallel_merge_level_minus2: ::std::os::raw::c_uchar,
    pub num_extra_slice_header_bits: ::std::os::raw::c_uchar,
    pub loop_filter_across_tiles_enabled_flag: ::std::os::raw::c_uchar,
    pub loop_filter_across_slices_enabled_flag: ::std::os::raw::c_uchar,
    pub output_flag_present_flag: ::std::os::raw::c_uchar,
    pub num_ref_idx_l0_default_active_minus1: ::std::os::raw::c_uchar,
    pub num_ref_idx_l1_default_active_minus1: ::std::os::raw::c_uchar,
    pub lists_modification_present_flag: ::std::os::raw::c_uchar,
    pub cabac_init_present_flag: ::std::os::raw::c_uchar,
    pub pps_slice_chroma_qp_offsets_present_flag: ::std::os::raw::c_uchar,
    pub deblocking_filter_override_enabled_flag: ::std::os::raw::c_uchar,
    pub pps_deblocking_filter_disabled_flag: ::std::os::raw::c_uchar,
    pub pps_beta_offset_div2: ::std::os::raw::c_schar,
    pub pps_tc_offset_div2: ::std::os::raw::c_schar,
    pub tiles_enabled_flag: ::std::os::raw::c_uchar,
    pub uniform_spacing_flag: ::std::os::raw::c_uchar,
    pub num_tile_columns_minus1: ::std::os::raw::c_uchar,
    pub num_tile_rows_minus1: ::std::os::raw::c_uchar,
    pub column_width_minus1: [::std::os::raw::c_ushort; 21usize],
    pub row_height_minus1: [::std::os::raw::c_ushort; 21usize],
    pub reserved3: [::std::os::raw::c_uint; 15usize],
    pub NumBitsForShortTermRPSInSlice: ::std::os::raw::c_int,
    pub NumDeltaPocsOfRefRpsIdx: ::std::os::raw::c_int,
    pub NumPocTotalCurr: ::std::os::raw::c_int,
    pub NumPocStCurrBefore: ::std::os::raw::c_int,
    pub NumPocStCurrAfter: ::std::os::raw::c_int,
    pub NumPocLtCurr: ::std::os::raw::c_int,
    pub CurrPicOrderCntVal: ::std::os::raw::c_int,
    pub RefPicIdx: [::std::os::raw::c_int; 16usize],
    pub PicOrderCntVal: [::std::os::raw::c_int; 16usize],
    pub IsLongTerm: [::std::os::raw::c_uchar; 16usize],
    pub RefPicSetStCurrBefore: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetStCurrAfter: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetLtCurr: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetInterLayer0: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetInterLayer1: [::std::os::raw::c_uchar; 8usize],
    pub reserved4: [::std::os::raw::c_uint; 12usize],
    pub ScalingList4x4: [[::std::os::raw::c_uchar; 16usize]; 6usize],
    pub ScalingList8x8: [[::std::os::raw::c_uchar; 64usize]; 6usize],
    pub ScalingList16x16: [[::std::os::raw::c_uchar; 64usize]; 6usize],
    pub ScalingList32x32: [[::std::os::raw::c_uchar; 64usize]; 2usize],
    pub ScalingListDCCoeff16x16: [::std::os::raw::c_uchar; 6usize],
    pub ScalingListDCCoeff32x32: [::std::os::raw::c_uchar; 2usize],
}
impl Default for _CUVIDHEVCPICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDHEVCPICPARAMS = _CUVIDHEVCPICPARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CUVIDVP8PICPARAMS {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub first_partition_size: ::std::os::raw::c_uint,
    pub LastRefIdx: ::std::os::raw::c_uchar,
    pub GoldenRefIdx: ::std::os::raw::c_uchar,
    pub AltRefIdx: ::std::os::raw::c_uchar,
    pub __bindgen_anon_1: _CUVIDVP8PICPARAMS__bindgen_ty_1,
    pub Reserved1: [::std::os::raw::c_uchar; 4usize],
    pub Reserved2: [::std::os::raw::c_uint; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDVP8PICPARAMS__bindgen_ty_1 {
    pub __bindgen_anon_1: _CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1,
    pub wFrameTagFlags: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frame_type_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_frame_type_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn version_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_version_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn show_frame(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn show_frame_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_show_frame_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn update_mb_segmentation_data(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_update_mb_segmentation_data(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn update_mb_segmentation_data_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_update_mb_segmentation_data_raw(
        this: *mut Self,
        val: ::std::os::raw::c_uchar,
    ) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved2Bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved2Bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved2Bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved2Bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_type: ::std::os::raw::c_uchar,
        version: ::std::os::raw::c_uchar,
        show_frame: ::std::os::raw::c_uchar,
        update_mb_segmentation_data: ::std::os::raw::c_uchar,
        Reserved2Bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frame_type: u8 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let version: u8 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let show_frame: u8 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let update_mb_segmentation_data: u8 =
                unsafe { ::std::mem::transmute(update_mb_segmentation_data) };
            update_mb_segmentation_data as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Reserved2Bits: u8 = unsafe { ::std::mem::transmute(Reserved2Bits) };
            Reserved2Bits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _CUVIDVP8PICPARAMS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CUVIDVP8PICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDVP8PICPARAMS = _CUVIDVP8PICPARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDVP9PICPARAMS {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub LastRefIdx: ::std::os::raw::c_uchar,
    pub GoldenRefIdx: ::std::os::raw::c_uchar,
    pub AltRefIdx: ::std::os::raw::c_uchar,
    pub colorSpace: ::std::os::raw::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub reserved16Bits: ::std::os::raw::c_ushort,
    pub refFrameSignBias: [::std::os::raw::c_uchar; 4usize],
    pub bitDepthMinus8Luma: ::std::os::raw::c_uchar,
    pub bitDepthMinus8Chroma: ::std::os::raw::c_uchar,
    pub loopFilterLevel: ::std::os::raw::c_uchar,
    pub loopFilterSharpness: ::std::os::raw::c_uchar,
    pub modeRefLfEnabled: ::std::os::raw::c_uchar,
    pub log2_tile_columns: ::std::os::raw::c_uchar,
    pub log2_tile_rows: ::std::os::raw::c_uchar,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub segmentFeatureEnable: [[::std::os::raw::c_uchar; 4usize]; 8usize],
    pub segmentFeatureData: [[::std::os::raw::c_short; 4usize]; 8usize],
    pub mb_segment_tree_probs: [::std::os::raw::c_uchar; 7usize],
    pub segment_pred_probs: [::std::os::raw::c_uchar; 3usize],
    pub reservedSegment16Bits: [::std::os::raw::c_uchar; 2usize],
    pub qpYAc: ::std::os::raw::c_int,
    pub qpYDc: ::std::os::raw::c_int,
    pub qpChDc: ::std::os::raw::c_int,
    pub qpChAc: ::std::os::raw::c_int,
    pub activeRefIdx: [::std::os::raw::c_uint; 3usize],
    pub resetFrameContext: ::std::os::raw::c_uint,
    pub mcomp_filter_type: ::std::os::raw::c_uint,
    pub mbRefLfDelta: [::std::os::raw::c_uint; 4usize],
    pub mbModeLfDelta: [::std::os::raw::c_uint; 2usize],
    pub frameTagSize: ::std::os::raw::c_uint,
    pub offsetToDctParts: ::std::os::raw::c_uint,
    pub reserved128Bits: [::std::os::raw::c_uint; 4usize],
}
impl _CUVIDVP9PICPARAMS {
    #[inline]
    pub fn profile(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_profile(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn profile_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_profile_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn frameContextIdx(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_frameContextIdx(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frameContextIdx_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_frameContextIdx_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn frameType(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_frameType(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frameType_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_frameType_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn showFrame(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_showFrame(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn showFrame_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_showFrame_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn errorResilient(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_errorResilient(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn errorResilient_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_errorResilient_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn frameParallelDecoding(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_frameParallelDecoding(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frameParallelDecoding_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_frameParallelDecoding_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn subSamplingX(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_subSamplingX(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn subSamplingX_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_subSamplingX_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn subSamplingY(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_subSamplingY(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn subSamplingY_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_subSamplingY_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intraOnly(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_intraOnly(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intraOnly_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_intraOnly_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_high_precision_mv_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_allow_high_precision_mv_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn refreshEntropyProbs(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_refreshEntropyProbs(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn refreshEntropyProbs_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_refreshEntropyProbs_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved2Bits(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_reserved2Bits(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved2Bits_raw(this: *const Self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_reserved2Bits_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        profile: ::std::os::raw::c_ushort,
        frameContextIdx: ::std::os::raw::c_ushort,
        frameType: ::std::os::raw::c_ushort,
        showFrame: ::std::os::raw::c_ushort,
        errorResilient: ::std::os::raw::c_ushort,
        frameParallelDecoding: ::std::os::raw::c_ushort,
        subSamplingX: ::std::os::raw::c_ushort,
        subSamplingY: ::std::os::raw::c_ushort,
        intraOnly: ::std::os::raw::c_ushort,
        allow_high_precision_mv: ::std::os::raw::c_ushort,
        refreshEntropyProbs: ::std::os::raw::c_ushort,
        reserved2Bits: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let profile: u16 = unsafe { ::std::mem::transmute(profile) };
            profile as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let frameContextIdx: u16 = unsafe { ::std::mem::transmute(frameContextIdx) };
            frameContextIdx as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frameType: u16 = unsafe { ::std::mem::transmute(frameType) };
            frameType as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let showFrame: u16 = unsafe { ::std::mem::transmute(showFrame) };
            showFrame as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let errorResilient: u16 = unsafe { ::std::mem::transmute(errorResilient) };
            errorResilient as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let frameParallelDecoding: u16 =
                unsafe { ::std::mem::transmute(frameParallelDecoding) };
            frameParallelDecoding as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let subSamplingX: u16 = unsafe { ::std::mem::transmute(subSamplingX) };
            subSamplingX as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let subSamplingY: u16 = unsafe { ::std::mem::transmute(subSamplingY) };
            subSamplingY as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let intraOnly: u16 = unsafe { ::std::mem::transmute(intraOnly) };
            intraOnly as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let allow_high_precision_mv: u16 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let refreshEntropyProbs: u16 = unsafe { ::std::mem::transmute(refreshEntropyProbs) };
            refreshEntropyProbs as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let reserved2Bits: u16 = unsafe { ::std::mem::transmute(reserved2Bits) };
            reserved2Bits as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn segmentEnabled(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentEnabled(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentEnabled_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentEnabled_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn segmentMapUpdate(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentMapUpdate(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentMapUpdate_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentMapUpdate_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn segmentMapTemporalUpdate(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentMapTemporalUpdate(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentMapTemporalUpdate_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentMapTemporalUpdate_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn segmentFeatureMode(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentFeatureMode(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn segmentFeatureMode_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_segmentFeatureMode_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved4Bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved4Bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved4Bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved4Bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        segmentEnabled: ::std::os::raw::c_uchar,
        segmentMapUpdate: ::std::os::raw::c_uchar,
        segmentMapTemporalUpdate: ::std::os::raw::c_uchar,
        segmentFeatureMode: ::std::os::raw::c_uchar,
        reserved4Bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let segmentEnabled: u8 = unsafe { ::std::mem::transmute(segmentEnabled) };
            segmentEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let segmentMapUpdate: u8 = unsafe { ::std::mem::transmute(segmentMapUpdate) };
            segmentMapUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let segmentMapTemporalUpdate: u8 =
                unsafe { ::std::mem::transmute(segmentMapTemporalUpdate) };
            segmentMapTemporalUpdate as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let segmentFeatureMode: u8 = unsafe { ::std::mem::transmute(segmentFeatureMode) };
            segmentFeatureMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved4Bits: u8 = unsafe { ::std::mem::transmute(reserved4Bits) };
            reserved4Bits as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type CUVIDVP9PICPARAMS = _CUVIDVP9PICPARAMS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CUVIDPICPARAMS {
    pub PicWidthInMbs: ::std::os::raw::c_int,
    pub FrameHeightInMbs: ::std::os::raw::c_int,
    pub CurrPicIdx: ::std::os::raw::c_int,
    pub field_pic_flag: ::std::os::raw::c_int,
    pub bottom_field_flag: ::std::os::raw::c_int,
    pub second_field: ::std::os::raw::c_int,
    pub nBitstreamDataLen: ::std::os::raw::c_uint,
    pub pBitstreamData: *const ::std::os::raw::c_uchar,
    pub nNumSlices: ::std::os::raw::c_uint,
    pub pSliceDataOffsets: *const ::std::os::raw::c_uint,
    pub ref_pic_flag: ::std::os::raw::c_int,
    pub intra_pic_flag: ::std::os::raw::c_int,
    pub Reserved: [::std::os::raw::c_uint; 30usize],
    pub CodecSpecific: _CUVIDPICPARAMS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDPICPARAMS__bindgen_ty_1 {
    pub mpeg2: CUVIDMPEG2PICPARAMS,
    pub h264: CUVIDH264PICPARAMS,
    pub vc1: CUVIDVC1PICPARAMS,
    pub mpeg4: CUVIDMPEG4PICPARAMS,
    pub jpeg: CUVIDJPEGPICPARAMS,
    pub hevc: CUVIDHEVCPICPARAMS,
    pub vp8: CUVIDVP8PICPARAMS,
    pub vp9: CUVIDVP9PICPARAMS,
    pub CodecReserved: [::std::os::raw::c_uint; 1024usize],
}
impl Default for _CUVIDPICPARAMS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _CUVIDPICPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDPICPARAMS = _CUVIDPICPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDPROCPARAMS {
    pub progressive_frame: ::std::os::raw::c_int,
    pub second_field: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub unpaired_field: ::std::os::raw::c_int,
    pub reserved_flags: ::std::os::raw::c_uint,
    pub reserved_zero: ::std::os::raw::c_uint,
    pub raw_input_dptr: ::std::os::raw::c_ulonglong,
    pub raw_input_pitch: ::std::os::raw::c_uint,
    pub raw_input_format: ::std::os::raw::c_uint,
    pub raw_output_dptr: ::std::os::raw::c_ulonglong,
    pub raw_output_pitch: ::std::os::raw::c_uint,
    pub Reserved1: ::std::os::raw::c_uint,
    pub output_stream: CUstream,
    pub Reserved: [::std::os::raw::c_uint; 46usize],
    pub Reserved2: [*mut ::std::os::raw::c_void; 2usize],
}
impl Default for _CUVIDPROCPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDPROCPARAMS = _CUVIDPROCPARAMS;
pub type tcuvidGetDecoderCaps =
    ::std::option::Option<unsafe extern "C" fn(pdc: *mut CUVIDDECODECAPS) -> CUresult>;
pub type tcuvidCreateDecoder = ::std::option::Option<
    unsafe extern "C" fn(
        phDecoder: *mut CUvideodecoder,
        pdci: *mut CUVIDDECODECREATEINFO,
    ) -> CUresult,
>;
pub type tcuvidDestroyDecoder =
    ::std::option::Option<unsafe extern "C" fn(hDecoder: CUvideodecoder) -> CUresult>;
pub type tcuvidDecodePicture = ::std::option::Option<
    unsafe extern "C" fn(hDecoder: CUvideodecoder, pPicParams: *mut CUVIDPICPARAMS) -> CUresult,
>;
pub type tcuvidMapVideoFrame64 = ::std::option::Option<
    unsafe extern "C" fn(
        hDecoder: CUvideodecoder,
        nPicIdx: ::std::os::raw::c_int,
        pDevPtr: *mut ::std::os::raw::c_ulonglong,
        pPitch: *mut ::std::os::raw::c_uint,
        pVPP: *mut CUVIDPROCPARAMS,
    ) -> CUresult,
>;
pub type tcuvidUnmapVideoFrame64 = ::std::option::Option<
    unsafe extern "C" fn(hDecoder: CUvideodecoder, DevPtr: ::std::os::raw::c_ulonglong) -> CUresult,
>;
pub type tcuvidCtxLockCreate = ::std::option::Option<
    unsafe extern "C" fn(pLock: *mut CUvideoctxlock, ctx: CUcontext) -> CUresult,
>;
pub type tcuvidCtxLockDestroy =
    ::std::option::Option<unsafe extern "C" fn(lck: CUvideoctxlock) -> CUresult>;
pub type tcuvidCtxLock = ::std::option::Option<
    unsafe extern "C" fn(lck: CUvideoctxlock, reserved_flags: ::std::os::raw::c_uint) -> CUresult,
>;
pub type tcuvidCtxUnlock = ::std::option::Option<
    unsafe extern "C" fn(lck: CUvideoctxlock, reserved_flags: ::std::os::raw::c_uint) -> CUresult,
>;
pub type CUvideosource = *mut ::std::os::raw::c_void;
pub type CUvideoparser = *mut ::std::os::raw::c_void;
pub type CUvideotimestamp = ::std::os::raw::c_longlong;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaVideoState {
    cudaVideoState_Error = -1,
    cudaVideoState_Stopped = 0,
    cudaVideoState_Started = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaAudioCodec {
    cudaAudioCodec_MPEG1 = 0,
    cudaAudioCodec_MPEG2 = 1,
    cudaAudioCodec_MP3 = 2,
    cudaAudioCodec_AC3 = 3,
    cudaAudioCodec_LPCM = 4,
    cudaAudioCodec_AAC = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMAT {
    pub codec: cudaVideoCodec,
    pub frame_rate: CUVIDEOFORMAT__bindgen_ty_1,
    pub progressive_sequence: ::std::os::raw::c_uchar,
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    pub reserved1: ::std::os::raw::c_uchar,
    pub coded_width: ::std::os::raw::c_uint,
    pub coded_height: ::std::os::raw::c_uint,
    pub display_area: CUVIDEOFORMAT__bindgen_ty_2,
    pub chroma_format: cudaVideoChromaFormat,
    pub bitrate: ::std::os::raw::c_uint,
    pub display_aspect_ratio: CUVIDEOFORMAT__bindgen_ty_3,
    pub video_signal_description: CUVIDEOFORMAT__bindgen_ty_4,
    pub seqhdr_data_length: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_1 {
    pub numerator: ::std::os::raw::c_uint,
    pub denominator: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_2 {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_3 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub color_primaries: ::std::os::raw::c_uchar,
    pub transfer_characteristics: ::std::os::raw::c_uchar,
    pub matrix_coefficients: ::std::os::raw::c_uchar,
}
impl CUVIDEOFORMAT__bindgen_ty_4 {
    #[inline]
    pub fn video_format(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_video_format(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn video_format_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_video_format_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn video_full_range_flag(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_video_full_range_flag(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn video_full_range_flag_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_video_full_range_flag_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved_zero_bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved_zero_bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_zero_bits_raw(this: *const Self) -> ::std::os::raw::c_uchar {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_zero_bits_raw(this: *mut Self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        video_format: ::std::os::raw::c_uchar,
        video_full_range_flag: ::std::os::raw::c_uchar,
        reserved_zero_bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let video_format: u8 = unsafe { ::std::mem::transmute(video_format) };
            video_format as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let video_full_range_flag: u8 = unsafe { ::std::mem::transmute(video_full_range_flag) };
            video_full_range_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved_zero_bits: u8 = unsafe { ::std::mem::transmute(reserved_zero_bits) };
            reserved_zero_bits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for CUVIDEOFORMAT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUVIDEOFORMATEX {
    pub format: CUVIDEOFORMAT,
    pub raw_seqhdr_data: [::std::os::raw::c_uchar; 1024usize],
}
impl Default for CUVIDEOFORMATEX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CUAUDIOFORMAT {
    pub codec: cudaAudioCodec,
    pub channels: ::std::os::raw::c_uint,
    pub samplespersec: ::std::os::raw::c_uint,
    pub bitrate: ::std::os::raw::c_uint,
    pub reserved1: ::std::os::raw::c_uint,
    pub reserved2: ::std::os::raw::c_uint,
}
impl Default for CUAUDIOFORMAT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUvideopacketflags {
    CUVID_PKT_ENDOFSTREAM = 1,
    CUVID_PKT_TIMESTAMP = 2,
    CUVID_PKT_DISCONTINUITY = 4,
    CUVID_PKT_ENDOFPICTURE = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDSOURCEDATAPACKET {
    pub flags: tcu_ulong,
    pub payload_size: tcu_ulong,
    pub payload: *const ::std::os::raw::c_uchar,
    pub timestamp: CUvideotimestamp,
}
impl Default for _CUVIDSOURCEDATAPACKET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDSOURCEDATAPACKET = _CUVIDSOURCEDATAPACKET;
pub type PFNVIDSOURCECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDSOURCEDATAPACKET,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDSOURCEPARAMS {
    pub ulClockRate: ::std::os::raw::c_uint,
    pub uReserved1: [::std::os::raw::c_uint; 7usize],
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnVideoDataHandler: PFNVIDSOURCECALLBACK,
    pub pfnAudioDataHandler: PFNVIDSOURCECALLBACK,
    pub pvReserved2: [*mut ::std::os::raw::c_void; 8usize],
}
impl Default for _CUVIDSOURCEPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDSOURCEPARAMS = _CUVIDSOURCEPARAMS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CUvideosourceformat_flags {
    CUVID_FMT_EXTFORMATINFO = 256,
}
pub type tcuvidCreateVideoSource = ::std::option::Option<
    unsafe extern "C" fn(
        pObj: *mut CUvideosource,
        pszFileName: *const ::std::os::raw::c_char,
        pParams: *mut CUVIDSOURCEPARAMS,
    ) -> CUresult,
>;
pub type tcuvidCreateVideoSourceW = ::std::option::Option<
    unsafe extern "C" fn(
        pObj: *mut CUvideosource,
        pwszFileName: *const wchar_t,
        pParams: *mut CUVIDSOURCEPARAMS,
    ) -> CUresult,
>;
pub type tcuvidDestroyVideoSource =
    ::std::option::Option<unsafe extern "C" fn(obj: CUvideosource) -> CUresult>;
pub type tcuvidSetVideoSourceState = ::std::option::Option<
    unsafe extern "C" fn(obj: CUvideosource, state: cudaVideoState) -> CUresult,
>;
pub type tcuvidGetVideoSourceState =
    ::std::option::Option<unsafe extern "C" fn(obj: CUvideosource) -> cudaVideoState>;
pub type tcuvidGetSourceVideoFormat = ::std::option::Option<
    unsafe extern "C" fn(
        obj: CUvideosource,
        pvidfmt: *mut CUVIDEOFORMAT,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
pub type tcuvidGetSourceAudioFormat = ::std::option::Option<
    unsafe extern "C" fn(
        obj: CUvideosource,
        paudfmt: *mut CUAUDIOFORMAT,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDPARSERDISPINFO {
    pub picture_index: ::std::os::raw::c_int,
    pub progressive_frame: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub repeat_first_field: ::std::os::raw::c_int,
    pub timestamp: CUvideotimestamp,
}
pub type CUVIDPARSERDISPINFO = _CUVIDPARSERDISPINFO;
pub type PFNVIDSEQUENCECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDEOFORMAT,
    ) -> ::std::os::raw::c_int,
>;
pub type PFNVIDDECODECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDPICPARAMS,
    ) -> ::std::os::raw::c_int,
>;
pub type PFNVIDDISPLAYCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDPARSERDISPINFO,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _CUVIDPARSERPARAMS {
    pub CodecType: cudaVideoCodec,
    pub ulMaxNumDecodeSurfaces: ::std::os::raw::c_uint,
    pub ulClockRate: ::std::os::raw::c_uint,
    pub ulErrorThreshold: ::std::os::raw::c_uint,
    pub ulMaxDisplayDelay: ::std::os::raw::c_uint,
    pub uReserved1: [::std::os::raw::c_uint; 5usize],
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnSequenceCallback: PFNVIDSEQUENCECALLBACK,
    pub pfnDecodePicture: PFNVIDDECODECALLBACK,
    pub pfnDisplayPicture: PFNVIDDISPLAYCALLBACK,
    pub pvReserved2: [*mut ::std::os::raw::c_void; 7usize],
    pub pExtVideoInfo: *mut CUVIDEOFORMATEX,
}
impl Default for _CUVIDPARSERPARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDPARSERPARAMS = _CUVIDPARSERPARAMS;
pub type tcuvidCreateVideoParser = ::std::option::Option<
    unsafe extern "C" fn(pObj: *mut CUvideoparser, pParams: *mut CUVIDPARSERPARAMS) -> CUresult,
>;
pub type tcuvidParseVideoData = ::std::option::Option<
    unsafe extern "C" fn(obj: CUvideoparser, pPacket: *mut CUVIDSOURCEDATAPACKET) -> CUresult,
>;
pub type tcuvidDestroyVideoParser =
    ::std::option::Option<unsafe extern "C" fn(obj: CUvideoparser) -> CUresult>;
